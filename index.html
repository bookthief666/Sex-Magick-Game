<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>93 PROTOCOL: DUALITY</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@700;900&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #ff003c; /* Neon Red */
            --secondary: #ffd700; /* Gold */
            --bg-color: #030303;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
            width: 100vw;
            height: 100vh;
            position: fixed;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            background: #000;
            overflow: hidden;
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* CRT Scanline Effect */
        .scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
            opacity: 0.4;
        }
        
        .vignette {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, black 130%);
            pointer-events: none;
            z-index: 11;
        }

        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 20;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            transition: opacity 0.3s ease;
            padding: 20px;
            box-sizing: border-box;
        }

        #startScreen {
            background-size: cover;
            background-position: center;
            animation: bgBreath 15s infinite alternate ease-in-out;
        }
        
        #startScreen::before {
            content: '';
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: -1;
            backdrop-filter: blur(3px);
        }

        @keyframes bgBreath {
            0% { transform: scale(1); }
            100% { transform: scale(1.02); }
        }

        .hidden { opacity: 0 !important; pointer-events: none !important; display: none !important; }

        /* --- BUTTONS: GLOWING & CHANGING COLORS --- */
        .mystic-btn {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #fff;
            color: #fff;
            padding: 12px 20px;
            font-size: 0.9rem;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 3px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 220px;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(5px);
            margin: 8px;
            /* Constant color cycling animation for ALL buttons */
            animation: chromaticPulse 4s infinite alternate;
        }

        @keyframes chromaticPulse {
            0% { 
                border-color: #ff003c; 
                box-shadow: 0 0 10px #ff003c, inset 0 0 5px #ff003c;
                color: #fff;
            }
            33% {
                border-color: #ffd700;
                box-shadow: 0 0 15px #ffd700, inset 0 0 8px #ffd700;
                color: #ffeebb;
            }
            66% {
                border-color: #00f0ff;
                box-shadow: 0 0 10px #00f0ff, inset 0 0 5px #00f0ff;
                color: #e0ffff;
            }
            100% {
                border-color: #ff00ff;
                box-shadow: 0 0 10px #ff00ff, inset 0 0 5px #ff00ff;
                color: #fff;
            }
        }

        .mystic-btn:hover {
            background: #fff;
            color: #000 !important;
            animation: none;
            transform: scale(1.05);
            box-shadow: 0 0 30px #fff;
            border-color: #fff;
        }

        .mode-select-container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* --- TITLE TEXT: GLITCH & GLOW --- */
        .title-text {
            font-family: 'Cinzel Decorative', cursive;
            font-size: 5rem;
            color: #fff;
            position: relative;
            margin-bottom: 5px;
            letter-spacing: -2px;
            animation: glitchSkew 3s infinite linear alternate-reverse, titleGlow 4s infinite alternate;
        }
        
        @keyframes titleGlow {
            0% { text-shadow: -1px 0 #ff003c; }
            50% { text-shadow: 0 0 20px #ffd700, -2px 0 #ff003c; }
            100% { text-shadow: 0 0 10px #00f0ff, 2px 0 #00f0ff; }
        }

        .title-text::before, .title-text::after {
            content: "Sex Magick";
            position: absolute; left: 0; top: 0; width: 100%; height: 100%;
            background: #000; overflow: hidden; opacity: 0.7;
        }
        
        .title-text::before {
            left: 2px; text-shadow: -1px 0 #ff003c;
            clip: rect(24px, 550px, 90px, 0);
            animation: glitch-anim-1 2.5s infinite linear alternate-reverse;
        }
        
        .title-text::after {
            left: -2px; text-shadow: -1px 0 #00ffff;
            clip: rect(85px, 550px, 140px, 0);
            animation: glitch-anim-2 3s infinite linear alternate-reverse;
        }

        @keyframes glitchSkew {
            0% { transform: skew(0deg); }
            10% { transform: skew(-2deg); }
            20% { transform: skew(2deg); }
            30% { transform: skew(0deg); }
            40% { transform: skew(0deg); }
            50% { transform: skew(0deg); }
            60% { transform: skew(0deg); }
            70% { transform: skew(0deg); }
            80% { transform: skew(0deg); }
            90% { transform: skew(0deg); }
            100% { transform: skew(0deg); }
        }

        @keyframes glitch-anim-1 {
            0% { clip: rect(20px, 9999px, 80px, 0); }
            20% { clip: rect(70px, 9999px, 10px, 0); }
            40% { clip: rect(20px, 9999px, 80px, 0); }
            60% { clip: rect(10px, 9999px, 60px, 0); }
            80% { clip: rect(50px, 9999px, 20px, 0); }
            100% { clip: rect(60px, 9999px, 70px, 0); }
        }
        @keyframes glitch-anim-2 {
            0% { clip: rect(70px, 9999px, 10px, 0); }
            20% { clip: rect(10px, 9999px, 60px, 0); }
            40% { clip: rect(50px, 9999px, 20px, 0); }
            60% { clip: rect(20px, 9999px, 80px, 0); }
            80% { clip: rect(60px, 9999px, 70px, 0); }
            100% { clip: rect(20px, 9999px, 80px, 0); }
        }

        .level-indicator {
            position: absolute; bottom: 40px; width: 100%; text-align: center;
            font-size: 1.2rem; font-family: 'Cinzel Decorative', serif;
            font-weight: 700; letter-spacing: 8px; z-index: 15;
            text-transform: uppercase; color: rgba(255, 255, 255, 0.85);
            text-shadow: 2px 0px 0px rgba(255, 0, 60, 0.7), -2px 0px 0px rgba(0, 255, 255, 0.7);
            mix-blend-mode: screen; opacity: 0.8;
            animation: holoFloat 4s ease-in-out infinite; 
        }

        @keyframes holoFloat {
            0%, 100% { transform: translateY(0); opacity: 0.8; }
            50% { transform: translateY(-5px); opacity: 0.6; text-shadow: 3px 0px 0px rgba(255, 0, 60, 0.5), -3px 0px 0px rgba(0, 255, 255, 0.5); }
        }

        .score-display {
            position: absolute; top: 12%; width: 100%;
            text-align: center; font-size: 8rem;
            font-family: 'Cinzel Decorative', serif;
            color: rgba(255, 255, 255, 0.15); 
            z-index: 5; pointer-events: none;
            mix-blend-mode: overlay; font-weight: 900;
        }

        .void-active .score-display {
            color: rgba(0, 255, 255, 0.3);
            text-shadow: 0 0 20px rgba(0,255,255,0.5);
            animation: shake 0.5s infinite;
        }
        @keyframes shake { 0% { transform: translate(1px, 1px); } 100% { transform: translate(-1px, -1px); } }

        .leaderboard-container {
            background: rgba(10, 10, 10, 0.6);
            border: 1px solid rgba(255, 0, 60, 0.3);
            padding: 20px; margin-top: 15px; width: 320px;
            pointer-events: auto; backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(0,0,0,0.5); border-radius: 4px;
        }
        .leaderboard-title {
            color: var(--secondary);
            font-family: 'Cinzel Decorative', cursive;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 8px; margin-bottom: 10px;
            letter-spacing: 2px; font-size: 1.1rem;
        }
        .leaderboard-row {
            display: flex; justify-content: space-between;
            font-family: 'Orbitron', monospace;
            font-size: 0.85rem; padding: 4px 0; color: #ccc;
        }
        .rank-1 { color: #ffd700; text-shadow: 0 0 8px rgba(255, 215, 0, 0.5); font-weight: bold; }

        .progress-bar {
            width: 300px; height: 2px; background: #333; margin: 25px 0;
            position: relative;
        }
        .progress-fill {
            height: 100%; background: var(--primary); width: 0%;
            transition: width 0.2s ease; box-shadow: 0 0 10px var(--primary);
        }

        .instructions {
            position: absolute; bottom: 100px; width: 100%; text-align: center;
            font-size: 0.7rem; color: rgba(255, 255, 255, 0.4); letter-spacing: 4px;
            z-index: 15; font-family: 'Orbitron', sans-serif;
            animation: fadeOut 5s ease-in-out forwards; animation-delay: 2s; 
            pointer-events: none;
        }
        @keyframes fadeOut { 0% { opacity: 1; } 100% { opacity: 0; visibility: hidden; } }

        .pause-btn {
            position: absolute; top: 30px; right: 30px; width: 40px; height: 40px;
            background: rgba(0, 0, 0, 0.5); border: 1px solid var(--primary);
            color: var(--primary);
            border-radius: 50%; cursor: pointer; z-index: 25;
            display: flex; justify-content: center; align-items: center; font-size: 1.2rem;
            pointer-events: auto; backdrop-filter: blur(4px); transition: 0.3s;
        }
        .pause-btn:hover { background: var(--primary); color: #000; }

        .stats-panel {
            position: absolute; top: 30px; left: 30px;
            background: rgba(0, 0, 0, 0.5); border-left: 2px solid var(--primary);
            padding: 8px 12px; font-size: 0.7rem; color: #888; z-index: 25;
            pointer-events: auto; font-family: 'Orbitron', monospace; text-align: left;
            backdrop-filter: blur(4px);
        }
        
        .mobile-controls {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 30;
        }
        .mobile-jump-area {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 40%;
            pointer-events: auto; background: transparent;
            display: flex; justify-content: center; align-items: center;
        }
        .mobile-jump-indicator {
            background: rgba(255, 0, 60, 0.1);
            border: 1px solid rgba(255, 0, 60, 0.4);
            border-radius: 50%; width: 70px; height: 70px;
            display: flex; justify-content: center; align-items: center;
            color: rgba(255,255,255,0.7);
            font-size: 0.7rem; letter-spacing: 2px; text-transform: uppercase;
            backdrop-filter: blur(2px); animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { transform: scale(1); opacity: 0.5; } 50% { transform: scale(1.05); opacity: 0.8; } 100% { transform: scale(1); opacity: 0.5; } }

        /* --- RESPONSIVE ADAPTATION --- */
        @media (max-width: 768px) {
            .title-text { font-size: 3.5rem !important; }
            .score-display { font-size: 6rem !important; top: 15% !important; }
            .level-indicator { font-size: 1rem !important; bottom: 80px !important; letter-spacing: 5px !important;}
            .mystic-btn { padding: 12px 15px !important; font-size: 0.8rem !important; min-width: 150px !important; }
            .instructions { bottom: 140px !important; font-size: 0.6rem !important; }
            .leaderboard-container { width: 85% !important; padding: 15px; }
            .mode-select-container { gap: 10px; }
        }
        
        .loader {
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-top: 2px solid var(--primary);
            border-radius: 50%; width: 30px; height: 30px;
            animation: spin 1s linear infinite; margin: 0 auto 15px auto;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="scanlines"></div>
        <div class="vignette"></div>
        
        <div id="scoreUi" class="score-display">0</div>
        <div id="levelUi" class="level-indicator">INITIATION</div>
        
        <div id="mobileControls" class="mobile-controls hidden">
            <div class="mobile-jump-area">
                <div class="mobile-jump-indicator">TAP</div>
            </div>
        </div>
        
        <div id="startScreen" class="ui-layer" style="background-image: url('https://lh3.googleusercontent.com/d/1BXrXXd9TKSqCFNwvS-cJpNORbyvP6fkR=s0');">
            <div style="z-index: 2;">
                <h1 class="title-text">Sex Magick</h1>
                <p style="letter-spacing: 6px; color: #ff003c; margin-bottom: 30px; font-size: 0.9rem; text-shadow: 0 0 5px #ff003c; font-family: 'Orbitron'; text-transform: uppercase;">Do Your Will Foo</p>
            </div>
            
            <div id="loadingMsg">
                <div class="loader"></div>
                <p id="loadingText" style="letter-spacing: 4px; font-size: 0.8rem; color: #aaa; font-family: 'Orbitron';">CHARGING SIGIL...</p>
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill"></div>
                </div>
            </div>

            <div id="menuButtons" class="hidden" style="width: 100%; display: flex; flex-direction: column; align-items: center;">
                
                <div class="mode-select-container">
                    <button id="startHexBtn" class="mystic-btn">RITE OF HEXAGRAM</button>
                    <button id="startMonasBtn" class="mystic-btn">RITE OF MONAS</button>
                </div>
                
                <button id="settingsBtn" class="mystic-btn" style="min-width: 150px; padding: 10px; font-size: 0.8rem;">SETTINGS</button>
                
                <div class="leaderboard-container">
                    <div class="leaderboard-title">:: HIGH GNOSIS ::</div>
                    <div id="leaderboardList">LOADING SCORES...</div>
                </div>
                
                <p id="trackName" style="margin-top: 10px; font-size: 0.6rem; color: #444; letter-spacing: 1px;">SOURCE: GITHUB CDN</p>
            </div>
        </div>

        <div id="gameOverScreen" class="ui-layer hidden" style="background: rgba(0,0,0,0.85);">
            <h1 class="title-text" style="color: #ff003c; font-size: 3.5rem;">Good job foo</h1>
            <p style="font-size: 1rem; letter-spacing: 4px; margin-bottom: 20px; font-family: 'Orbitron'; color: #888;">RITUAL ENDED</p>
            <p class="text-xl mb-6 text-gray-300">WILL: <span id="finalScore" style="color: #fff; font-weight:bold; text-shadow: 0 0 10px #fff;">0</span></p>
            <p id="uploadStatus" style="color: var(--secondary); font-size: 0.8rem; margin-bottom: 10px;">CONNECTING TO ETHER...</p>
            <p id="highScoreMsg" style="color: #ffd700; margin-bottom: 20px; font-size: 0.9rem; letter-spacing: 2px;"></p>
            
            <button id="restartBtn" class="mystic-btn">REINCARNATE</button>
            <button id="voidBtn" class="mystic-btn">RETURN TO VOID</button>
        </div>

        <div id="pauseScreen" class="ui-layer hidden">
            <h1 class="title-text" style="font-size: 3rem; color: #ffd700;">MEDITATION</h1>
            <button id="resumeBtn" class="mystic-btn">RESUME</button>
            <button id="menuBtn" class="mystic-btn">ABORT</button>
        </div>

        <div id="settingsScreen" class="ui-layer hidden" style="background: rgba(0,0,0,0.9);">
            <h1 class="title-text" style="font-size: 2.5rem;">SACRED RITES</h1>
            <div style="width: 300px; margin: 20px 0; background: rgba(20,20,20,0.6); padding: 25px; border: 1px solid var(--primary); backdrop-filter: blur(10px);">
                <div style="display: flex; justify-content: space-between; margin: 15px 0; border-bottom: 1px solid #444; padding-bottom: 10px;">
                    <span>CHANT (MUSIC)</span>
                    <input type="checkbox" id="musicToggle" checked style="accent-color: var(--primary);">
                </div>
                <div style="display: flex; justify-content: space-between; margin: 15px 0; border-bottom: 1px solid #444; padding-bottom: 10px;">
                    <span>RESONANCE (SFX)</span>
                    <input type="checkbox" id="sfxToggle" checked style="accent-color: var(--primary);">
                </div>
                <div style="display: flex; justify-content: space-between; margin: 15px 0;">
                    <span>KUNDALINI (VIBE)</span>
                    <input type="checkbox" id="vibrationToggle" checked style="accent-color: var(--primary);">
                </div>
            </div>
            <button id="backBtn" class="mystic-btn">RETURN</button>
        </div>

        <button id="pauseBtn" class="pause-btn hidden">||</button>
        
        <div id="statsPanel" class="stats-panel">
            <div style="color: var(--primary); font-weight: bold; margin-bottom: 5px;">:: GNOSIS ::</div>
            FPS: <span id="fpsCounter" style="color: #fff;">0</span><br>
            AUDIO: <span id="audioStatus" style="color: #fff;">STANDBY</span>
        </div>

        <div id="instructions" class="instructions hidden">
            [ TAP / SPACE TO ASCEND ]
        </div>
    </div>

    <script>
        const AUDIO_BASE = "https://raw.githubusercontent.com/bookthief666/93-protocol-game-assets-/8c1973f1dada601ef830fa99ebfbbb67906b10cd/";
        const CDN_PREFIX = "https://cdn.jsdelivr.net/gh/bookthief666/93-protocol-game-assets-@662f3d608769e9e945295ac00d668447d974dc5c/";

        const CONFIG = {
            DEBUG: false,
            MENU_MUSIC: AUDIO_BASE + "iamerror%20-%20The%20Zelda%20Song%20(Hyr00l).mp3",
            GAME_PLAYLIST: [
                AUDIO_BASE + "iamerror%20-%20The%20Zelda%20Song%20(Hyr00l).mp3",
                AUDIO_BASE + "iamerror%20-%20Hyr00l%20Rough.mp4",
                AUDIO_BASE + "forget%20me%20remix%2093.flac",
                AUDIO_BASE + "eyedea%20_%201950s%20void%20the%C3%B4ry%20.mp3",
                AUDIO_BASE + "bookthief%F0%9F%A5%80%20-%20booothief-%20All%20gay%F0%9F%98%87%202024-07-10%2001_11%20(1).m4a",
                AUDIO_BASE + "bookthief%F0%9F%A5%80%20-%20How%20Much%20Does%20One%20Pay%202024-07-31%2018_24.m4a",
                AUDIO_BASE + "bookthief%20x%20inv.s.b.l.ty-%20Liquid%20Sovereignty.flac",
                AUDIO_BASE + "Post%20Mvdern%20-%20Pleiades%2018MAR25.flac",
                AUDIO_BASE + "MONOLITH%20bounce%201.mp3",
                AUDIO_BASE + "LEX_LFL_80_wurli_loop_ate_bit_Cm.wav"
            ],
            GAMEOVER_PLAYLIST: [
                AUDIO_BASE + "Post%20Mvdern%20-%20Pleiades%2018MAR25.flac",
                AUDIO_BASE + "LEX_LFL_80_wurli_loop_ate_bit_Cm.wav"
            ],
            BASE_URL: "https://lh3.googleusercontent.com/d/",
            IMG_SUFFIX: "=s0",
            
            // --- PHYSICS CONSTANTS ---
            INITIAL_GAME_SPEED: 2.9, // Reduced from 3.8
            SPEED_INCREASE_PER_LEVEL: 0.035, // Reduced from 0.08
            MAX_GAME_SPEED: 8.5, 
            PILLAR_SPAWN_BASE: 140, 
            PILLAR_WIDTH: 45,
            PILLAR_GAP: 200, 
            PILLAR_GAP_DECREASE_PER_5_LEVELS: 10, 
            MIN_PILLAR_GAP: 110, 
            ORB_SPAWN_CHANCE: 0.5,
            // These will be overridden by Mode selection
            PLAYER_JUMP_FORCE: -7.5,
            GRAVITY: 0.45,
            MAX_FALL_SPEED: 11,
            PLAYER_RADIUS: 16, 
            HITBOX_OFFSET: 4, 
            MOBILE_CONTROL_DEADZONE: 50,
            VOID_DURATION: 300, 
            VOID_INTERVAL: 5, 
        };

        const originalLevels = [
            { name: "MALKUTH", id: "1jI7bl3hsVOuzYf6u35L4bhHq5JUiBDa1" },
            { name: "YESOD", id: "1tHgxNvDO5md4z24hS81eTa9uva25mtr5" },
            { name: "HOD", id: "1Mtp6cP6lwGbPRhLWjQKKDijrLX53K4UR" },
            { name: "NETZACH", id: "1y1i5lxL1jVp37bIz1mtJh4-Puce-E5k0" },
            { name: "TIPHARETH", id: "12png0vOPyJC1Ab4Vffcw2R_K-yRw1sqj" },
            { name: "GEBURAH", id: "1le2Hox1ORxhL28fv7WujO0410vM6jUEJ" },
            { name: "CHESED", id: "1Gsq1xSx9ivfVEq6W2nCMrO-dOIMrSYrW" },
            { name: "DA'ATH", id: "1o601hrLi5RpuGL_kiVEoPXxXk2SCbM2z" },
            { name: "BINAH", id: "1iSYJfPsaYjA1rmRTsujLcn1Do-lBydF7" },
            { name: "CHOKMAH", id: "1PvOC62nv5HdsE1cuCF8RENY9Z8HTabn7" },
            { name: "KETHER", id: "1Ym_eyrXJEQUBA7Lg_2oUc6dQ-gy9yfGs" }
        ];

        const newImageIDs = [
            "1pJ5CUGyKXgkSgEREkKos1Kch5FmfUyxE", "1spT4HpO_4q9joE4x6bLjZQRlFTS9j-ie", "1YGzyjcjiCoPCLbYjJEiqT8USUhe4S6hM", "1ELjoJU7KDC88nUk_Vs57OKUG9oLl5E8N",
            "1faa2c3QFWhZ8UgvyZ_ZrlnyFsnsKRclm", "10W5oYkoqB9LC3YjvB_aozR0kG3hWaHka", "1l9Jdm0EQh8sgWh1W0wsXQCzrQM19Bfm9", "1BrHTF2dvfbRkyYfXAbPUiujwE1AJskY4",
            "1KqV8IYF7KDbmgHS3ph6eRQKl4uAAFG_u", "1sZ02UH_vb1xLaOvyETqptc5FuvOtVKd4", "1hLKOGYXCBemcIKt8OLEX4dHTn6bd88cr", "1g_DQeG6qldMBxHzZ82MOVoxk9APwb4NO",
            "1-SIvE5EZyUd7FKXJ7eyB4JCrtOpQoF18", "1S4y4YSCjxSb-b_U1BfMw_0PhabJ-METm", "1OL-kWl-TJNcZFPcsCAtynW2NWp-YYjGd", "1ApPgou40N2Q6GlNKNuyoQ2Gk5DqAfmw_",
            "1OeH1GMu2rDcwzdtWFZSB1WWe0OjkmxV0", "12Z92v9Mu9yNOnDTtK-bjMRZ8_2BAW2eW", "1Erf3DKxZpfbG57oGcUCjuHIhajsweLZz", "1qK22CJhJ1XgElL156uOQxYrucaRG16p0",
            "1euwdAWg-xQw7isR-JAiZ-krXQXOS8pi0", "1A3hT3mJibINtsr8CVxTmp71QsYgPB2JZ", "1QUVr-RK2kP7IIAuy0wX3pOZRQuyr-o-e", "1eF02YMyYBcgx7Ga20pXgoltzWXPYznfD",
            "1zx1vrrbuSA4xCFKXAHgXbkG1rX8PUPel", "1ds1iqXf90gy9PUFs80t4QOxamkJj0u1I", "14-t6dPPv5MeXe7LWPIp7Tjc8x4w5Vj2d", "1pUtIizMzVhjzB46dhah5mgz6Tr-vaSLO",
            "1ZOEkUW8q2s5zerS7BubYJU69RHk7_Zlo", "15ZHj0fLYu-4rEQy43BMJKDgXnnQ5FeyP", "1ZzgVT0O6XQzW3DUP4i1aoKd_DD5wV5LZ", "1rZHZM0bR_j6uiYZLS82J0BkbIfEUoXvY",
            "1CNrQ_EeMXQgHJGXxe7EHysQi_A0A9UE7", "1ubCqIg7ETOIsHGfBjQfVsRzjlZIpBP6E", "1pojzjR-uiQ0oTHRJxXXCW_w0hlJUCqyb", "1SnclBlH6sflhaTWzFhbcNedzNeh25-BV",
            "1thfc-9DnM4GhCi0zTbcX4MH-yaQEpomX", "1BXrXXd9TKSqCFNwvS-cJpNORbyvP6fkR", "1D1bOksatIt6Jw6Zq8Sbmhbq_GC_2EQHh", "1eP_Xnk80YnL3w3Q69wQmVo9_F0OaA3Wo",
            "1ARDOipcr0lB1GYf3gmhqlHXlpC23Q2JE", "1io39jfggXQl-OyvSFGIpgOtoIzHbml3M", "1o0rJmx3vEKITMx1ixP5iruOX2ujOT6VO", "1Irw61utgSGdip21OgTcYqz56LpWWS9fb",
            "19V2ObVoQn9R9bt1ZgMNEBJokaAjYdX_9", "1WWvLnkkPBN7Q0ZsGi16FL1anhPlti3Qd", "1HoYqC0SLc3nrSDnoW9KJ2-z8AnRWIz5M", "1oS0J3F-zh5H48-Qs5Mrm10dPR993kF-b",
            "1bRwsBEuZiAIZW_5f3WOZVI6-KVnCEslk", "1GLza2_RmR4c_KD_KGxbXPOoCAw9SITKl", "1uWFSChozQmHEnuJwXqiPNApXuAwPAzKS", "1t2hNBEudzIo19kuP8ksPY_cNetDdTd8P",
            "1KhMBL7a3NSggVerbyy53fQ-dLq11adwj", "1wgxalTR68YM7oIku8JYZYKtG50atEnG_", "1BceMgnHgVn9U_7EYnXQu9HDwEQY1UBa_", "14_iwYDQjp34-R_iby8QadKnI9m3zVnOu",
            "1cZ_ci9J80jnqCAdag8SQofYZw1dfsX3C", "15z3bGrCqUy8SQjX1dO5C1vlN3y4-soai", "10xAFw98B39Ou0SSeB4eWyoY2D_OLLPgz", "1CexZQw11p33u1-YA7JhPAkGV6NBCgd6e",
            "16t1EdHfHRpb7GmqNAfo2iKKm57qLfbKn", "12wQOhUztVCVEFV21fPDq-JXGi5zxdkeQ", "1-0u9JUH0oUHD1--5iaySxRpO_PuyxkH6", "1wnITY3i6XxOr1b3l6P0cT10LkEHQauO5"
        ].filter((value, index, self) => self.indexOf(value) === index);

        const esotericNames = [
            "KUNDALINI", "HIEROS GAMOS", "SACRED UNION", "RED TINCTURE", "WHITE GLUTEN", 
            "CUP OF BABALON", "BLOOD OF SAINTS", "CITY OF PYRAMIDS", "NIGHT OF PAN", 
            "HADIT'S FLAME", "NUIT'S EMBRACE", "LAW OF THELEMA", "LOVE UNDER WILL", 
            "GREAT WORK", "STONE OF WISE", "ELIXIR OF LIFE", "RED LION", "WHITE EAGLE",
            "ABRAHADABRA", "LASHTAL", "KA", "BA", "KHU", "SCARLET WOMAN", "THE BEAST",
            "AEON OF HORUS", "93", "AGAPE", "THELEMA", "VIA OVUM", "SPERMATOZOON",
            "HOMUNCULUS", "DIVINE EROS", "TANTRA", "YONI", "LINGAM", "O.T.O.", "A.'.A.'.",
            "STAR SAPPHIRE", "MASS OF PHOENIX", "LIBER AL", "RESH", "SAMEKH", "TZADDI"
        ];
        
        let MASTER_POOL = [...originalLevels];
        
        const palette = ["#ff003c", "#ff00ff", "#9d00ff", "#00f0ff", "#00ff9d", "#d4ff00", "#ff8800"];
        newImageIDs.forEach((id, index) => {
            const nameIndex = index % esotericNames.length;
            MASTER_POOL.push({
                name: esotericNames[nameIndex],
                id: id,
                color: "#000",
                accent: palette[index % palette.length],
                img: null,
                loaded: false
            });
        });

        // --- LOOTLOCKER CONFIG ---
        const LEADERBOARD_ID = "global_ritual";
        const API_KEY = "dev_44a2b8e7798a416eba598ee295a91d55";
        const Leaderboard = {
            token: null,
            async init() {
                const stored = localStorage.getItem("ritual_id");
                let payload = { game_version: "1.0", development_mode: true };
                if(stored) payload.guest_player_id = stored;
                try {
                    const r = await fetch("https://api.lootlocker.io/game/v2/session/guest", {
                        method: "POST",
                        headers: { "Content-Type": "application/json", "x-game-key": API_KEY },
                        body: JSON.stringify(payload)
                    });
                    const d = await r.json();
                    if(d.session_token) {
                        this.token = d.session_token;
                        localStorage.setItem("ritual_id", d.player_id);
                        this.fetchTop();
                    } else {
                        document.getElementById('leaderboardList').innerHTML = "OFFLINE";
                    }
                } catch(e) {
                    document.getElementById('leaderboardList').innerHTML = "OFFLINE";
                }
            },
            async fetchTop() {
                if(!this.token) return;
                try {
                    const r = await fetch(`https://api.lootlocker.io/game/v1/leaderboards/${LEADERBOARD_ID}/list?count=5`, {
                        headers: { "x-session-token": this.token }
                    });
                    const d = await r.json();
                    const list = document.getElementById('leaderboardList');
                    if(d.items && d.items.length > 0) {
                        list.innerHTML = d.items.map((i, idx) => `
                            <div class="leaderboard-row ${idx===0?'rank-1':''}">
                                <span>#${i.rank} ${i.player.id ? i.player.id.toString().substring(0,6) : "MAGE"}...</span>
                                <span>${i.score}</span>
                            </div>
                        `).join('');
                    } else {
                        list.innerHTML = "NO RITUALS YET";
                    }
                } catch(e) {}
            },
            async submit(score) {
                if(!this.token) return;
                const status = document.getElementById('uploadStatus');
                status.innerText = "UPLOADING...";
                try {
                    await fetch(`https://api.lootlocker.io/game/v1/leaderboards/${LEADERBOARD_ID}/submit`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json", "x-session-token": this.token },
                        body: JSON.stringify({ score: score })
                    });
                    status.innerText = "UPLOAD COMPLETE";
                    this.fetchTop();
                } catch(e) {
                    status.innerText = "UPLOAD FAILED";
                }
            }
        };

        const GameState = {
            START: 'start',
            LOADING: 'loading',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAME_OVER: 'gameover',
            SETTINGS: 'settings'
        };

        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        const optimizedShadow = {
            apply(ctx, blur, color) {
                if (isMobile) {
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = 'transparent';
                } else {
                    ctx.shadowBlur = blur;
                    ctx.shadowColor = color;
                }
            },
            clear(ctx) {
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }
        };

        const GlitchFX = {
            active: false, duration: 0, intensity: 1, type: 'rgb',
            rgbSplit(ctx, intensity) {
                const offset = Math.floor(Math.random() * 3 * intensity);
                const rOffset = Math.random() > 0.5 ? offset : -offset;
                const gOffset = Math.random() > 0.5 ? offset : -offset;
                const bOffset = Math.random() > 0.5 ? offset : -offset;
                if (Math.random() > 0.3) return null;
                return {
                    rOffset, gOffset, bOffset,
                    draw: function(ctx, width, height) {
                        const imageData = ctx.getImageData(0, 0, width, height);
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = width; tempCanvas.height = height;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.putImageData(imageData, 0, 0);
                        ctx.save();
                        ctx.globalCompositeOperation = 'screen';
                        ctx.globalAlpha = 0.8; ctx.drawImage(tempCanvas, rOffset, 0);
                        ctx.globalAlpha = 0.8; ctx.drawImage(tempCanvas, 0, gOffset);
                        ctx.globalAlpha = 0.8;
                        ctx.drawImage(tempCanvas, bOffset, bOffset);
                        ctx.restore();
                    }
                };
            },
            apply(ctx, currentTime) {
                if (!this.active || this.duration <= 0) return;
                const progress = this.duration / 100;
                this.intensity = Math.min(1, progress * 2);
                if (Math.random() > 0.8) {
                    const rgbEffect = this.rgbSplit(ctx, this.intensity);
                    if (rgbEffect) rgbEffect.draw(ctx, ctx.canvas.width, ctx.canvas.height);
                }
                this.duration -= 16;
                if (this.duration <= 0) { this.active = false; this.intensity = 1; }
            },
            trigger(duration = 100, type = 'all') {
                this.active = true;
                this.duration = duration; this.type = type; this.intensity = 1;
            }
        };

        const SFX = {
            audioContext: null,
            init() { if (!this.audioContext) this.audioContext = new (window.AudioContext || window.webkitAudioContext)(); },
            playTone(freq, type, duration, vol, detune = 0) {
                if (!game?.settings?.sfx) return;
                if (!this.audioContext) this.init();
                if (this.audioContext.state === 'suspended') this.audioContext.resume();
                try {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    osc.type = type;
                    osc.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                    osc.detune.setValueAtTime(detune, this.audioContext.currentTime);
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    gain.gain.setValueAtTime(vol, this.audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                    osc.start();
                    osc.stop(this.audioContext.currentTime + duration);
                } catch(e){}
            },
            jump() { this.playTone(400, 'square', 0.08, 0.1); this.playTone(600, 'sine', 0.05, 0.05, 100); },
            collect() { this.playTone(800, 'sine', 0.2, 0.1); this.playTone(1200, 'triangle', 0.1, 0.05, 50); },
            crash() { this.playTone(100, 'sawtooth', 0.5, 0.3); this.playTone(80, 'square', 0.3, 0.2, -100); },
            voidEnter() { this.playTone(200, 'sawtooth', 0.5, 0.2, -50); this.playTone(800, 'sine', 1.0, 0.1, 50); }, 
            levelUp() { 
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.5);
                osc.connect(gain); gain.connect(this.audioContext.destination);
                gain.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                osc.start(); osc.stop(this.audioContext.currentTime + 0.5);
            }
        };

        const Haptics = {
            // Enhanced Haptic Patterns
            jump() { if (game?.settings?.vibration && navigator.vibrate) navigator.vibrate([10]); },
            collect() { if (game?.settings?.vibration && navigator.vibrate) navigator.vibrate([15, 5, 15]); },
            crash() { if (game?.settings?.vibration && navigator.vibrate) navigator.vibrate([50, 100, 200, 100, 50]); },
            levelUp() { if (game?.settings?.vibration && navigator.vibrate) navigator.vibrate([50, 50, 50, 50, 100]); },
            start() { if (game?.settings?.vibration && navigator.vibrate) navigator.vibrate([30, 30]); }
        };

        const AudioSys = {
            bgm: null, localBlobUrl: null, currentMode: 'none', retryCount: 0, playlistQueue: [],
            setStatus(msg) {
                const el = document.getElementById('audioStatus');
                if (el) { el.textContent = msg; el.style.color = '#fff'; setTimeout(() => el.style.color = 'var(--primary)', 200); }
            },
            init() { this.setupAudioElement(CONFIG.MENU_MUSIC); this.currentMode = 'menu'; this.setStatus("MENU AUDIO RDY"); },
            setupAudioElement(src) {
                if (this.bgm) { this.bgm.pause(); this.bgm.src = ""; this.bgm.onended = null; }
                this.bgm = new Audio();
                this.bgm.src = src; this.bgm.volume = 0.8; this.bgm.preload = "auto";
                this.bgm.onwaiting = () => this.setStatus("BUFFERING...");
                this.bgm.onplaying = () => { this.setStatus("PLAYING"); this.retryCount = 0; };
                this.bgm.onerror = (e) => { console.warn("Audio error:", e); this.setStatus("LOAD ERROR"); };
            },
            shuffleQueue() {
                 this.playlistQueue = [...CONFIG.GAME_PLAYLIST];
                 for (let i = this.playlistQueue.length - 1; i > 0; i--) {
                     const j = Math.floor(Math.random() * (i + 1));
                     [this.playlistQueue[i], this.playlistQueue[j]] = [this.playlistQueue[j], this.playlistQueue[i]];
                 }
            },
            switchToGameMusic() {
                if (this.localBlobUrl) return;
                this.currentMode = 'game';
                if (this.playlistQueue.length === 0) this.shuffleQueue();
                const track = this.playlistQueue.pop(); 
                this.setStatus("LOADING NEXT TRACK");
                this.setupAudioElement(track);
                this.bgm.loop = false;
                this.bgm.onended = () => { if(this.currentMode === 'game') this.switchToGameMusic(); };
                this.play();
            },
            switchToGameOverMusic() {
                if (this.localBlobUrl) return;
                this.currentMode = 'gameover';
                const randomIndex = Math.floor(Math.random() * CONFIG.GAMEOVER_PLAYLIST.length);
                const track = CONFIG.GAMEOVER_PLAYLIST[randomIndex];
                this.setStatus("RITUAL ENDED");
                this.setupAudioElement(track);
                this.bgm.loop = true;
                this.play();
            },
            switchToMenuMusic() {
                if (this.localBlobUrl) return;
                this.currentMode = 'menu'; this.setStatus("LOADING MENU");
                this.setupAudioElement(CONFIG.MENU_MUSIC);
                this.bgm.loop = true;
            },
            play() { if (!this.bgm) return; const p = this.bgm.play(); if (p !== undefined) p.catch(e => { console.warn(e); this.setStatus("AUTOPLAY BLOCK"); }); },
            pause() { if (this.bgm) { this.bgm.pause(); this.setStatus("PAUSED"); } },
            resume() { if (this.bgm && this.bgm.paused) { this.bgm.play(); this.setStatus("RESUMED"); } },
            stop() { if (this.bgm) { this.bgm.pause(); this.bgm.currentTime = 0; this.setStatus("STOPPED"); } }
        };

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.root = document.documentElement;
                this.state = GameState.START;
                this.currentLevelIdx = 0;
                this.frames = 0;
                this.score = 0;
                this.highScore = localStorage.getItem('93protocol_highscore') || 0;
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED;
                this.shake = 0;
                this.lastFrameTime = 0;
                this.fps = 0;
                this.isMobile = isMobile;
                this.scaleFactor = 1;
                this.baseWidth = 800;
                this.baseHeight = 450;
                this.glitchEffect = false;
                this.glitchTimer = 0;
                this.tunnelOffset = 0;
                this.hitStop = 0;
                this.screenFlash = null;
                this.voidMode = false;
                this.voidTimer = 0;
                this.preVoidSpeed = 0;
                
                this.gameMode = 'HEX'; // 'HEX' or 'MONAS'

                this.backgroundParticles = [];
                this.player = null;
                this.particles = [];
                this.stars = []; // For standard stars
                this.warpStars = []; // For Monas warp stars
                this.obstacles = [];
                this.collectibles = [];
                this.pentagrams = [];
                this.gameLevels = []; 
                this.settings = { music: true, sfx: true, vibration: true };
                
                this.loadSettings();
                this.initEventListeners();
                this.resizeCanvas();
                this.preloadAllImages();
                this.createBackgroundParticles();
                
                AudioSys.init();
                SFX.init();
            }
            
            createBackgroundParticles() {
                this.backgroundParticles = [];
                for (let i = 0; i < 25; i++) { 
                    this.backgroundParticles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        z: Math.random() * 2 + 0.5,
                        size: Math.random() * 3 + 2,
                        speed: Math.random() * 0.5 + 0.1,
                        color: palette[Math.floor(Math.random() * palette.length)],
                        opacity: Math.random() * 0.4 + 0.1,
                        shape: Math.floor(Math.random() * 3) 
                    });
                }
            }
            
            triggerOrbGlitch() {
                GlitchFX.trigger(80, 'orb');
                this.screenFlash = { active: true, duration: 10, color: '#ffd700', intensity: 0.3 };
            }
            
            triggerLevelUpGlitch() {
                GlitchFX.trigger(150, 'level');
                this.screenFlash = {
                    active: true, duration: 20,
                    color: this.gameLevels[this.currentLevelIdx]?.accent || '#ff003c', intensity: 0.4
                };
            }
            
            triggerDeathGlitch() {
                GlitchFX.trigger(200, 'death');
                this.screenFlash = { active: true, duration: 30, color: '#ff003c', intensity: 0.6 };
            }
            
            applyScreenFlash() {
                if (!this.screenFlash || !this.screenFlash.active) return;
                this.ctx.save();
                this.ctx.fillStyle = this.screenFlash.color;
                this.ctx.globalAlpha = this.screenFlash.intensity * (this.screenFlash.duration / 30);
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.restore();
                this.screenFlash.duration--;
                if (this.screenFlash.duration <= 0) { this.screenFlash.active = false; }
            }
            
            initEventListeners() {
                window.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && this.state === GameState.PLAYING) this.playerJump();
                    else if (e.code === 'Escape') this.togglePause();
                });
                window.addEventListener('mousedown', (e) => {
                    if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'LABEL' && this.state === GameState.PLAYING) this.playerJump();
                });
                window.addEventListener('touchstart', (e) => {
                    if (this.state === GameState.PLAYING) {
                        e.preventDefault();
                        const touchY = e.touches[0].clientY;
                        if (touchY > window.innerHeight * 0.6) { this.playerJump(); }
                    }
                }, { passive: false });

                document.getElementById('startHexBtn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.gameMode = 'HEX';
                    if (this.settings.music) AudioSys.switchToGameMusic();
                    this.startGame();
                });
                document.getElementById('startMonasBtn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.gameMode = 'MONAS';
                    if (this.settings.music) AudioSys.switchToGameMusic();
                    this.startGame();
                });

                document.getElementById('restartBtn').addEventListener('click', (e) => {
                     e.stopPropagation();
                     if (this.settings.music) AudioSys.switchToGameMusic();
                     this.restartGame();
                });
                document.getElementById('voidBtn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.returnToMenu();
                });
                document.getElementById('pauseBtn').addEventListener('click', (e) => { e.stopPropagation(); this.togglePause(); });
                document.getElementById('resumeBtn').addEventListener('click', (e) => { e.stopPropagation(); this.togglePause(); });
                document.getElementById('menuBtn').addEventListener('click', (e) => { e.stopPropagation(); this.returnToMenu(); });
                document.getElementById('settingsBtn').addEventListener('click', (e) => { e.stopPropagation(); this.showSettings(); });
                document.getElementById('backBtn').addEventListener('click', (e) => { e.stopPropagation(); this.hideSettings(); });
                
                document.getElementById('musicToggle').addEventListener('change', (e) => {
                    this.settings.music = e.target.checked;
                    this.saveSettings();
                    if (!this.settings.music) AudioSys.stop();
                    else if (this.state === GameState.PLAYING) AudioSys.play();
                });
                document.getElementById('sfxToggle').addEventListener('change', (e) => {
                    this.settings.sfx = e.target.checked; this.saveSettings();
                });
                document.getElementById('vibrationToggle').addEventListener('change', (e) => {
                    this.settings.vibration = e.target.checked; this.saveSettings();
                });
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            loadSettings() {
                const saved = localStorage.getItem('93protocol_settings');
                if (saved) this.settings = { ...this.settings, ...JSON.parse(saved) };
                document.getElementById('musicToggle').checked = this.settings.music;
                document.getElementById('sfxToggle').checked = this.settings.sfx;
                document.getElementById('vibrationToggle').checked = this.settings.vibration;
            }
            
            saveSettings() { localStorage.setItem('93protocol_settings', JSON.stringify(this.settings)); }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.calculateScaleFactor();
                this.adjustForScreenSize();
            }
            
            calculateScaleFactor() {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const targetRatio = 16/9;
                if (width/height > targetRatio) { this.scaleFactor = height / this.baseHeight; } else { this.scaleFactor = width / this.baseWidth; }
                this.scaleFactor = Math.max(0.6, Math.min(this.scaleFactor, 1.5));
            }
            
            adjustForScreenSize() {
                const screenHeight = this.canvas.height;
                const screenWidth = this.canvas.width;
                let baseGap = CONFIG.PILLAR_GAP;
                
                // --- PORTRAIT MODE FIX ---
                // If height > width (Portrait), give more gap to compensate for low reaction time
                if (screenHeight > screenWidth) {
                    baseGap = Math.max(250, baseGap * 1.3); 
                    // Slow down game speed slightly in portrait mode for fairness
                    this.gameSpeed = Math.max(CONFIG.INITIAL_GAME_SPEED * 0.9, 2.0);
                } else if (screenHeight < 600) { 
                    baseGap = Math.min(270, baseGap * 1.08); 
                } else if (screenHeight > 800) { 
                    baseGap = Math.max(240, baseGap * 0.95); 
                }
                this.currentBaseGap = baseGap;
            }
            
            preloadAllImages() {
                const progressFill = document.getElementById('progressFill');
                const loadingText = document.getElementById('loadingText');
                let loadedCount = 0;
                const failsafe = setTimeout(() => { if (loadedCount < MASTER_POOL.length) { this.finishLoading(); } }, 5000);
                MASTER_POOL.forEach(lvl => {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.onload = () => {
                        lvl.img = img;
                        lvl.loaded = true;
                        loadedCount++;
                        const percent = Math.floor((loadedCount / MASTER_POOL.length) * 100);
                        progressFill.style.width = `${percent}%`;
                        loadingText.innerText = `CHARGING SIGIL... ${loadedCount}/${MASTER_POOL.length}`;
                        if (loadedCount >= MASTER_POOL.length) { clearTimeout(failsafe); this.finishLoading(); }
                    };
                    img.onerror = () => {
                        loadedCount++;
                        if (loadedCount >= MASTER_POOL.length) { clearTimeout(failsafe); this.finishLoading(); }
                    };
                    img.src = CONFIG.BASE_URL + lvl.id + CONFIG.IMG_SUFFIX;
                });
            }
            
            finishLoading() {
                Leaderboard.init();
                setTimeout(() => {
                    document.getElementById('loadingMsg').classList.add('hidden');
                    document.getElementById('menuButtons').classList.remove('hidden');
                }, 500);
            }
            
            prepareLevels() {
                let shuffled = [...MASTER_POOL];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                this.gameLevels = shuffled.map((lvl, index) => {
                    return { ...lvl, threshold: index * 5 };
                });
            }

            startGame() {
                this.prepareLevels();
                this.state = GameState.PLAYING;
                document.getElementById('startScreen').classList.add('hidden');
                document.getElementById('scoreUi').classList.remove('hidden');
                document.getElementById('pauseBtn').classList.remove('hidden');
                document.getElementById('instructions').classList.remove('hidden');
                
                if (this.isMobile) {
                    document.getElementById('mobileControls').classList.remove('hidden');
                    setTimeout(() => { document.getElementById('mobileControls').classList.add('hidden'); }, 5000);
                }
                
                if (CONFIG.DEBUG) document.getElementById('statsPanel').classList.remove('hidden');
                this.initGame();
                Haptics.start();
                this.gameLoop();
            }
            
            initGame() {
                this.player = new Player(this.gameMode);
                this.obstacles = [];
                this.collectibles = [];
                this.pentagrams = [];
                this.particles = [];
                
                // Initialize background based on mode
                this.stars = [];
                this.warpStars = [];
                
                if (this.gameMode === 'MONAS') {
                    for (let i = 0; i < 50; i++) this.warpStars.push(new WarpStar());
                } else {
                    for (let i = 0; i < 40; i++) this.stars.push(new Star());
                }

                this.score = 0;
                this.currentLevelIdx = 0;
                this.frames = 0;
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED;
                this.shake = 0;
                this.tunnelOffset = 0;
                this.hitStop = 0;
                this.voidMode = false;
                this.voidTimer = 0;
                document.getElementById('scoreUi').innerText = "0";
                document.getElementById('game-container').classList.remove('void-active');
                this.applyLevel();
            }
            
            applyLevel() {
                if (this.currentLevelIdx >= this.gameLevels.length) return;
                const l = this.gameLevels[this.currentLevelIdx];
                document.getElementById('levelUi').innerText = l.name;
                document.getElementById('levelUi').style.color = l.accent;
                document.getElementById('levelUi').style.textShadow = `0 0 15px ${l.accent}`;
                this.root.style.setProperty('--primary', l.accent);
                let newSpeed = CONFIG.INITIAL_GAME_SPEED + (this.currentLevelIdx * CONFIG.SPEED_INCREASE_PER_LEVEL);
                this.gameSpeed = Math.min(newSpeed, CONFIG.MAX_GAME_SPEED);
                if (this.currentLevelIdx > 0) {
                    this.triggerGlitchEffect();
                    Haptics.levelUp();
                    if (this.settings.sfx) SFX.levelUp();
                }
            }
            
            startVoidMode() {
                this.voidMode = true;
                this.voidTimer = CONFIG.VOID_DURATION;
                this.preVoidSpeed = this.gameSpeed;
                this.gameSpeed = this.gameSpeed * 1.8; 
                this.obstacles = [];
                this.collectibles = [];
                this.screenFlash = { active: true, duration: 20, color: '#00ffff', intensity: 0.5 };
                document.getElementById('game-container').classList.add('void-active');
                document.getElementById('levelUi').innerText = "THE VOID";
                document.getElementById('levelUi').style.color = "#00ffff";
                if (this.settings.sfx) SFX.voidEnter();
            }
            
            endVoidMode() {
                this.voidMode = false;
                this.gameSpeed = this.preVoidSpeed;
                document.getElementById('game-container').classList.remove('void-active');
                this.applyLevel(); 
            }

            triggerGlitchEffect() { this.glitchEffect = true; this.glitchTimer = 300; }
            
            applyGlitchEffect() {
                if (!this.glitchEffect) return;
                const ctx = this.ctx;
                const intensity = this.glitchTimer / 300;
                if (Math.random() > 0.7) {
                    const shiftX = Math.floor(Math.random() * 10 * intensity) - 5;
                    const shiftY = Math.floor(Math.random() * 10 * intensity) - 5;
                    ctx.save();
                    ctx.translate(shiftX, shiftY);
                    ctx.restore();
                }
                if (Math.random() > 0.8) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fillRect(0, Math.floor(Math.random() * this.canvas.height), this.canvas.width, 1);
                }
                this.glitchTimer -= 16;
                if (this.glitchTimer <= 0) { this.glitchEffect = false; }
            }
            
            getCurrentGap() {
                const baseGap = this.currentBaseGap || CONFIG.PILLAR_GAP;
                const levelsCompleted = Math.floor(this.currentLevelIdx / 5);
                const gapReduction = levelsCompleted * CONFIG.PILLAR_GAP_DECREASE_PER_5_LEVELS;
                const calculatedGap = Math.max(CONFIG.MIN_PILLAR_GAP, baseGap - gapReduction);
                return calculatedGap + (Math.sin(this.frames * 0.05) * 10);
            }
            
            checkLevel() {
                const nextIdx = this.currentLevelIdx + 1;
                if (nextIdx >= this.gameLevels.length) return;
                const next = this.gameLevels[nextIdx];
                if (this.score >= next.threshold) {
                    this.currentLevelIdx++;
                    if (this.currentLevelIdx % CONFIG.VOID_INTERVAL === 0) {
                        this.startVoidMode();
                    } else {
                        this.applyLevel();
                        this.shake = 12;
                        this.hitStop = 3;
                        this.triggerLevelUpGlitch();
                        for (let i = 0; i < 30; i++) {
                            this.particles.push(new Particle(
                                this.canvas.width / 2, this.canvas.height / 2, 
                                this.gameLevels[this.currentLevelIdx].accent, 12,
                                Math.random() > 0.5 ? 'hexagram' : 'triangle'
                            ));
                        }
                        if (this.settings.sfx) SFX.levelUp();
                        Haptics.levelUp();
                    }
                }
            }
            
            playerJump() {
                if (this.state === GameState.PLAYING) {
                    this.player.jump();
                    Haptics.jump();
                    GlitchFX.trigger(50, 'rgb');
                }
            }
            
            togglePause() {
                if (this.state === GameState.PLAYING) {
                    this.state = GameState.PAUSED;
                    document.getElementById('pauseScreen').classList.remove('hidden');
                    AudioSys.pause();
                } else if (this.state === GameState.PAUSED) {
                    this.state = GameState.PLAYING;
                    document.getElementById('pauseScreen').classList.add('hidden');
                    AudioSys.resume();
                    this.gameLoop();
                }
            }
            
            showSettings() {
                document.getElementById('startScreen').classList.add('hidden');
                document.getElementById('settingsScreen').classList.remove('hidden');
                this.state = GameState.SETTINGS;
            }
            
            hideSettings() {
                document.getElementById('settingsScreen').classList.add('hidden');
                document.getElementById('startScreen').classList.remove('hidden');
                this.state = GameState.START;
            }
            
            returnToMenu() {
                this.state = GameState.START;
                document.getElementById('pauseScreen').classList.add('hidden');
                document.getElementById('gameOverScreen').classList.add('hidden');
                document.getElementById('startScreen').classList.remove('hidden');
                document.getElementById('scoreUi').classList.add('hidden');
                document.getElementById('pauseBtn').classList.add('hidden');
                document.getElementById('instructions').classList.add('hidden');
                document.getElementById('statsPanel').classList.add('hidden');
                document.getElementById('mobileControls').classList.add('hidden');
                document.getElementById('game-container').classList.remove('void-active');
                if (this.settings.music) AudioSys.switchToMenuMusic();
            }
            
            gameOver() {
                if (this.state === GameState.GAME_OVER || this.voidMode) return;
                this.state = GameState.GAME_OVER;
                this.shake = 15;
                this.triggerDeathGlitch();
                if (this.settings.sfx) SFX.crash();
                Haptics.crash();
                for (let i = 0; i < 25; i++) {
                    this.particles.push(new Particle(
                        this.player.x, this.player.y, '#ff003c', 10,
                        Math.random() > 0.3 ? 'hexagram' : 'triangle'
                    ));
                }
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('93protocol_highscore', this.highScore);
                    document.getElementById('highScoreMsg').textContent = "NEW GNOSIS ATTAINED";
                } else {
                    document.getElementById('highScoreMsg').textContent = `BEST: ${this.highScore}`;
                }
                Leaderboard.submit(this.score);
                if (this.settings.music) AudioSys.switchToGameOverMusic(); else AudioSys.stop();
                document.getElementById('finalScore').innerText = this.score;
                document.getElementById('scoreUi').classList.add('hidden');
                document.getElementById('pauseBtn').classList.add('hidden');
                document.getElementById('instructions').classList.add('hidden');
                document.getElementById('statsPanel').classList.add('hidden');
                document.getElementById('mobileControls').classList.add('hidden');
                document.getElementById('gameOverScreen').classList.remove('hidden');
            }
            
            restartGame() {
                this.state = GameState.PLAYING;
                this.prepareLevels();
                document.getElementById('gameOverScreen').classList.add('hidden');
                document.getElementById('scoreUi').classList.remove('hidden');
                document.getElementById('pauseBtn').classList.remove('hidden');
                document.getElementById('instructions').classList.remove('hidden');
                if (this.isMobile) {
                    document.getElementById('mobileControls').classList.remove('hidden');
                    setTimeout(() => { document.getElementById('mobileControls').classList.add('hidden'); }, 5000);
                }
                if (CONFIG.DEBUG) document.getElementById('statsPanel').classList.remove('hidden');
                this.initGame();
                this.gameLoop();
            }
            
            gameLoop(currentTime = 0) {
                if (this.state !== GameState.PLAYING) return;
                if (this.lastFrameTime) {
                    this.fps = Math.round(1000 / (currentTime - this.lastFrameTime));
                    if (CONFIG.DEBUG) document.getElementById('fpsCounter').textContent = this.fps;
                }
                this.lastFrameTime = currentTime;
                if (this.hitStop > 0) {
                    this.hitStop--;
                    this.drawScene(currentTime);
                    requestAnimationFrame((time) => this.gameLoop(time));
                    return;
                }

                this.frames++;
                if (this.frames % 30 === 0 && Math.random() > 0.8) { GlitchFX.trigger(10, 'random'); }
                if (this.voidMode) {
                    this.voidTimer--;
                    if (this.voidTimer <= 0) { this.endVoidMode(); }
                }
                
                this.tunnelOffset += this.tunnelSpeed * (1 + this.gameSpeed * 0.1) || 10;
                this.updateGameObjects();
                this.drawScene(currentTime);
                requestAnimationFrame((time) => this.gameLoop(time));
            }

            drawScene(currentTime) {
                const lvl = this.gameLevels[this.currentLevelIdx];
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                const tunnelColor = this.voidMode ? '#00ffff' : lvl.accent;
                this.drawHyperspaceTunnel(tunnelColor);

                // --- BACKGROUND LOGIC SPLIT BASED ON MODE ---
                if (this.gameMode === 'MONAS') {
                    // 3D Expanding Stars for MONAS mode
                    const cx = this.canvas.width / 2;
                    const cy = this.canvas.height / 2;
                    // SLOW EXPANSION UPDATE
                    this.warpStars.forEach(s => {
                        // If in Void mode, speed up; otherwise, use 0.15x multiplier for SUPER SLOW floaty effect
                        const warpSpeed = this.voidMode ? this.gameSpeed : (this.gameSpeed * 0.15);
                        s.update(warpSpeed, this.voidMode);
                        s.draw(this.ctx, cx, cy, tunnelColor);
                    });
                } else {
                    // Standard Scrolling Stars for HEX mode
                    this.drawBackgroundParticles(tunnelColor);
                    // Draw Standard Stars
                    this.stars.forEach(s => {
                         s.update();
                         s.draw(this.ctx);
                    });
                }
                
                GlitchFX.apply(this.ctx, currentTime);
                this.applyScreenFlash();
                if (this.glitchEffect) this.applyGlitchEffect();
                
                this.ctx.save();
                if (this.shake > 0) {
                    this.ctx.translate((Math.random() - 0.5) * this.shake, (Math.random() - 0.5) * this.shake);
                    this.shake *= 0.9;
                }
                this.drawGameObjects();
                this.ctx.restore();
            }
            
            drawHyperspaceTunnel(color) {
                const ctx = this.ctx;
                const cx = this.canvas.width / 2;
                const cy = this.canvas.height / 2;
                const maxRadius = Math.max(this.canvas.width, this.canvas.height) * 0.8;
                const breath = (Math.sin(Date.now() * 0.002 * (1 + this.gameSpeed * 0.1)) + 1) * 0.5;
                
                ctx.strokeStyle = color;
                ctx.lineWidth = 1.5;
                optimizedShadow.apply(ctx, 15, color);
                const baseRotation = this.frames * 0.005;
                for (let i = 0; i < 8; i++) {
                    const progress = ((this.tunnelOffset + i * 60) % 300) / 300;
                    const radius = progress * maxRadius;
                    if (radius < 50) continue;
                    ctx.globalAlpha = (1 - progress * 0.8) * (0.8 + breath * 0.2);
                    ctx.save();
                    ctx.translate(cx, cy);
                    ctx.rotate(baseRotation + (i * 0.1)); 
                    ctx.beginPath();
                    for(let k = 0; k < 5; k++) {
                        const angle = (k * 4 * Math.PI / 5) - (Math.PI / 2);
                        const px = Math.cos(angle) * radius;
                        const py = Math.sin(angle) * radius;
                        if(k===0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                }
                optimizedShadow.clear(ctx);
                ctx.globalAlpha = 1;
                
                // Render Background Image (Common)
                const lvl = this.gameLevels[this.currentLevelIdx];
                if (!this.voidMode && lvl.loaded && lvl.img && lvl.img.complete) {
                    ctx.globalAlpha = 0.6;
                    try {
                        const img = lvl.img;
                        const canvasRatio = this.canvas.width / this.canvas.height;
                        const imgRatio = img.width / img.height;
                        let drawWidth, drawHeight, drawX, drawY;
                        if (canvasRatio > imgRatio) {
                            drawHeight = this.canvas.height;
                            drawWidth = img.width * (drawHeight / img.height);
                            drawX = (this.canvas.width - drawWidth) / 2;
                            drawY = 0;
                        } else {
                            drawWidth = this.canvas.width;
                            drawHeight = img.height * (drawWidth / img.width);
                            drawX = 0;
                            drawY = (this.canvas.height - drawHeight) / 2;
                        }
                        ctx.filter = 'blur(1px)';
                        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                        ctx.filter = 'none';
                    } catch (e) {}
                    ctx.globalAlpha = 1.0;
                }
            }

            drawBackgroundParticles(tunnelColor) {
                // Used for HEX mode
                 this.backgroundParticles.forEach(p => {
                    p.y += p.speed * (1 + this.gameSpeed * 0.1);
                    if (p.y > this.canvas.height) { 
                        p.y = 0; 
                        p.x = Math.random() * this.canvas.width;
                        p.shape = Math.floor(Math.random() * 3);
                    }
                    this.ctx.fillStyle = p.color;
                    this.ctx.globalAlpha = p.opacity;
                    this.ctx.save();
                    this.ctx.translate(p.x, p.y);
                    this.ctx.rotate(this.frames * 0.02);
                    if (p.shape === 0) { 
                        this.ctx.beginPath(); this.ctx.moveTo(0, -p.size); this.ctx.lineTo(p.size, p.size); this.ctx.lineTo(-p.size, p.size); this.ctx.fill();
                    } else if (p.shape === 1) { 
                        this.ctx.beginPath(); this.ctx.moveTo(0, -p.size); this.ctx.lineTo(p.size, 0); this.ctx.lineTo(0, p.size); this.ctx.lineTo(-p.size, 0); this.ctx.fill();
                    } else { 
                        this.ctx.fillRect(-p.size/2, -p.size*1.5, p.size, p.size*3);
                        this.ctx.fillRect(-p.size*1.5, -p.size/2, p.size*3, p.size);
                    }
                    this.ctx.restore();
                });
                this.ctx.globalAlpha = 1;
            }
            
            updateGameObjects() {
                const currentGap = this.getCurrentGap();
                const spawnRate = Math.floor(CONFIG.PILLAR_SPAWN_BASE / (this.gameSpeed / 3)); 
                
                if (!this.voidMode && this.frames % Math.max(20, spawnRate) === 0) {
                    const p = new Pillar(this.currentLevelIdx, currentGap);
                    this.obstacles.push(p);
                    if (Math.random() > (1 - CONFIG.ORB_SPAWN_CHANCE)) {
                        this.collectibles.push(new Orb(p.x + p.w / 2, p.top + p.gap / 2));
                    }
                }
                
                if (this.voidMode && this.frames % 10 === 0) {
                     const y = Math.random() * (this.canvas.height - 100) + 50;
                     this.pentagrams.push(new Pentagram(window.innerWidth, y));
                }
                
                this.obstacles.forEach((o, i) => {
                    o.update(this.gameSpeed);
                    const hitboxReduction = CONFIG.HITBOX_OFFSET;
                    const pLeft = this.player.x - this.player.r + hitboxReduction;
                    const pRight = this.player.x + this.player.r - hitboxReduction;
                    const pTop = this.player.y - this.player.r + hitboxReduction;
                    const pBottom = this.player.y + this.player.r - hitboxReduction;
                    
                    if (o.collides(pLeft, pRight, pTop, pBottom)) { this.gameOver(); }
                    
                    if (!o.marked && o.x + o.w < this.player.x) {
                        this.score++;
                        o.marked = true;
                        document.getElementById('scoreUi').innerText = this.score;
                        this.checkLevel();
                    }
                    if (o.x < -100) this.obstacles.splice(i, 1);
                });
                
                this.collectibles.forEach((c, i) => {
                    c.update(this.gameSpeed);
                    const dist = Math.hypot(this.player.x - c.x, this.player.y - c.y);
                    if (dist < this.player.r + c.r && !c.collected) {
                        this.score += 5;
                        document.getElementById('scoreUi').innerText = this.score;
                        c.collected = true;
                        this.triggerOrbGlitch();
                        this.hitStop = 3;
                        for (let k = 0; k < 20; k++) {
                            this.particles.push(new Particle(c.x, c.y, '#ffd700', 8));
                        }
                        if (this.settings.sfx) SFX.collect();
                        Haptics.collect();
                        this.collectibles.splice(i, 1);
                        this.checkLevel();
                    }
                    if (c.x < -50) this.collectibles.splice(i, 1);
                });

                this.pentagrams.forEach((p, i) => {
                    p.update(this.gameSpeed);
                    const dist = Math.hypot(this.player.x - p.x, this.player.y - p.y);
                    if (dist < this.player.r + p.size && !p.collected) {
                        this.score += 10;
                        document.getElementById('scoreUi').innerText = this.score;
                        p.collected = true;
                        for (let k = 0; k < 10; k++) {
                            this.particles.push(new Particle(p.x, p.y, '#00ffff', 12, 'hexagram'));
                        }
                        if (this.settings.sfx) SFX.collect();
                        this.pentagrams.splice(i, 1);
                    }
                    if (p.x < -50) this.pentagrams.splice(i, 1);
                });
                
                this.player.update();
                
                this.particles.forEach((p, i) => {
                    p.update();
                    if (p.life <= 0) this.particles.splice(i, 1);
                });
            }
            
            drawGameObjects() {
                const currentLvlConfig = this.gameLevels[this.currentLevelIdx];
                this.obstacles.forEach(o => o.draw(this.ctx, currentLvlConfig));
                this.collectibles.forEach(c => c.draw(this.ctx));
                this.pentagrams.forEach(p => p.draw(this.ctx));
                this.player.draw(this.ctx, currentLvlConfig);
                this.particles.forEach(p => p.draw(this.ctx));
            }
        }

        class Player {
            constructor(mode) {
                this.mode = mode; // 'HEX' or 'MONAS'
                this.x = window.innerWidth * 0.25;
                this.y = window.innerHeight / 2;
                this.vy = 0;
                this.r = CONFIG.PLAYER_RADIUS;
                this.rot = 0;
                this.trail = [];
                // Monas gets longer, smoother trail
                this.trailLength = (mode === 'MONAS') ? 20 : 12; 
                this.jumpCooldown = 0;
                this.scaleX = 1;
                this.scaleY = 1;
            }
            
            update() {
                // --- SPLIT PHYSICS FOR MODES ---
                if (this.mode === 'MONAS') {
                    // FLOANTY PHYSICS (Low Gravity, High Drag)
                    // This creates a "gliding" feel where you hang in the air
                    this.vy += 0.18; // Super low gravity (was 0.25)
                    // Add subtle air resistance
                    this.vy *= 0.98;
                } else {
                    // SNAPPY HEX PHYSICS (Standard Flappy Style)
                    this.vy += CONFIG.GRAVITY; // 0.45
                }
                
                if (this.vy > CONFIG.MAX_FALL_SPEED) this.vy = CONFIG.MAX_FALL_SPEED;
                
                this.y += this.vy;
                this.rot += 0.03;
                
                const stretch = Math.min(Math.abs(this.vy) * 0.04, 0.3);
                if (this.vy < 0) { this.scaleY = 1 + stretch; this.scaleX = 1 - stretch * 0.5; } 
                else { this.scaleY = 1 - stretch * 0.5; this.scaleX = 1 + stretch; }

                if (this.y > window.innerHeight - this.r * 1.5) { game.gameOver(); }
                if (this.y < this.r * 1.5) { this.y = this.r * 1.5; this.vy = 0; }
                
                if (this.jumpCooldown > 0) { this.jumpCooldown--; }
                
                // Trail update
                if (game.frames % 1 === 0) { 
                    this.trail.unshift({
                        x: this.x, y: this.y, r: this.r, life: 1.0,
                        rot: this.rot, scaleX: this.scaleX, scaleY: this.scaleY
                    });
                    if (this.trail.length > this.trailLength) this.trail.pop();
                }
                
                // MONAS gets slow decay, HEX gets fast decay
                const decay = (this.mode === 'MONAS') ? 0.02 : 0.08;
                this.trail.forEach(t => t.life -= decay);
            }
            
            draw(ctx, conf) {
                const hue = (game.frames * 2) % 360;
                const strokeColor = `hsl(${hue}, 100%, 60%)`;
                const shadowColor = `hsl(${hue}, 100%, 50%)`;

                // --- DRAW TRAIL ---
                this.trail.forEach((t, i) => {
                    if (t.life > 0) {
                        ctx.save();
                        // Increased opacity for neon look
                        ctx.globalAlpha = t.life * 0.6;
                        ctx.translate(t.x, t.y);
                        ctx.scale(t.scaleX, t.scaleY);
                        ctx.rotate(t.rot + (this.vy * 0.05));
                        
                        // Apply specific look based on mode
                        if (this.mode === 'MONAS') {
                            // Gold/Blue neon for Monas
                            optimizedShadow.apply(ctx, 20 * t.life, '#ffd700');
                            ctx.strokeStyle = '#ffd700';
                            ctx.lineWidth = 2;
                            this.drawMonasShape(ctx, t.r * 1.3 * t.life); // Reduced scale slightly
                        } else {
                            // Red/Pink neon for Hex
                            optimizedShadow.apply(ctx, 20 * t.life, '#ff003c');
                            ctx.strokeStyle = '#ff003c';
                            ctx.lineWidth = 1 + t.life;
                            this.drawHexShape(ctx, t.r * 0.8 * t.life);
                        }
                        
                        ctx.restore();
                    }
                });

                ctx.globalAlpha = 1.0;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.scaleX, this.scaleY);
                ctx.rotate(this.rot + (this.vy * 0.05));
                
                const r = this.r * 1.2;
                optimizedShadow.apply(ctx, 25, shadowColor);
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 3;
                
                // --- DRAW MAIN AVATAR ---
                if (this.mode === 'MONAS') {
                    // Scale up Monas by 1.3x for visibility (reduced from 1.5x)
                    this.drawMonasShape(ctx, r * 1.3);
                } else {
                    this.drawHexShape(ctx, r);
                }

                if (game.isMobile) {
                    ctx.save();
                    ctx.strokeStyle = shadowColor;
                    ctx.lineWidth = 8;
                    ctx.globalAlpha = 0.3;
                    ctx.stroke();
                    ctx.restore();
                }

                const pulse = Math.sin(game.frames * 0.1) * 0.5 + 1;
                ctx.fillStyle = "#fff";
                optimizedShadow.apply(ctx, 40 * pulse, "#fff");
                ctx.beginPath();
                ctx.arc(0, 0, 3 * pulse, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
            
            // --- UNICURSAL HEXAGRAM SHAPE ---
            drawHexShape(ctx, r) {
                // Unicursal hexagram points
                const points = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (i * 60 - 90) * Math.PI / 180;
                    points.push({ x: Math.cos(angle) * r, y: Math.sin(angle) * r });
                }
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                ctx.lineTo(points[2].x, points[2].y);
                ctx.lineTo(points[5].x, points[5].y);
                ctx.lineTo(points[3].x, points[3].y);
                ctx.lineTo(points[1].x, points[1].y);
                ctx.lineTo(points[4].x, points[4].y);
                ctx.lineTo(points[0].x, points[0].y);
                ctx.closePath();
                ctx.stroke();
            }

            // --- MONAS HIEROGLYPHICA SHAPE ---
            drawMonasShape(ctx, r) {
                const s = r * 0.8; 
                ctx.beginPath();
                // 1. The Crescent (Top)
                ctx.arc(0, -s, s * 0.4, 0, Math.PI, false);
                // 2. The Sun (Circle)
                ctx.moveTo(s*0.4, -s*0.4);
                ctx.arc(0, -s*0.4, s*0.4, 0, Math.PI * 2);
                // 3. The Center Point
                ctx.moveTo(1, -s*0.4);
                ctx.arc(0, -s*0.4, 1, 0, Math.PI * 2);
                // 4. The Cross
                ctx.moveTo(0, 0); // Bottom of circle
                ctx.lineTo(0, s); // Down stem
                ctx.moveTo(-s*0.6, s*0.4); // Cross bar left
                ctx.lineTo(s*0.6, s*0.4); // Cross bar right
                // 5. The Aries (Bottom)
                ctx.moveTo(-s*0.4, s); 
                ctx.bezierCurveTo(-s*0.6, s, -s*0.6, s*0.8, -s*0.4, s*0.8); // Left hook
                ctx.lineTo(s*0.4, s*0.8);
                ctx.bezierCurveTo(s*0.6, s*0.8, s*0.6, s, s*0.4, s); // Right hook
                
                ctx.stroke();
            }

            jump() {
                if (this.jumpCooldown > 0) return;
                
                // --- SPLIT JUMP PHYSICS FOR MODES ---
                if (this.mode === 'MONAS') {
                    // Gentle impulse for floaty mode
                    this.vy = -5.8; // Increased from -4.8 to be higher but floaty
                } else {
                    // Snappy jump for Hex mode
                    this.vy = CONFIG.PLAYER_JUMP_FORCE; // -7.5
                }
                
                this.jumpCooldown = game.isMobile ? 8 : 5;
                if (Math.random() > 0.7) GlitchFX.trigger(40, 'jump');
                
                for (let i = 0; i < (game.isMobile ? 10 : 12); i++) {
                    const type = Math.random() > 0.7 ? 'hexagram' : Math.random() > 0.4 ? 'triangle' : 'circle';
                    game.particles.push(new Particle(this.x, this.y, '#fff', 3, type));
                }
                if (game.settings.sfx) SFX.jump();
                Haptics.jump();
                GlitchFX.trigger(50, 'rgb');
            }
        }

        class Pillar {
            constructor(lvlIndex, currentGap) {
                this.x = window.innerWidth;
                this.w = CONFIG.PILLAR_WIDTH;
                this.gap = currentGap;
                const maxTop = window.innerHeight - this.gap - 50;
                const minTop = 30;
                this.top = Math.random() * (maxTop - minTop) + minTop;
                this.baseTop = this.top; 
                this.marked = false;
                this.lvl = lvlIndex;
                this.rotation = Math.random() * Math.PI * 2;
                this.innerPattern = Math.floor(Math.random() * 3);
                this.pulse = 0;
                this.hasWarning = game.isMobile && Math.random() > 0.5;
                this.warningAlpha = 1;
            }
            
            update(speed) { 
                this.x -= speed;
                this.pulse += 0.05;
                this.rotation += 0.005;
                if (this.hasWarning) { this.warningAlpha -= 0.01; }
                const breathe = Math.sin(game.frames * 0.05) * 5;
                this.top = this.baseTop + breathe;
            }
            
            collides(pLeft, pRight, pTop, pBottom) {
                 const pillarLeft = this.x;
                 const pillarRight = this.x + this.w;
                 const topPillarBottom = this.top;
                 const topPillarTop = 0;
                 const bottomPillarTop = this.top + this.gap;
                 const bottomPillarBottom = window.innerHeight;
                 
                 const horizontalOverlap = pRight > pillarLeft && pLeft < pillarRight;
                 const hittingTopPillar = horizontalOverlap && pBottom > topPillarTop && pTop < topPillarBottom;
                 const hittingBottomPillar = horizontalOverlap && pTop < bottomPillarBottom && pBottom > bottomPillarTop;
                 
                 return hittingTopPillar || hittingBottomPillar;
            }
            
            draw(ctx, conf) {
                const hue = (game.frames * 0.5 + this.x * 0.1) % 360;
                const mainColor = `hsl(${hue}, 100%, 60%)`;
                const innerColor = `hsl(${(hue + 60) % 360}, 100%, 70%)`;
                const glowColor = `hsl(${hue}, 100%, 50%)`;
                
                if (this.hasWarning && this.x < window.innerWidth * 0.7 && this.warningAlpha > 0) {
                    ctx.save();
                    ctx.globalAlpha = this.warningAlpha * 0.3;
                    ctx.fillStyle = '#ff003c';
                    ctx.fillRect(this.x - 10, 0, this.w + 20, window.innerHeight);
                    ctx.restore();
                }
                
                ctx.save();
                ctx.translate(this.x + this.w/2, 0);
                
                optimizedShadow.apply(ctx, 30, glowColor);
                ctx.strokeStyle = mainColor;
                ctx.lineWidth = 4;
                ctx.fillStyle = "rgba(0,0,0,0.7)";
                const topHeight = this.top + 10;
                ctx.beginPath();
                ctx.moveTo(-this.w/2, -10);
                ctx.lineTo(this.w/2, -10);
                
                const jagCount = 5;
                for (let i = 0; i <= jagCount; i++) {
                    const x = this.w/2 - (i * this.w/jagCount);
                    const y = -10 + (i % 2 === 0 ? 8 : -4);
                    ctx.lineTo(x, y);
                }
                
                ctx.lineTo(-this.w/2, topHeight);
                ctx.lineTo(-this.w/2, -10);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.save();
                ctx.translate(0, topHeight/2);
                ctx.rotate(this.rotation);
                ctx.globalAlpha = 0.4;
                ctx.strokeStyle = innerColor;
                ctx.lineWidth = 1.5;
                this.drawPattern(ctx, Math.min(this.w, topHeight) * 0.3);
                ctx.restore();

                const botY = this.top + this.gap;
                const botHeight = window.innerHeight - botY + 10;
                ctx.beginPath();
                ctx.moveTo(-this.w/2, botY);
                ctx.lineTo(this.w/2, botY);
                for (let i = 0; i <= jagCount; i++) {
                    const x = this.w/2 - (i * this.w/jagCount);
                    const y = botY + (i % 2 === 0 ? -4 : 8);
                    ctx.lineTo(x, y);
                }
                
                ctx.lineTo(this.w/2, botY + botHeight);
                ctx.lineTo(-this.w/2, botY + botHeight);
                ctx.lineTo(-this.w/2, botY);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.save();
                ctx.translate(0, botY + botHeight/2);
                ctx.rotate(-this.rotation);
                ctx.globalAlpha = 0.4;
                ctx.strokeStyle = innerColor;
                ctx.lineWidth = 1.5;
                this.drawPattern(ctx, Math.min(this.w, botHeight) * 0.3);
                ctx.restore();
                
                ctx.restore();
                optimizedShadow.clear(ctx);
                ctx.globalAlpha = 1.0;
            }

            drawPattern(ctx, size) {
                if (this.innerPattern === 0) {
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = Math.cos(angle) * size;
                        const y = Math.sin(angle) * size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                } else if (this.innerPattern === 1) {
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size * 0.866, size * 0.5);
                    ctx.lineTo(-size * 0.866, size * 0.5);
                    ctx.closePath();
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.moveTo(-size, 0);
                    ctx.lineTo(size, 0);
                    ctx.moveTo(0, -size);
                    ctx.lineTo(0, size);
                    ctx.stroke();
                }
            }
        }

        class Orb {
            constructor(x, y) {
                this.x = x;
                this.y = y; 
                this.r = 9;
                this.collected = false;
                this.float = Math.random() * Math.PI * 2;
                this.pulse = 0;
                this.rotation = 0;
            }
            
            update(speed) {
                this.x -= speed;
                this.float += 0.1;
                this.pulse += 0.15;
                this.rotation += 0.02;
                this.y += Math.sin(this.float) * 0.8;
            }
            
            draw(ctx) {
                if (this.collected) return;
                const pulseSize = this.r + Math.sin(this.pulse) * 3;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                optimizedShadow.apply(ctx, 25, '#ffd700');
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
                ctx.stroke();
                
                optimizedShadow.apply(ctx, 30, '#fff');
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.9;
                const r = pulseSize * 0.7;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i * 60) * Math.PI / 180;
                    const x = Math.cos(angle) * r;
                    const y = Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
        }

        class Pentagram {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 20;
                this.collected = false;
                this.rotation = 0;
                this.hue = Math.random() * 360;
            }
            update(speed) {
                this.x -= speed;
                this.rotation += 0.1;
                this.hue += 10;
            }
            draw(ctx) {
                if (this.collected) return;
                const color = `hsl(${this.hue}, 100%, 70%)`;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                optimizedShadow.apply(ctx, 20, color);
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                for(let k = 0; k < 5; k++) {
                    const angle = (k * 4 * Math.PI / 5) - (Math.PI / 2);
                    const px = Math.cos(angle) * this.size;
                    const py = Math.sin(angle) * this.size;
                    if(k===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.stroke();
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
        }

        class Particle {
            constructor(x, y, c, speed, type = 'circle') {
                this.x = x;
                this.y = y; 
                this.c = c;
                this.vx = (Math.random() - 0.5) * speed;
                this.vy = (Math.random() - 0.5) * speed;
                this.life = 1; 
                this.size = Math.random() * 3 + 2;
                this.type = type;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.2;
                this.glow = Math.random() > 0.5;
            }
            
            update() { 
                this.x += this.vx;
                this.y += this.vy; 
                this.vx *= 0.97;
                this.vy *= 0.97;
                this.life -= 0.03; 
                this.rotation += this.rotationSpeed;
                this.size *= 0.98;
                if (game.isMobile) { this.life -= 0.01; }
            }
            
            draw(ctx) {
                if (this.life <= 0) return;
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.c;
                if (this.glow && this.life > 0.3) {
                    optimizedShadow.apply(ctx, 20 * this.life, this.c);
                }
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                if (this.type === 'hexagram') {
                    const r = this.size * 0.8;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 'triangle') {
                    const r = this.size;
                    ctx.beginPath();
                    ctx.moveTo(0, -r);
                    ctx.lineTo(r * 0.866, r * 0.5);
                    ctx.lineTo(-r * 0.866, r * 0.5);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
        }
        
        // --- STAR CLASSES FOR DIFFERENT MODES ---
        class Star {
            constructor() {
                this.x = Math.random() * window.innerWidth;
                this.y = Math.random() * window.innerHeight;
                this.size = Math.random() * 2;
                this.speed = Math.random() * 0.5 + 0.1;
                this.alpha = Math.random() * 0.5 + 0.2;
                this.twinkle = Math.random() * Math.PI * 2;
            }
            update() {
                this.y += this.speed;
                if (this.y > window.innerHeight) {
                    this.y = 0;
                    this.x = Math.random() * window.innerWidth;
                }
                this.twinkle += 0.05;
                this.alpha = 0.3 + Math.sin(this.twinkle) * 0.2;
            }
            draw(ctx) {
                const conf = game.gameLevels[game.currentLevelIdx];
                ctx.fillStyle = conf ? conf.accent : '#fff';
                ctx.globalAlpha = this.alpha;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1.0;
            }
        }

        class WarpStar {
            constructor() { this.reset(); }
            reset() {
                this.x = (Math.random() - 0.5) * window.innerWidth;
                this.y = (Math.random() - 0.5) * window.innerHeight;
                this.z = Math.random() * window.innerWidth;
                this.pz = this.z;
            }
            update(speed, isVoid) {
                const speedFactor = isVoid ? 25 : 10;
                this.z -= speed * speedFactor * 0.1;
                if (this.z < 1) {
                    this.reset();
                    this.z = window.innerWidth;
                    this.pz = this.z;
                }
            }
            draw(ctx, cx, cy, color) {
                const sx = (this.x / this.z) * 100 + cx;
                const sy = (this.y / this.z) * 100 + cy;
                const alpha = (window.innerWidth - this.z) / window.innerWidth;
                ctx.fillStyle = color;
                ctx.globalAlpha = alpha;
                const size = (1 - this.z / window.innerWidth) * 3;
                ctx.fillRect(sx, sy, size, size);
                ctx.globalAlpha = 1.0;
            }
        }

        let game;
        document.addEventListener('DOMContentLoaded', () => {
            game = new Game();
        });
    </script>
</body>
</html>

        canvas { display: block; width: 100%; height: 100%; }

        /* CRT Scanline Effect */
        .scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
            opacity: 0.4;
        }
        
        .vignette {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, black 130%);
            pointer-events: none;
            z-index: 11;
        }

        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 20;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            transition: opacity 0.3s ease;
            padding: 20px;
            box-sizing: border-box;
        }

        #startScreen {
            background-size: cover;
            background-position: center;
            animation: bgBreath 15s infinite alternate ease-in-out;
        }
        
        #startScreen::before {
            content: '';
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: -1;
            backdrop-filter: blur(3px);
        }

        @keyframes bgBreath {
            0% { transform: scale(1); }
            100% { transform: scale(1.02); }
        }

        .hidden { opacity: 0 !important; pointer-events: none !important; display: none !important; }

        /* --- BUTTONS: GLOWING & CHANGING COLORS --- */
        .mystic-btn {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #fff;
            color: #fff;
            padding: 12px 20px;
            font-size: 0.9rem;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 3px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 220px;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(5px);
            margin: 8px;
            /* Constant color cycling animation for ALL buttons */
            animation: chromaticPulse 4s infinite alternate;
        }

        @keyframes chromaticPulse {
            0% { 
                border-color: #ff003c; 
                box-shadow: 0 0 10px #ff003c, inset 0 0 5px #ff003c;
                color: #fff;
            }
            33% {
                border-color: #ffd700;
                box-shadow: 0 0 15px #ffd700, inset 0 0 8px #ffd700;
                color: #ffeebb;
            }
            66% {
                border-color: #00f0ff;
                box-shadow: 0 0 10px #00f0ff, inset 0 0 5px #00f0ff;
                color: #e0ffff;
            }
            100% {
                border-color: #ff00ff;
                box-shadow: 0 0 10px #ff00ff, inset 0 0 5px #ff00ff;
                color: #fff;
            }
        }

        .mystic-btn:hover {
            background: #fff;
            color: #000 !important;
            animation: none;
            transform: scale(1.05);
            box-shadow: 0 0 30px #fff;
            border-color: #fff;
        }

        .mode-select-container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* --- TITLE TEXT: GLITCH & GLOW --- */
        .title-text {
            font-family: 'Cinzel Decorative', cursive;
            font-size: 5rem;
            color: #fff;
            position: relative;
            margin-bottom: 5px;
            letter-spacing: -2px;
            animation: glitchSkew 3s infinite linear alternate-reverse, titleGlow 4s infinite alternate;
        }
        
        @keyframes titleGlow {
            0% { text-shadow: -1px 0 #ff003c; }
            50% { text-shadow: 0 0 20px #ffd700, -2px 0 #ff003c; }
            100% { text-shadow: 0 0 10px #00f0ff, 2px 0 #00f0ff; }
        }

        .title-text::before, .title-text::after {
            content: "Sex Magick";
            position: absolute; left: 0; top: 0; width: 100%; height: 100%;
            background: #000; overflow: hidden; opacity: 0.7;
        }
        
        .title-text::before {
            left: 2px; text-shadow: -1px 0 #ff003c;
            clip: rect(24px, 550px, 90px, 0);
            animation: glitch-anim-1 2.5s infinite linear alternate-reverse;
        }
        
        .title-text::after {
            left: -2px; text-shadow: -1px 0 #00ffff;
            clip: rect(85px, 550px, 140px, 0);
            animation: glitch-anim-2 3s infinite linear alternate-reverse;
        }

        @keyframes glitchSkew {
            0% { transform: skew(0deg); }
            10% { transform: skew(-2deg); }
            20% { transform: skew(2deg); }
            30% { transform: skew(0deg); }
            40% { transform: skew(0deg); }
            50% { transform: skew(0deg); }
            60% { transform: skew(0deg); }
            70% { transform: skew(0deg); }
            80% { transform: skew(0deg); }
            90% { transform: skew(0deg); }
            100% { transform: skew(0deg); }
        }

        @keyframes glitch-anim-1 {
            0% { clip: rect(20px, 9999px, 80px, 0); }
            20% { clip: rect(70px, 9999px, 10px, 0); }
            40% { clip: rect(20px, 9999px, 80px, 0); }
            60% { clip: rect(10px, 9999px, 60px, 0); }
            80% { clip: rect(50px, 9999px, 20px, 0); }
            100% { clip: rect(60px, 9999px, 70px, 0); }
        }
        @keyframes glitch-anim-2 {
            0% { clip: rect(70px, 9999px, 10px, 0); }
            20% { clip: rect(10px, 9999px, 60px, 0); }
            40% { clip: rect(50px, 9999px, 20px, 0); }
            60% { clip: rect(20px, 9999px, 80px, 0); }
            80% { clip: rect(60px, 9999px, 70px, 0); }
            100% { clip: rect(20px, 9999px, 80px, 0); }
        }

        .level-indicator {
            position: absolute; bottom: 40px; width: 100%; text-align: center;
            font-size: 1.2rem; font-family: 'Cinzel Decorative', serif;
            font-weight: 700; letter-spacing: 8px; z-index: 15;
            text-transform: uppercase; color: rgba(255, 255, 255, 0.85);
            text-shadow: 2px 0px 0px rgba(255, 0, 60, 0.7), -2px 0px 0px rgba(0, 255, 255, 0.7);
            mix-blend-mode: screen; opacity: 0.8;
            animation: holoFloat 4s ease-in-out infinite; 
        }

        @keyframes holoFloat {
            0%, 100% { transform: translateY(0); opacity: 0.8; }
            50% { transform: translateY(-5px); opacity: 0.6; text-shadow: 3px 0px 0px rgba(255, 0, 60, 0.5), -3px 0px 0px rgba(0, 255, 255, 0.5); }
        }

        .score-display {
            position: absolute; top: 12%; width: 100%;
            text-align: center; font-size: 8rem;
            font-family: 'Cinzel Decorative', serif;
            color: rgba(255, 255, 255, 0.15); 
            z-index: 5; pointer-events: none;
            mix-blend-mode: overlay; font-weight: 900;
        }

        .void-active .score-display {
            color: rgba(0, 255, 255, 0.3);
            text-shadow: 0 0 20px rgba(0,255,255,0.5);
            animation: shake 0.5s infinite;
        }
        @keyframes shake { 0% { transform: translate(1px, 1px); } 100% { transform: translate(-1px, -1px); } }

        .leaderboard-container {
            background: rgba(10, 10, 10, 0.6);
            border: 1px solid rgba(255, 0, 60, 0.3);
            padding: 20px; margin-top: 15px; width: 320px;
            pointer-events: auto; backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(0,0,0,0.5); border-radius: 4px;
        }
        .leaderboard-title {
            color: var(--secondary);
            font-family: 'Cinzel Decorative', cursive;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 8px; margin-bottom: 10px;
            letter-spacing: 2px; font-size: 1.1rem;
        }
        .leaderboard-row {
            display: flex; justify-content: space-between;
            font-family: 'Orbitron', monospace;
            font-size: 0.85rem; padding: 4px 0; color: #ccc;
        }
        .rank-1 { color: #ffd700; text-shadow: 0 0 8px rgba(255, 215, 0, 0.5); font-weight: bold; }

        .progress-bar {
            width: 300px; height: 2px; background: #333; margin: 25px 0;
            position: relative;
        }
        .progress-fill {
            height: 100%; background: var(--primary); width: 0%;
            transition: width 0.2s ease; box-shadow: 0 0 10px var(--primary);
        }

        .instructions {
            position: absolute; bottom: 100px; width: 100%; text-align: center;
            font-size: 0.7rem; color: rgba(255, 255, 255, 0.4); letter-spacing: 4px;
            z-index: 15; font-family: 'Orbitron', sans-serif;
            animation: fadeOut 5s ease-in-out forwards; animation-delay: 2s; 
            pointer-events: none;
        }
        @keyframes fadeOut { 0% { opacity: 1; } 100% { opacity: 0; visibility: hidden; } }

        .pause-btn {
            position: absolute; top: 30px; right: 30px; width: 40px; height: 40px;
            background: rgba(0, 0, 0, 0.5); border: 1px solid var(--primary);
            color: var(--primary);
            border-radius: 50%; cursor: pointer; z-index: 25;
            display: flex; justify-content: center; align-items: center; font-size: 1.2rem;
            pointer-events: auto; backdrop-filter: blur(4px); transition: 0.3s;
        }
        .pause-btn:hover { background: var(--primary); color: #000; }

        .stats-panel {
            position: absolute; top: 30px; left: 30px;
            background: rgba(0, 0, 0, 0.5); border-left: 2px solid var(--primary);
            padding: 8px 12px; font-size: 0.7rem; color: #888; z-index: 25;
            pointer-events: auto; font-family: 'Orbitron', monospace; text-align: left;
            backdrop-filter: blur(4px);
        }
        
        .mobile-controls {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 30;
        }
        .mobile-jump-area {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 40%;
            pointer-events: auto; background: transparent;
            display: flex; justify-content: center; align-items: center;
        }
        .mobile-jump-indicator {
            background: rgba(255, 0, 60, 0.1);
            border: 1px solid rgba(255, 0, 60, 0.4);
            border-radius: 50%; width: 70px; height: 70px;
            display: flex; justify-content: center; align-items: center;
            color: rgba(255,255,255,0.7);
            font-size: 0.7rem; letter-spacing: 2px; text-transform: uppercase;
            backdrop-filter: blur(2px); animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { transform: scale(1); opacity: 0.5; } 50% { transform: scale(1.05); opacity: 0.8; } 100% { transform: scale(1); opacity: 0.5; } }

        /* --- RESPONSIVE ADAPTATION --- */
        @media (max-width: 768px) {
            .title-text { font-size: 3.5rem !important; }
            .score-display { font-size: 6rem !important; top: 15% !important; }
            .level-indicator { font-size: 1rem !important; bottom: 80px !important; letter-spacing: 5px !important;}
            .mystic-btn { padding: 12px 15px !important; font-size: 0.8rem !important; min-width: 150px !important; }
            .instructions { bottom: 140px !important; font-size: 0.6rem !important; }
            .leaderboard-container { width: 85% !important; padding: 15px; }
            .mode-select-container { gap: 10px; }
        }
        
        .loader {
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-top: 2px solid var(--primary);
            border-radius: 50%; width: 30px; height: 30px;
            animation: spin 1s linear infinite; margin: 0 auto 15px auto;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="scanlines"></div>
        <div class="vignette"></div>
        
        <div id="scoreUi" class="score-display">0</div>
        <div id="levelUi" class="level-indicator">INITIATION</div>
        
        <div id="mobileControls" class="mobile-controls hidden">
            <div class="mobile-jump-area">
                <div class="mobile-jump-indicator">TAP</div>
            </div>
        </div>
        
        <div id="startScreen" class="ui-layer" style="background-image: url('https://lh3.googleusercontent.com/d/1BXrXXd9TKSqCFNwvS-cJpNORbyvP6fkR=s0');">
            <div style="z-index: 2;">
                <h1 class="title-text">Sex Magick</h1>
                <p style="letter-spacing: 6px; color: #ff003c; margin-bottom: 30px; font-size: 0.9rem; text-shadow: 0 0 5px #ff003c; font-family: 'Orbitron'; text-transform: uppercase;">Do Your Will Foo</p>
            </div>
            
            <div id="loadingMsg">
                <div class="loader"></div>
                <p id="loadingText" style="letter-spacing: 4px; font-size: 0.8rem; color: #aaa; font-family: 'Orbitron';">CHARGING SIGIL...</p>
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill"></div>
                </div>
            </div>

            <div id="menuButtons" class="hidden" style="width: 100%; display: flex; flex-direction: column; align-items: center;">
                
                <div class="mode-select-container">
                    <button id="startHexBtn" class="mystic-btn">RITE OF HEXAGRAM</button>
                    <button id="startMonasBtn" class="mystic-btn">RITE OF MONAS</button>
                </div>
                
                <button id="settingsBtn" class="mystic-btn" style="min-width: 150px; padding: 10px; font-size: 0.8rem;">SETTINGS</button>
                
                <div class="leaderboard-container">
                    <div class="leaderboard-title">:: HIGH GNOSIS ::</div>
                    <div id="leaderboardList">LOADING SCORES...</div>
                </div>
                
                <p id="trackName" style="margin-top: 10px; font-size: 0.6rem; color: #444; letter-spacing: 1px;">SOURCE: GITHUB CDN</p>
            </div>
        </div>

        <div id="gameOverScreen" class="ui-layer hidden" style="background: rgba(0,0,0,0.85);">
            <h1 class="title-text" style="color: #ff003c; font-size: 3.5rem;">Good job foo</h1>
            <p style="font-size: 1rem; letter-spacing: 4px; margin-bottom: 20px; font-family: 'Orbitron'; color: #888;">RITUAL ENDED</p>
            <p class="text-xl mb-6 text-gray-300">WILL: <span id="finalScore" style="color: #fff; font-weight:bold; text-shadow: 0 0 10px #fff;">0</span></p>
            <p id="uploadStatus" style="color: var(--secondary); font-size: 0.8rem; margin-bottom: 10px;">CONNECTING TO ETHER...</p>
            <p id="highScoreMsg" style="color: #ffd700; margin-bottom: 20px; font-size: 0.9rem; letter-spacing: 2px;"></p>
            
            <button id="restartBtn" class="mystic-btn">REINCARNATE</button>
            <button id="voidBtn" class="mystic-btn">RETURN TO VOID</button>
        </div>

        <div id="pauseScreen" class="ui-layer hidden">
            <h1 class="title-text" style="font-size: 3rem; color: #ffd700;">MEDITATION</h1>
            <button id="resumeBtn" class="mystic-btn">RESUME</button>
            <button id="menuBtn" class="mystic-btn">ABORT</button>
        </div>

        <div id="settingsScreen" class="ui-layer hidden" style="background: rgba(0,0,0,0.9);">
            <h1 class="title-text" style="font-size: 2.5rem;">SACRED RITES</h1>
            <div style="width: 300px; margin: 20px 0; background: rgba(20,20,20,0.6); padding: 25px; border: 1px solid var(--primary); backdrop-filter: blur(10px);">
                <div style="display: flex; justify-content: space-between; margin: 15px 0; border-bottom: 1px solid #444; padding-bottom: 10px;">
                    <span>CHANT (MUSIC)</span>
                    <input type="checkbox" id="musicToggle" checked style="accent-color: var(--primary);">
                </div>
                <div style="display: flex; justify-content: space-between; margin: 15px 0; border-bottom: 1px solid #444; padding-bottom: 10px;">
                    <span>RESONANCE (SFX)</span>
                    <input type="checkbox" id="sfxToggle" checked style="accent-color: var(--primary);">
                </div>
                <div style="display: flex; justify-content: space-between; margin: 15px 0;">
                    <span>KUNDALINI (VIBE)</span>
                    <input type="checkbox" id="vibrationToggle" checked style="accent-color: var(--primary);">
                </div>
            </div>
            <button id="backBtn" class="mystic-btn">RETURN</button>
        </div>

        <button id="pauseBtn" class="pause-btn hidden">||</button>
        
        <div id="statsPanel" class="stats-panel">
            <div style="color: var(--primary); font-weight: bold; margin-bottom: 5px;">:: GNOSIS ::</div>
            FPS: <span id="fpsCounter" style="color: #fff;">0</span><br>
            AUDIO: <span id="audioStatus" style="color: #fff;">STANDBY</span>
        </div>

        <div id="instructions" class="instructions hidden">
            [ TAP / SPACE TO ASCEND ]
        </div>
    </div>

    <script>
        const AUDIO_BASE = "https://raw.githubusercontent.com/bookthief666/93-protocol-game-assets-/8c1973f1dada601ef830fa99ebfbbb67906b10cd/";
        const CDN_PREFIX = "https://cdn.jsdelivr.net/gh/bookthief666/93-protocol-game-assets-@662f3d608769e9e945295ac00d668447d974dc5c/";

        const CONFIG = {
            DEBUG: false,
            MENU_MUSIC: AUDIO_BASE + "iamerror%20-%20The%20Zelda%20Song%20(Hyr00l).mp3",
            GAME_PLAYLIST: [
                AUDIO_BASE + "iamerror%20-%20The%20Zelda%20Song%20(Hyr00l).mp3",
                AUDIO_BASE + "iamerror%20-%20Hyr00l%20Rough.mp4",
                AUDIO_BASE + "forget%20me%20remix%2093.flac",
                AUDIO_BASE + "eyedea%20_%201950s%20void%20the%C3%B4ry%20.mp3",
                AUDIO_BASE + "bookthief%F0%9F%A5%80%20-%20booothief-%20All%20gay%F0%9F%98%87%202024-07-10%2001_11%20(1).m4a",
                AUDIO_BASE + "bookthief%F0%9F%A5%80%20-%20How%20Much%20Does%20One%20Pay%202024-07-31%2018_24.m4a",
                AUDIO_BASE + "bookthief%20x%20inv.s.b.l.ty-%20Liquid%20Sovereignty.flac",
                AUDIO_BASE + "Post%20Mvdern%20-%20Pleiades%2018MAR25.flac",
                AUDIO_BASE + "MONOLITH%20bounce%201.mp3",
                AUDIO_BASE + "LEX_LFL_80_wurli_loop_ate_bit_Cm.wav"
            ],
            GAMEOVER_PLAYLIST: [
                AUDIO_BASE + "Post%20Mvdern%20-%20Pleiades%2018MAR25.flac",
                AUDIO_BASE + "LEX_LFL_80_wurli_loop_ate_bit_Cm.wav"
            ],
            BASE_URL: "https://lh3.googleusercontent.com/d/",
            IMG_SUFFIX: "=s0",
            
            // --- PHYSICS CONSTANTS ---
            INITIAL_GAME_SPEED: 2.9, // Reduced from 3.8
            SPEED_INCREASE_PER_LEVEL: 0.035, // Reduced from 0.08
            MAX_GAME_SPEED: 8.5, 
            PILLAR_SPAWN_BASE: 140, 
            PILLAR_WIDTH: 45,
            PILLAR_GAP: 200, 
            PILLAR_GAP_DECREASE_PER_5_LEVELS: 10, 
            MIN_PILLAR_GAP: 110, 
            ORB_SPAWN_CHANCE: 0.5,
            // These will be overridden by Mode selection
            PLAYER_JUMP_FORCE: -7.5,
            GRAVITY: 0.45,
            MAX_FALL_SPEED: 11,
            PLAYER_RADIUS: 16, 
            HITBOX_OFFSET: 4, 
            MOBILE_CONTROL_DEADZONE: 50,
            VOID_DURATION: 300, 
            VOID_INTERVAL: 5, 
        };

        const originalLevels = [
            { name: "MALKUTH", id: "1jI7bl3hsVOuzYf6u35L4bhHq5JUiBDa1" },
            { name: "YESOD", id: "1tHgxNvDO5md4z24hS81eTa9uva25mtr5" },
            { name: "HOD", id: "1Mtp6cP6lwGbPRhLWjQKKDijrLX53K4UR" },
            { name: "NETZACH", id: "1y1i5lxL1jVp37bIz1mtJh4-Puce-E5k0" },
            { name: "TIPHARETH", id: "12png0vOPyJC1Ab4Vffcw2R_K-yRw1sqj" },
            { name: "GEBURAH", id: "1le2Hox1ORxhL28fv7WujO0410vM6jUEJ" },
            { name: "CHESED", id: "1Gsq1xSx9ivfVEq6W2nCMrO-dOIMrSYrW" },
            { name: "DA'ATH", id: "1o601hrLi5RpuGL_kiVEoPXxXk2SCbM2z" },
            { name: "BINAH", id: "1iSYJfPsaYjA1rmRTsujLcn1Do-lBydF7" },
            { name: "CHOKMAH", id: "1PvOC62nv5HdsE1cuCF8RENY9Z8HTabn7" },
            { name: "KETHER", id: "1Ym_eyrXJEQUBA7Lg_2oUc6dQ-gy9yfGs" }
        ];

        const newImageIDs = [
            "1pJ5CUGyKXgkSgEREkKos1Kch5FmfUyxE", "1spT4HpO_4q9joE4x6bLjZQRlFTS9j-ie", "1YGzyjcjiCoPCLbYjJEiqT8USUhe4S6hM", "1ELjoJU7KDC88nUk_Vs57OKUG9oLl5E8N",
            "1faa2c3QFWhZ8UgvyZ_ZrlnyFsnsKRclm", "10W5oYkoqB9LC3YjvB_aozR0kG3hWaHka", "1l9Jdm0EQh8sgWh1W0wsXQCzrQM19Bfm9", "1BrHTF2dvfbRkyYfXAbPUiujwE1AJskY4",
            "1KqV8IYF7KDbmgHS3ph6eRQKl4uAAFG_u", "1sZ02UH_vb1xLaOvyETqptc5FuvOtVKd4", "1hLKOGYXCBemcIKt8OLEX4dHTn6bd88cr", "1g_DQeG6qldMBxHzZ82MOVoxk9APwb4NO",
            "1-SIvE5EZyUd7FKXJ7eyB4JCrtOpQoF18", "1S4y4YSCjxSb-b_U1BfMw_0PhabJ-METm", "1OL-kWl-TJNcZFPcsCAtynW2NWp-YYjGd", "1ApPgou40N2Q6GlNKNuyoQ2Gk5DqAfmw_",
            "1OeH1GMu2rDcwzdtWFZSB1WWe0OjkmxV0", "12Z92v9Mu9yNOnDTtK-bjMRZ8_2BAW2eW", "1Erf3DKxZpfbG57oGcUCjuHIhajsweLZz", "1qK22CJhJ1XgElL156uOQxYrucaRG16p0",
            "1euwdAWg-xQw7isR-JAiZ-krXQXOS8pi0", "1A3hT3mJibINtsr8CVxTmp71QsYgPB2JZ", "1QUVr-RK2kP7IIAuy0wX3pOZRQuyr-o-e", "1eF02YMyYBcgx7Ga20pXgoltzWXPYznfD",
            "1zx1vrrbuSA4xCFKXAHgXbkG1rX8PUPel", "1ds1iqXf90gy9PUFs80t4QOxamkJj0u1I", "14-t6dPPv5MeXe7LWPIp7Tjc8x4w5Vj2d", "1pUtIizMzVhjzB46dhah5mgz6Tr-vaSLO",
            "1ZOEkUW8q2s5zerS7BubYJU69RHk7_Zlo", "15ZHj0fLYu-4rEQy43BMJKDgXnnQ5FeyP", "1ZzgVT0O6XQzW3DUP4i1aoKd_DD5wV5LZ", "1rZHZM0bR_j6uiYZLS82J0BkbIfEUoXvY",
            "1CNrQ_EeMXQgHJGXxe7EHysQi_A0A9UE7", "1ubCqIg7ETOIsHGfBjQfVsRzjlZIpBP6E", "1pojzjR-uiQ0oTHRJxXXCW_w0hlJUCqyb", "1SnclBlH6sflhaTWzFhbcNedzNeh25-BV",
            "1thfc-9DnM4GhCi0zTbcX4MH-yaQEpomX", "1BXrXXd9TKSqCFNwvS-cJpNORbyvP6fkR", "1D1bOksatIt6Jw6Zq8Sbmhbq_GC_2EQHh", "1eP_Xnk80YnL3w3Q69wQmVo9_F0OaA3Wo",
            "1ARDOipcr0lB1GYf3gmhqlHXlpC23Q2JE", "1io39jfggXQl-OyvSFGIpgOtoIzHbml3M", "1o0rJmx3vEKITMx1ixP5iruOX2ujOT6VO", "1Irw61utgSGdip21OgTcYqz56LpWWS9fb",
            "19V2ObVoQn9R9bt1ZgMNEBJokaAjYdX_9", "1WWvLnkkPBN7Q0ZsGi16FL1anhPlti3Qd", "1HoYqC0SLc3nrSDnoW9KJ2-z8AnRWIz5M", "1oS0J3F-zh5H48-Qs5Mrm10dPR993kF-b",
            "1bRwsBEuZiAIZW_5f3WOZVI6-KVnCEslk", "1GLza2_RmR4c_KD_KGxbXPOoCAw9SITKl", "1uWFSChozQmHEnuJwXqiPNApXuAwPAzKS", "1t2hNBEudzIo19kuP8ksPY_cNetDdTd8P",
            "1KhMBL7a3NSggVerbyy53fQ-dLq11adwj", "1wgxalTR68YM7oIku8JYZYKtG50atEnG_", "1BceMgnHgVn9U_7EYnXQu9HDwEQY1UBa_", "14_iwYDQjp34-R_iby8QadKnI9m3zVnOu",
            "1cZ_ci9J80jnqCAdag8SQofYZw1dfsX3C", "15z3bGrCqUy8SQjX1dO5C1vlN3y4-soai", "10xAFw98B39Ou0SSeB4eWyoY2D_OLLPgz", "1CexZQw11p33u1-YA7JhPAkGV6NBCgd6e",
            "16t1EdHfHRpb7GmqNAfo2iKKm57qLfbKn", "12wQOhUztVCVEFV21fPDq-JXGi5zxdkeQ", "1-0u9JUH0oUHD1--5iaySxRpO_PuyxkH6", "1wnITY3i6XxOr1b3l6P0cT10LkEHQauO5"
        ].filter((value, index, self) => self.indexOf(value) === index);

        const esotericNames = [
            "KUNDALINI", "HIEROS GAMOS", "SACRED UNION", "RED TINCTURE", "WHITE GLUTEN", 
            "CUP OF BABALON", "BLOOD OF SAINTS", "CITY OF PYRAMIDS", "NIGHT OF PAN", 
            "HADIT'S FLAME", "NUIT'S EMBRACE", "LAW OF THELEMA", "LOVE UNDER WILL", 
            "GREAT WORK", "STONE OF WISE", "ELIXIR OF LIFE", "RED LION", "WHITE EAGLE",
            "ABRAHADABRA", "LASHTAL", "KA", "BA", "KHU", "SCARLET WOMAN", "THE BEAST",
            "AEON OF HORUS", "93", "AGAPE", "THELEMA", "VIA OVUM", "SPERMATOZOON",
            "HOMUNCULUS", "DIVINE EROS", "TANTRA", "YONI", "LINGAM", "O.T.O.", "A.'.A.'.",
            "STAR SAPPHIRE", "MASS OF PHOENIX", "LIBER AL", "RESH", "SAMEKH", "TZADDI"
        ];
        
        let MASTER_POOL = [...originalLevels];
        
        const palette = ["#ff003c", "#ff00ff", "#9d00ff", "#00f0ff", "#00ff9d", "#d4ff00", "#ff8800"];
        newImageIDs.forEach((id, index) => {
            const nameIndex = index % esotericNames.length;
            MASTER_POOL.push({
                name: esotericNames[nameIndex],
                id: id,
                color: "#000",
                accent: palette[index % palette.length],
                img: null,
                loaded: false
            });
        });

        // --- LOOTLOCKER CONFIG ---
        const LEADERBOARD_ID = "global_ritual";
        const API_KEY = "dev_44a2b8e7798a416eba598ee295a91d55";
        const Leaderboard = {
            token: null,
            async init() {
                const stored = localStorage.getItem("ritual_id");
                let payload = { game_version: "1.0", development_mode: true };
                if(stored) payload.guest_player_id = stored;
                try {
                    const r = await fetch("https://api.lootlocker.io/game/v2/session/guest", {
                        method: "POST",
                        headers: { "Content-Type": "application/json", "x-session-token": API_KEY },
                        body: JSON.stringify(payload)
                    });
                    const d = await r.json();
                    if(d.session_token) {
                        this.token = d.session_token;
                        localStorage.setItem("ritual_id", d.player_id);
                        this.fetchTop();
                    } else {
                        document.getElementById('leaderboardList').innerHTML = "OFFLINE";
                    }
                } catch(e) {
                    document.getElementById('leaderboardList').innerHTML = "OFFLINE";
                }
            },
            async fetchTop() {
                if(!this.token) return;
                try {
                    const r = await fetch(`https://api.lootlocker.io/game/v1/leaderboards/${LEADERBOARD_ID}/list?count=5`, {
                        headers: { "x-session-token": this.token }
                    });
                    const d = await r.json();
                    const list = document.getElementById('leaderboardList');
                    if(d.items && d.items.length > 0) {
                        list.innerHTML = d.items.map((i, idx) => `
                            <div class="leaderboard-row ${idx===0?'rank-1':''}">
                                <span>#${i.rank} ${i.player.id ? i.player.id.toString().substring(0,6) : "MAGE"}...</span>
                                <span>${i.score}</span>
                            </div>
                        `).join('');
                    } else {
                        list.innerHTML = "NO RITUALS YET";
                    }
                } catch(e) {}
            },
            async submit(score) {
                if(!this.token) return;
                const status = document.getElementById('uploadStatus');
                status.innerText = "UPLOADING...";
                try {
                    await fetch(`https://api.lootlocker.io/game/v1/leaderboards/${LEADERBOARD_ID}/submit`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json", "x-session-token": this.token },
                        body: JSON.stringify({ score: score })
                    });
                    status.innerText = "UPLOAD COMPLETE";
                    this.fetchTop();
                } catch(e) {
                    status.innerText = "UPLOAD FAILED";
                }
            }
        };

        const GameState = {
            START: 'start',
            LOADING: 'loading',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAME_OVER: 'gameover',
            SETTINGS: 'settings'
        };

        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        const optimizedShadow = {
            apply(ctx, blur, color) {
                if (isMobile) {
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = 'transparent';
                } else {
                    ctx.shadowBlur = blur;
                    ctx.shadowColor = color;
                }
            },
            clear(ctx) {
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }
        };

        const GlitchFX = {
            active: false, duration: 0, intensity: 1, type: 'rgb',
            rgbSplit(ctx, intensity) {
                const offset = Math.floor(Math.random() * 3 * intensity);
                const rOffset = Math.random() > 0.5 ? offset : -offset;
                const gOffset = Math.random() > 0.5 ? offset : -offset;
                const bOffset = Math.random() > 0.5 ? offset : -offset;
                if (Math.random() > 0.3) return null;
                return {
                    rOffset, gOffset, bOffset,
                    draw: function(ctx, width, height) {
                        const imageData = ctx.getImageData(0, 0, width, height);
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = width; tempCanvas.height = height;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.putImageData(imageData, 0, 0);
                        ctx.save();
                        ctx.globalCompositeOperation = 'screen';
                        ctx.globalAlpha = 0.8; ctx.drawImage(tempCanvas, rOffset, 0);
                        ctx.globalAlpha = 0.8; ctx.drawImage(tempCanvas, 0, gOffset);
                        ctx.globalAlpha = 0.8;
                        ctx.drawImage(tempCanvas, bOffset, bOffset);
                        ctx.restore();
                    }
                };
            },
            apply(ctx, currentTime) {
                if (!this.active || this.duration <= 0) return;
                const progress = this.duration / 100;
                this.intensity = Math.min(1, progress * 2);
                if (Math.random() > 0.8) {
                    const rgbEffect = this.rgbSplit(ctx, this.intensity);
                    if (rgbEffect) rgbEffect.draw(ctx, ctx.canvas.width, ctx.canvas.height);
                }
                this.duration -= 16;
                if (this.duration <= 0) { this.active = false; this.intensity = 1; }
            },
            trigger(duration = 100, type = 'all') {
                this.active = true;
                this.duration = duration; this.type = type; this.intensity = 1;
            }
        };

        const SFX = {
            audioContext: null,
            init() { if (!this.audioContext) this.audioContext = new (window.AudioContext || window.webkitAudioContext)(); },
            playTone(freq, type, duration, vol, detune = 0) {
                if (!game?.settings?.sfx) return;
                if (!this.audioContext) this.init();
                if (this.audioContext.state === 'suspended') this.audioContext.resume();
                try {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    osc.type = type;
                    osc.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                    osc.detune.setValueAtTime(detune, this.audioContext.currentTime);
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    gain.gain.setValueAtTime(vol, this.audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                    osc.start();
                    osc.stop(this.audioContext.currentTime + duration);
                } catch(e){}
            },
            jump() { this.playTone(400, 'square', 0.08, 0.1); this.playTone(600, 'sine', 0.05, 0.05, 100); },
            collect() { this.playTone(800, 'sine', 0.2, 0.1); this.playTone(1200, 'triangle', 0.1, 0.05, 50); },
            crash() { this.playTone(100, 'sawtooth', 0.5, 0.3); this.playTone(80, 'square', 0.3, 0.2, -100); },
            voidEnter() { this.playTone(200, 'sawtooth', 0.5, 0.2, -50); this.playTone(800, 'sine', 1.0, 0.1, 50); }, 
            levelUp() { 
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.5);
                osc.connect(gain); gain.connect(this.audioContext.destination);
                gain.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                osc.start(); osc.stop(this.audioContext.currentTime + 0.5);
            }
        };

        const Haptics = {
            // Enhanced Haptic Patterns
            jump() { if (game?.settings?.vibration && navigator.vibrate) navigator.vibrate([10]); },
            collect() { if (game?.settings?.vibration && navigator.vibrate) navigator.vibrate([15, 5, 15]); },
            crash() { if (game?.settings?.vibration && navigator.vibrate) navigator.vibrate([50, 100, 200, 100, 50]); },
            levelUp() { if (game?.settings?.vibration && navigator.vibrate) navigator.vibrate([50, 50, 50, 50, 100]); },
            start() { if (game?.settings?.vibration && navigator.vibrate) navigator.vibrate([30, 30]); }
        };

        const AudioSys = {
            bgm: null, localBlobUrl: null, currentMode: 'none', retryCount: 0, playlistQueue: [],
            setStatus(msg) {
                const el = document.getElementById('audioStatus');
                if (el) { el.textContent = msg; el.style.color = '#fff'; setTimeout(() => el.style.color = 'var(--primary)', 200); }
            },
            init() { this.setupAudioElement(CONFIG.MENU_MUSIC); this.currentMode = 'menu'; this.setStatus("MENU AUDIO RDY"); },
            setupAudioElement(src) {
                if (this.bgm) { this.bgm.pause(); this.bgm.src = ""; this.bgm.onended = null; }
                this.bgm = new Audio();
                this.bgm.src = src; this.bgm.volume = 0.8; this.bgm.preload = "auto";
                this.bgm.onwaiting = () => this.setStatus("BUFFERING...");
                this.bgm.onplaying = () => { this.setStatus("PLAYING"); this.retryCount = 0; };
                this.bgm.onerror = (e) => { console.warn("Audio error:", e); this.setStatus("LOAD ERROR"); };
            },
            shuffleQueue() {
                 this.playlistQueue = [...CONFIG.GAME_PLAYLIST];
                 for (let i = this.playlistQueue.length - 1; i > 0; i--) {
                     const j = Math.floor(Math.random() * (i + 1));
                     [this.playlistQueue[i], this.playlistQueue[j]] = [this.playlistQueue[j], this.playlistQueue[i]];
                 }
            },
            switchToGameMusic() {
                if (this.localBlobUrl) return;
                this.currentMode = 'game';
                if (this.playlistQueue.length === 0) this.shuffleQueue();
                const track = this.playlistQueue.pop(); 
                this.setStatus("LOADING NEXT TRACK");
                this.setupAudioElement(track);
                this.bgm.loop = false;
                this.bgm.onended = () => { if(this.currentMode === 'game') this.switchToGameMusic(); };
                this.play();
            },
            switchToGameOverMusic() {
                if (this.localBlobUrl) return;
                this.currentMode = 'gameover';
                const randomIndex = Math.floor(Math.random() * CONFIG.GAMEOVER_PLAYLIST.length);
                const track = CONFIG.GAMEOVER_PLAYLIST[randomIndex];
                this.setStatus("RITUAL ENDED");
                this.setupAudioElement(track);
                this.bgm.loop = true;
                this.play();
            },
            switchToMenuMusic() {
                if (this.localBlobUrl) return;
                this.currentMode = 'menu'; this.setStatus("LOADING MENU");
                this.setupAudioElement(CONFIG.MENU_MUSIC);
                this.bgm.loop = true;
            },
            play() { if (!this.bgm) return; const p = this.bgm.play(); if (p !== undefined) p.catch(e => { console.warn(e); this.setStatus("AUTOPLAY BLOCK"); }); },
            pause() { if (this.bgm) { this.bgm.pause(); this.setStatus("PAUSED"); } },
            resume() { if (this.bgm && this.bgm.paused) { this.bgm.play(); this.setStatus("RESUMED"); } },
            stop() { if (this.bgm) { this.bgm.pause(); this.bgm.currentTime = 0; this.setStatus("STOPPED"); } }
        };

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.root = document.documentElement;
                this.state = GameState.START;
                this.currentLevelIdx = 0;
                this.frames = 0;
                this.score = 0;
                this.highScore = localStorage.getItem('93protocol_highscore') || 0;
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED;
                this.shake = 0;
                this.lastFrameTime = 0;
                this.fps = 0;
                this.isMobile = isMobile;
                this.scaleFactor = 1;
                this.baseWidth = 800;
                this.baseHeight = 450;
                this.glitchEffect = false;
                this.glitchTimer = 0;
                this.tunnelOffset = 0;
                this.hitStop = 0;
                this.screenFlash = null;
                this.voidMode = false;
                this.voidTimer = 0;
                this.preVoidSpeed = 0;
                
                this.gameMode = 'HEX'; // 'HEX' or 'MONAS'

                this.backgroundParticles = [];
                this.player = null;
                this.particles = [];
                this.stars = []; // For standard stars
                this.warpStars = []; // For Monas warp stars
                this.obstacles = [];
                this.collectibles = [];
                this.pentagrams = [];
                this.gameLevels = []; 
                this.settings = { music: true, sfx: true, vibration: true };
                
                this.loadSettings();
                this.initEventListeners();
                this.resizeCanvas();
                this.preloadAllImages();
                this.createBackgroundParticles();
                
                AudioSys.init();
                SFX.init();
            }
            
            createBackgroundParticles() {
                this.backgroundParticles = [];
                for (let i = 0; i < 25; i++) { 
                    this.backgroundParticles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        z: Math.random() * 2 + 0.5,
                        size: Math.random() * 3 + 2,
                        speed: Math.random() * 0.5 + 0.1,
                        color: palette[Math.floor(Math.random() * palette.length)],
                        opacity: Math.random() * 0.4 + 0.1,
                        shape: Math.floor(Math.random() * 3) 
                    });
                }
            }
            
            triggerOrbGlitch() {
                GlitchFX.trigger(80, 'orb');
                this.screenFlash = { active: true, duration: 10, color: '#ffd700', intensity: 0.3 };
            }
            
            triggerLevelUpGlitch() {
                GlitchFX.trigger(150, 'level');
                this.screenFlash = {
                    active: true, duration: 20,
                    color: this.gameLevels[this.currentLevelIdx]?.accent || '#ff003c', intensity: 0.4
                };
            }
            
            triggerDeathGlitch() {
                GlitchFX.trigger(200, 'death');
                this.screenFlash = { active: true, duration: 30, color: '#ff003c', intensity: 0.6 };
            }
            
            applyScreenFlash() {
                if (!this.screenFlash || !this.screenFlash.active) return;
                this.ctx.save();
                this.ctx.fillStyle = this.screenFlash.color;
                this.ctx.globalAlpha = this.screenFlash.intensity * (this.screenFlash.duration / 30);
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.restore();
                this.screenFlash.duration--;
                if (this.screenFlash.duration <= 0) { this.screenFlash.active = false; }
            }
            
            initEventListeners() {
                window.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && this.state === GameState.PLAYING) this.playerJump();
                    else if (e.code === 'Escape') this.togglePause();
                });
                window.addEventListener('mousedown', (e) => {
                    if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'LABEL' && this.state === GameState.PLAYING) this.playerJump();
                });
                window.addEventListener('touchstart', (e) => {
                    if (this.state === GameState.PLAYING) {
                        e.preventDefault();
                        const touchY = e.touches[0].clientY;
                        if (touchY > window.innerHeight * 0.6) { this.playerJump(); }
                    }
                }, { passive: false });

                document.getElementById('startHexBtn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.gameMode = 'HEX';
                    if (this.settings.music) AudioSys.switchToGameMusic();
                    this.startGame();
                });
                document.getElementById('startMonasBtn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.gameMode = 'MONAS';
                    if (this.settings.music) AudioSys.switchToGameMusic();
                    this.startGame();
                });

                document.getElementById('restartBtn').addEventListener('click', (e) => {
                     e.stopPropagation();
                     if (this.settings.music) AudioSys.switchToGameMusic();
                     this.restartGame();
                });
                document.getElementById('voidBtn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.returnToMenu();
                });
                document.getElementById('pauseBtn').addEventListener('click', (e) => { e.stopPropagation(); this.togglePause(); });
                document.getElementById('resumeBtn').addEventListener('click', (e) => { e.stopPropagation(); this.togglePause(); });
                document.getElementById('menuBtn').addEventListener('click', (e) => { e.stopPropagation(); this.returnToMenu(); });
                document.getElementById('settingsBtn').addEventListener('click', (e) => { e.stopPropagation(); this.showSettings(); });
                document.getElementById('backBtn').addEventListener('click', (e) => { e.stopPropagation(); this.hideSettings(); });
                
                document.getElementById('musicToggle').addEventListener('change', (e) => {
                    this.settings.music = e.target.checked;
                    this.saveSettings();
                    if (!this.settings.music) AudioSys.stop();
                    else if (this.state === GameState.PLAYING) AudioSys.play();
                });
                document.getElementById('sfxToggle').addEventListener('change', (e) => {
                    this.settings.sfx = e.target.checked; this.saveSettings();
                });
                document.getElementById('vibrationToggle').addEventListener('change', (e) => {
                    this.settings.vibration = e.target.checked; this.saveSettings();
                });
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            loadSettings() {
                const saved = localStorage.getItem('93protocol_settings');
                if (saved) this.settings = { ...this.settings, ...JSON.parse(saved) };
                document.getElementById('musicToggle').checked = this.settings.music;
                document.getElementById('sfxToggle').checked = this.settings.sfx;
                document.getElementById('vibrationToggle').checked = this.settings.vibration;
            }
            
            saveSettings() { localStorage.setItem('93protocol_settings', JSON.stringify(this.settings)); }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.calculateScaleFactor();
                this.adjustForScreenSize();
            }
            
            calculateScaleFactor() {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const targetRatio = 16/9;
                if (width/height > targetRatio) { this.scaleFactor = height / this.baseHeight; } else { this.scaleFactor = width / this.baseWidth; }
                this.scaleFactor = Math.max(0.6, Math.min(this.scaleFactor, 1.5));
            }
            
            adjustForScreenSize() {
                const screenHeight = this.canvas.height;
                const screenWidth = this.canvas.width;
                let baseGap = CONFIG.PILLAR_GAP;
                
                // --- PORTRAIT MODE FIX ---
                // If height > width (Portrait), give more gap to compensate for low reaction time
                if (screenHeight > screenWidth) {
                    baseGap = Math.max(250, baseGap * 1.3); 
                    // Slow down game speed slightly in portrait mode for fairness
                    this.gameSpeed = Math.max(CONFIG.INITIAL_GAME_SPEED * 0.9, 2.0);
                } else if (screenHeight < 600) { 
                    baseGap = Math.min(270, baseGap * 1.08); 
                } else if (screenHeight > 800) { 
                    baseGap = Math.max(240, baseGap * 0.95); 
                }
                this.currentBaseGap = baseGap;
            }
            
            preloadAllImages() {
                const progressFill = document.getElementById('progressFill');
                const loadingText = document.getElementById('loadingText');
                let loadedCount = 0;
                const failsafe = setTimeout(() => { if (loadedCount < MASTER_POOL.length) { this.finishLoading(); } }, 5000);
                MASTER_POOL.forEach(lvl => {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.onload = () => {
                        lvl.img = img;
                        lvl.loaded = true;
                        loadedCount++;
                        const percent = Math.floor((loadedCount / MASTER_POOL.length) * 100);
                        progressFill.style.width = `${percent}%`;
                        loadingText.innerText = `CHARGING SIGIL... ${loadedCount}/${MASTER_POOL.length}`;
                        if (loadedCount >= MASTER_POOL.length) { clearTimeout(failsafe); this.finishLoading(); }
                    };
                    img.onerror = () => {
                        loadedCount++;
                        if (loadedCount >= MASTER_POOL.length) { clearTimeout(failsafe); this.finishLoading(); }
                    };
                    img.src = CONFIG.BASE_URL + lvl.id + CONFIG.IMG_SUFFIX;
                });
            }
            
            finishLoading() {
                Leaderboard.init();
                setTimeout(() => {
                    document.getElementById('loadingMsg').classList.add('hidden');
                    document.getElementById('menuButtons').classList.remove('hidden');
                }, 500);
            }
            
            prepareLevels() {
                let shuffled = [...MASTER_POOL];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                this.gameLevels = shuffled.map((lvl, index) => {
                    return { ...lvl, threshold: index * 5 };
                });
            }

            startGame() {
                this.prepareLevels();
                this.state = GameState.PLAYING;
                document.getElementById('startScreen').classList.add('hidden');
                document.getElementById('scoreUi').classList.remove('hidden');
                document.getElementById('pauseBtn').classList.remove('hidden');
                document.getElementById('instructions').classList.remove('hidden');
                
                if (this.isMobile) {
                    document.getElementById('mobileControls').classList.remove('hidden');
                    setTimeout(() => { document.getElementById('mobileControls').classList.add('hidden'); }, 5000);
                }
                
                if (CONFIG.DEBUG) document.getElementById('statsPanel').classList.remove('hidden');
                this.initGame();
                Haptics.start();
                this.gameLoop();
            }
            
            initGame() {
                this.player = new Player(this.gameMode);
                this.obstacles = [];
                this.collectibles = [];
                this.pentagrams = [];
                this.particles = [];
                
                // Initialize background based on mode
                this.stars = [];
                this.warpStars = [];
                
                if (this.gameMode === 'MONAS') {
                    for (let i = 0; i < 50; i++) this.warpStars.push(new WarpStar());
                } else {
                    for (let i = 0; i < 40; i++) this.stars.push(new Star());
                }

                this.score = 0;
                this.currentLevelIdx = 0;
                this.frames = 0;
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED;
                this.shake = 0;
                this.tunnelOffset = 0;
                this.hitStop = 0;
                this.voidMode = false;
                this.voidTimer = 0;
                document.getElementById('scoreUi').innerText = "0";
                document.getElementById('game-container').classList.remove('void-active');
                this.applyLevel();
            }
            
            applyLevel() {
                if (this.currentLevelIdx >= this.gameLevels.length) return;
                const l = this.gameLevels[this.currentLevelIdx];
                document.getElementById('levelUi').innerText = l.name;
                document.getElementById('levelUi').style.color = l.accent;
                document.getElementById('levelUi').style.textShadow = `0 0 15px ${l.accent}`;
                this.root.style.setProperty('--primary', l.accent);
                let newSpeed = CONFIG.INITIAL_GAME_SPEED + (this.currentLevelIdx * CONFIG.SPEED_INCREASE_PER_LEVEL);
                this.gameSpeed = Math.min(newSpeed, CONFIG.MAX_GAME_SPEED);
                if (this.currentLevelIdx > 0) {
                    this.triggerGlitchEffect();
                    Haptics.levelUp();
                    if (this.settings.sfx) SFX.levelUp();
                }
            }
            
            startVoidMode() {
                this.voidMode = true;
                this.voidTimer = CONFIG.VOID_DURATION;
                this.preVoidSpeed = this.gameSpeed;
                this.gameSpeed = this.gameSpeed * 1.8; 
                this.obstacles = [];
                this.collectibles = [];
                this.screenFlash = { active: true, duration: 20, color: '#00ffff', intensity: 0.5 };
                document.getElementById('game-container').classList.add('void-active');
                document.getElementById('levelUi').innerText = "THE VOID";
                document.getElementById('levelUi').style.color = "#00ffff";
                if (this.settings.sfx) SFX.voidEnter();
            }
            
            endVoidMode() {
                this.voidMode = false;
                this.gameSpeed = this.preVoidSpeed;
                document.getElementById('game-container').classList.remove('void-active');
                this.applyLevel(); 
            }

            triggerGlitchEffect() { this.glitchEffect = true; this.glitchTimer = 300; }
            
            applyGlitchEffect() {
                if (!this.glitchEffect) return;
                const ctx = this.ctx;
                const intensity = this.glitchTimer / 300;
                if (Math.random() > 0.7) {
                    const shiftX = Math.floor(Math.random() * 10 * intensity) - 5;
                    const shiftY = Math.floor(Math.random() * 10 * intensity) - 5;
                    ctx.save();
                    ctx.translate(shiftX, shiftY);
                    ctx.restore();
                }
                if (Math.random() > 0.8) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fillRect(0, Math.floor(Math.random() * this.canvas.height), this.canvas.width, 1);
                }
                this.glitchTimer -= 16;
                if (this.glitchTimer <= 0) { this.glitchEffect = false; }
            }
            
            getCurrentGap() {
                const baseGap = this.currentBaseGap || CONFIG.PILLAR_GAP;
                const levelsCompleted = Math.floor(this.currentLevelIdx / 5);
                const gapReduction = levelsCompleted * CONFIG.PILLAR_GAP_DECREASE_PER_5_LEVELS;
                const calculatedGap = Math.max(CONFIG.MIN_PILLAR_GAP, baseGap - gapReduction);
                return calculatedGap + (Math.sin(this.frames * 0.05) * 10);
            }
            
            checkLevel() {
                const nextIdx = this.currentLevelIdx + 1;
                if (nextIdx >= this.gameLevels.length) return;
                const next = this.gameLevels[nextIdx];
                if (this.score >= next.threshold) {
                    this.currentLevelIdx++;
                    if (this.currentLevelIdx % CONFIG.VOID_INTERVAL === 0) {
                        this.startVoidMode();
                    } else {
                        this.applyLevel();
                        this.shake = 12;
                        this.hitStop = 3;
                        this.triggerLevelUpGlitch();
                        for (let i = 0; i < 30; i++) {
                            this.particles.push(new Particle(
                                this.canvas.width / 2, this.canvas.height / 2, 
                                this.gameLevels[this.currentLevelIdx].accent, 12,
                                Math.random() > 0.5 ? 'hexagram' : 'triangle'
                            ));
                        }
                        if (this.settings.sfx) SFX.levelUp();
                        Haptics.levelUp();
                    }
                }
            }
            
            playerJump() {
                if (this.state === GameState.PLAYING) {
                    this.player.jump();
                    Haptics.jump();
                    GlitchFX.trigger(50, 'rgb');
                }
            }
            
            togglePause() {
                if (this.state === GameState.PLAYING) {
                    this.state = GameState.PAUSED;
                    document.getElementById('pauseScreen').classList.remove('hidden');
                    AudioSys.pause();
                } else if (this.state === GameState.PAUSED) {
                    this.state = GameState.PLAYING;
                    document.getElementById('pauseScreen').classList.add('hidden');
                    AudioSys.resume();
                    this.gameLoop();
                }
            }
            
            showSettings() {
                document.getElementById('startScreen').classList.add('hidden');
                document.getElementById('settingsScreen').classList.remove('hidden');
                this.state = GameState.SETTINGS;
            }
            
            hideSettings() {
                document.getElementById('settingsScreen').classList.add('hidden');
                document.getElementById('startScreen').classList.remove('hidden');
                this.state = GameState.START;
            }
            
            returnToMenu() {
                this.state = GameState.START;
                document.getElementById('pauseScreen').classList.add('hidden');
                document.getElementById('gameOverScreen').classList.add('hidden');
                document.getElementById('startScreen').classList.remove('hidden');
                document.getElementById('scoreUi').classList.add('hidden');
                document.getElementById('pauseBtn').classList.add('hidden');
                document.getElementById('instructions').classList.add('hidden');
                document.getElementById('statsPanel').classList.add('hidden');
                document.getElementById('mobileControls').classList.add('hidden');
                document.getElementById('game-container').classList.remove('void-active');
                if (this.settings.music) AudioSys.switchToMenuMusic();
            }
            
            gameOver() {
                if (this.state === GameState.GAME_OVER || this.voidMode) return;
                this.state = GameState.GAME_OVER;
                this.shake = 15;
                this.triggerDeathGlitch();
                if (this.settings.sfx) SFX.crash();
                Haptics.crash();
                for (let i = 0; i < 25; i++) {
                    this.particles.push(new Particle(
                        this.player.x, this.player.y, '#ff003c', 10,
                        Math.random() > 0.3 ? 'hexagram' : 'triangle'
                    ));
                }
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('93protocol_highscore', this.highScore);
                    document.getElementById('highScoreMsg').textContent = "NEW GNOSIS ATTAINED";
                } else {
                    document.getElementById('highScoreMsg').textContent = `BEST: ${this.highScore}`;
                }
                Leaderboard.submit(this.score);
                if (this.settings.music) AudioSys.switchToGameOverMusic(); else AudioSys.stop();
                document.getElementById('finalScore').innerText = this.score;
                document.getElementById('scoreUi').classList.add('hidden');
                document.getElementById('pauseBtn').classList.add('hidden');
                document.getElementById('instructions').classList.add('hidden');
                document.getElementById('statsPanel').classList.add('hidden');
                document.getElementById('mobileControls').classList.add('hidden');
                document.getElementById('gameOverScreen').classList.remove('hidden');
            }
            
            restartGame() {
                this.state = GameState.PLAYING;
                this.prepareLevels();
                document.getElementById('gameOverScreen').classList.add('hidden');
                document.getElementById('scoreUi').classList.remove('hidden');
                document.getElementById('pauseBtn').classList.remove('hidden');
                document.getElementById('instructions').classList.remove('hidden');
                if (this.isMobile) {
                    document.getElementById('mobileControls').classList.remove('hidden');
                    setTimeout(() => { document.getElementById('mobileControls').classList.add('hidden'); }, 5000);
                }
                if (CONFIG.DEBUG) document.getElementById('statsPanel').classList.remove('hidden');
                this.initGame();
                this.gameLoop();
            }
            
            gameLoop(currentTime = 0) {
                if (this.state !== GameState.PLAYING) return;
                if (this.lastFrameTime) {
                    this.fps = Math.round(1000 / (currentTime - this.lastFrameTime));
                    if (CONFIG.DEBUG) document.getElementById('fpsCounter').textContent = this.fps;
                }
                this.lastFrameTime = currentTime;
                if (this.hitStop > 0) {
                    this.hitStop--;
                    this.drawScene(currentTime);
                    requestAnimationFrame((time) => this.gameLoop(time));
                    return;
                }

                this.frames++;
                if (this.frames % 30 === 0 && Math.random() > 0.8) { GlitchFX.trigger(10, 'random'); }
                if (this.voidMode) {
                    this.voidTimer--;
                    if (this.voidTimer <= 0) { this.endVoidMode(); }
                }
                
                this.tunnelOffset += this.tunnelSpeed * (1 + this.gameSpeed * 0.1) || 10;
                this.updateGameObjects();
                this.drawScene(currentTime);
                requestAnimationFrame((time) => this.gameLoop(time));
            }

            drawScene(currentTime) {
                const lvl = this.gameLevels[this.currentLevelIdx];
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                const tunnelColor = this.voidMode ? '#00ffff' : lvl.accent;
                this.drawHyperspaceTunnel(tunnelColor);

                // --- BACKGROUND LOGIC SPLIT BASED ON MODE ---
                if (this.gameMode === 'MONAS') {
                    // 3D Expanding Stars for MONAS mode
                    const cx = this.canvas.width / 2;
                    const cy = this.canvas.height / 2;
                    // SLOW EXPANSION UPDATE
                    this.warpStars.forEach(s => {
                        // If in Void mode, speed up; otherwise, use 0.15x multiplier for SUPER SLOW floaty effect
                        const warpSpeed = this.voidMode ? this.gameSpeed : (this.gameSpeed * 0.15);
                        s.update(warpSpeed, this.voidMode);
                        s.draw(this.ctx, cx, cy, tunnelColor);
                    });
                } else {
                    // Standard Scrolling Stars for HEX mode
                    this.drawBackgroundParticles(tunnelColor);
                    // Draw Standard Stars
                    this.stars.forEach(s => {
                         s.update();
                         s.draw(this.ctx);
                    });
                }
                
                GlitchFX.apply(this.ctx, currentTime);
                this.applyScreenFlash();
                if (this.glitchEffect) this.applyGlitchEffect();
                
                this.ctx.save();
                if (this.shake > 0) {
                    this.ctx.translate((Math.random() - 0.5) * this.shake, (Math.random() - 0.5) * this.shake);
                    this.shake *= 0.9;
                }
                this.drawGameObjects();
                this.ctx.restore();
            }
            
            drawHyperspaceTunnel(color) {
                const ctx = this.ctx;
                const cx = this.canvas.width / 2;
                const cy = this.canvas.height / 2;
                const maxRadius = Math.max(this.canvas.width, this.canvas.height) * 0.8;
                const breath = (Math.sin(Date.now() * 0.002 * (1 + this.gameSpeed * 0.1)) + 1) * 0.5;
                
                ctx.strokeStyle = color;
                ctx.lineWidth = 1.5;
                optimizedShadow.apply(ctx, 15, color);
                const baseRotation = this.frames * 0.005;
                for (let i = 0; i < 8; i++) {
                    const progress = ((this.tunnelOffset + i * 60) % 300) / 300;
                    const radius = progress * maxRadius;
                    if (radius < 50) continue;
                    ctx.globalAlpha = (1 - progress * 0.8) * (0.8 + breath * 0.2);
                    ctx.save();
                    ctx.translate(cx, cy);
                    ctx.rotate(baseRotation + (i * 0.1)); 
                    ctx.beginPath();
                    for(let k = 0; k < 5; k++) {
                        const angle = (k * 4 * Math.PI / 5) - (Math.PI / 2);
                        const px = Math.cos(angle) * radius;
                        const py = Math.sin(angle) * radius;
                        if(k===0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                }
                optimizedShadow.clear(ctx);
                ctx.globalAlpha = 1;
                
                // Render Background Image (Common)
                const lvl = this.gameLevels[this.currentLevelIdx];
                if (!this.voidMode && lvl.loaded && lvl.img && lvl.img.complete) {
                    ctx.globalAlpha = 0.6;
                    try {
                        const img = lvl.img;
                        const canvasRatio = this.canvas.width / this.canvas.height;
                        const imgRatio = img.width / img.height;
                        let drawWidth, drawHeight, drawX, drawY;
                        if (canvasRatio > imgRatio) {
                            drawHeight = this.canvas.height;
                            drawWidth = img.width * (drawHeight / img.height);
                            drawX = (this.canvas.width - drawWidth) / 2;
                            drawY = 0;
                        } else {
                            drawWidth = this.canvas.width;
                            drawHeight = img.height * (drawWidth / img.width);
                            drawX = 0;
                            drawY = (this.canvas.height - drawHeight) / 2;
                        }
                        ctx.filter = 'blur(1px)';
                        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                        ctx.filter = 'none';
                    } catch (e) {}
                    ctx.globalAlpha = 1.0;
                }
            }

            drawBackgroundParticles(tunnelColor) {
                // Used for HEX mode
                 this.backgroundParticles.forEach(p => {
                    p.y += p.speed * (1 + this.gameSpeed * 0.1);
                    if (p.y > this.canvas.height) { 
                        p.y = 0; 
                        p.x = Math.random() * this.canvas.width;
                        p.shape = Math.floor(Math.random() * 3);
                    }
                    this.ctx.fillStyle = p.color;
                    this.ctx.globalAlpha = p.opacity;
                    this.ctx.save();
                    this.ctx.translate(p.x, p.y);
                    this.ctx.rotate(this.frames * 0.02);
                    if (p.shape === 0) { 
                        this.ctx.beginPath(); this.ctx.moveTo(0, -p.size); this.ctx.lineTo(p.size, p.size); this.ctx.lineTo(-p.size, p.size); this.ctx.fill();
                    } else if (p.shape === 1) { 
                        this.ctx.beginPath(); this.ctx.moveTo(0, -p.size); this.ctx.lineTo(p.size, 0); this.ctx.lineTo(0, p.size); this.ctx.lineTo(-p.size, 0); this.ctx.fill();
                    } else { 
                        this.ctx.fillRect(-p.size/2, -p.size*1.5, p.size, p.size*3);
                        this.ctx.fillRect(-p.size*1.5, -p.size/2, p.size*3, p.size);
                    }
                    this.ctx.restore();
                });
                this.ctx.globalAlpha = 1;
            }
            
            updateGameObjects() {
                const currentGap = this.getCurrentGap();
                const spawnRate = Math.floor(CONFIG.PILLAR_SPAWN_BASE / (this.gameSpeed / 3)); 
                
                if (!this.voidMode && this.frames % Math.max(20, spawnRate) === 0) {
                    const p = new Pillar(this.currentLevelIdx, currentGap);
                    this.obstacles.push(p);
                    if (Math.random() > (1 - CONFIG.ORB_SPAWN_CHANCE)) {
                        this.collectibles.push(new Orb(p.x + p.w / 2, p.top + p.gap / 2));
                    }
                }
                
                if (this.voidMode && this.frames % 10 === 0) {
                     const y = Math.random() * (this.canvas.height - 100) + 50;
                     this.pentagrams.push(new Pentagram(window.innerWidth, y));
                }
                
                this.obstacles.forEach((o, i) => {
                    o.update(this.gameSpeed);
                    const hitboxReduction = CONFIG.HITBOX_OFFSET;
                    const pLeft = this.player.x - this.player.r + hitboxReduction;
                    const pRight = this.player.x + this.player.r - hitboxReduction;
                    const pTop = this.player.y - this.player.r + hitboxReduction;
                    const pBottom = this.player.y + this.player.r - hitboxReduction;
                    
                    if (o.collides(pLeft, pRight, pTop, pBottom)) { this.gameOver(); }
                    
                    if (!o.marked && o.x + o.w < this.player.x) {
                        this.score++;
                        o.marked = true;
                        document.getElementById('scoreUi').innerText = this.score;
                        this.checkLevel();
                    }
                    if (o.x < -100) this.obstacles.splice(i, 1);
                });
                
                this.collectibles.forEach((c, i) => {
                    c.update(this.gameSpeed);
                    const dist = Math.hypot(this.player.x - c.x, this.player.y - c.y);
                    if (dist < this.player.r + c.r && !c.collected) {
                        this.score += 5;
                        document.getElementById('scoreUi').innerText = this.score;
                        c.collected = true;
                        this.triggerOrbGlitch();
                        this.hitStop = 3;
                        for (let k = 0; k < 20; k++) {
                            this.particles.push(new Particle(c.x, c.y, '#ffd700', 8));
                        }
                        if (this.settings.sfx) SFX.collect();
                        Haptics.collect();
                        this.collectibles.splice(i, 1);
                        this.checkLevel();
                    }
                    if (c.x < -50) this.collectibles.splice(i, 1);
                });

                this.pentagrams.forEach((p, i) => {
                    p.update(this.gameSpeed);
                    const dist = Math.hypot(this.player.x - p.x, this.player.y - p.y);
                    if (dist < this.player.r + p.size && !p.collected) {
                        this.score += 10;
                        document.getElementById('scoreUi').innerText = this.score;
                        p.collected = true;
                        for (let k = 0; k < 10; k++) {
                            this.particles.push(new Particle(p.x, p.y, '#00ffff', 12, 'hexagram'));
                        }
                        if (this.settings.sfx) SFX.collect();
                        this.pentagrams.splice(i, 1);
                    }
                    if (p.x < -50) this.pentagrams.splice(i, 1);
                });
                
                this.player.update();
                
                this.particles.forEach((p, i) => {
                    p.update();
                    if (p.life <= 0) this.particles.splice(i, 1);
                });
            }
            
            drawGameObjects() {
                const currentLvlConfig = this.gameLevels[this.currentLevelIdx];
                this.obstacles.forEach(o => o.draw(this.ctx, currentLvlConfig));
                this.collectibles.forEach(c => c.draw(this.ctx));
                this.pentagrams.forEach(p => p.draw(this.ctx));
                this.player.draw(this.ctx, currentLvlConfig);
                this.particles.forEach(p => p.draw(this.ctx));
            }
        }

        class Player {
            constructor(mode) {
                this.mode = mode; // 'HEX' or 'MONAS'
                this.x = window.innerWidth * 0.25;
                this.y = window.innerHeight / 2;
                this.vy = 0;
                this.r = CONFIG.PLAYER_RADIUS;
                this.rot = 0;
                this.trail = [];
                // Monas gets longer, smoother trail
                this.trailLength = (mode === 'MONAS') ? 20 : 12; 
                this.jumpCooldown = 0;
                this.scaleX = 1;
                this.scaleY = 1;
            }
            
            update() {
                // --- SPLIT PHYSICS FOR MODES ---
                if (this.mode === 'MONAS') {
                    // FLOANTY PHYSICS (Low Gravity, High Drag)
                    // This creates a "gliding" feel where you hang in the air
                    this.vy += 0.18; // Super low gravity (was 0.25)
                    // Add subtle air resistance
                    this.vy *= 0.98;
                } else {
                    // SNAPPY HEX PHYSICS (Standard Flappy Style)
                    this.vy += CONFIG.GRAVITY; // 0.45
                }
                
                if (this.vy > CONFIG.MAX_FALL_SPEED) this.vy = CONFIG.MAX_FALL_SPEED;
                
                this.y += this.vy;
                this.rot += 0.03;
                
                const stretch = Math.min(Math.abs(this.vy) * 0.04, 0.3);
                if (this.vy < 0) { this.scaleY = 1 + stretch; this.scaleX = 1 - stretch * 0.5; } 
                else { this.scaleY = 1 - stretch * 0.5; this.scaleX = 1 + stretch; }

                if (this.y > window.innerHeight - this.r * 1.5) { game.gameOver(); }
                if (this.y < this.r * 1.5) { this.y = this.r * 1.5; this.vy = 0; }
                
                if (this.jumpCooldown > 0) { this.jumpCooldown--; }
                
                // Trail update
                if (game.frames % 1 === 0) { 
                    this.trail.unshift({
                        x: this.x, y: this.y, r: this.r, life: 1.0,
                        rot: this.rot, scaleX: this.scaleX, scaleY: this.scaleY
                    });
                    if (this.trail.length > this.trailLength) this.trail.pop();
                }
                
                // MONAS gets slow decay, HEX gets fast decay
                const decay = (this.mode === 'MONAS') ? 0.02 : 0.08;
                this.trail.forEach(t => t.life -= decay);
            }
            
            draw(ctx, conf) {
                const hue = (game.frames * 2) % 360;
                const strokeColor = `hsl(${hue}, 100%, 60%)`;
                const shadowColor = `hsl(${hue}, 100%, 50%)`;

                // --- DRAW TRAIL ---
                this.trail.forEach((t, i) => {
                    if (t.life > 0) {
                        ctx.save();
                        // Increased opacity for neon look
                        ctx.globalAlpha = t.life * 0.6;
                        ctx.translate(t.x, t.y);
                        ctx.scale(t.scaleX, t.scaleY);
                        ctx.rotate(t.rot + (this.vy * 0.05));
                        
                        // Apply specific look based on mode
                        if (this.mode === 'MONAS') {
                            // Gold/Blue neon for Monas
                            optimizedShadow.apply(ctx, 20 * t.life, '#ffd700');
                            ctx.strokeStyle = '#ffd700';
                            ctx.lineWidth = 2;
                            this.drawMonasShape(ctx, t.r * 1.4 * t.life); // Larger scale
                        } else {
                            // Red/Pink neon for Hex
                            optimizedShadow.apply(ctx, 20 * t.life, '#ff003c');
                            ctx.strokeStyle = '#ff003c';
                            ctx.lineWidth = 1 + t.life;
                            this.drawHexShape(ctx, t.r * 0.8 * t.life);
                        }
                        
                        ctx.restore();
                    }
                });

                ctx.globalAlpha = 1.0;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.scaleX, this.scaleY);
                ctx.rotate(this.rot + (this.vy * 0.05));
                
                const r = this.r * 1.2;
                optimizedShadow.apply(ctx, 25, shadowColor);
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 3;
                
                // --- DRAW MAIN AVATAR ---
                if (this.mode === 'MONAS') {
                    // Scale up Monas by 1.5x for visibility
                    this.drawMonasShape(ctx, r * 1.5);
                } else {
                    this.drawHexShape(ctx, r);
                }

                if (game.isMobile) {
                    ctx.save();
                    ctx.strokeStyle = shadowColor;
                    ctx.lineWidth = 8;
                    ctx.globalAlpha = 0.3;
                    ctx.stroke();
                    ctx.restore();
                }

                const pulse = Math.sin(game.frames * 0.1) * 0.5 + 1;
                ctx.fillStyle = "#fff";
                optimizedShadow.apply(ctx, 40 * pulse, "#fff");
                ctx.beginPath();
                ctx.arc(0, 0, 3 * pulse, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
            
            // --- UNICURSAL HEXAGRAM SHAPE ---
            drawHexShape(ctx, r) {
                // Unicursal hexagram points
                const points = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (i * 60 - 90) * Math.PI / 180;
                    points.push({ x: Math.cos(angle) * r, y: Math.sin(angle) * r });
                }
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                ctx.lineTo(points[2].x, points[2].y);
                ctx.lineTo(points[5].x, points[5].y);
                ctx.lineTo(points[3].x, points[3].y);
                ctx.lineTo(points[1].x, points[1].y);
                ctx.lineTo(points[4].x, points[4].y);
                ctx.lineTo(points[0].x, points[0].y);
                ctx.closePath();
                ctx.stroke();
            }

            // --- MONAS HIEROGLYPHICA SHAPE ---
            drawMonasShape(ctx, r) {
                const s = r * 0.8; 
                ctx.beginPath();
                // 1. The Crescent (Top)
                ctx.arc(0, -s, s * 0.4, 0, Math.PI, false);
                // 2. The Sun (Circle)
                ctx.moveTo(s*0.4, -s*0.4);
                ctx.arc(0, -s*0.4, s*0.4, 0, Math.PI * 2);
                // 3. The Center Point
                ctx.moveTo(1, -s*0.4);
                ctx.arc(0, -s*0.4, 1, 0, Math.PI * 2);
                // 4. The Cross
                ctx.moveTo(0, 0); // Bottom of circle
                ctx.lineTo(0, s); // Down stem
                ctx.moveTo(-s*0.6, s*0.4); // Cross bar left
                ctx.lineTo(s*0.6, s*0.4); // Cross bar right
                // 5. The Aries (Bottom)
                ctx.moveTo(-s*0.4, s); 
                ctx.bezierCurveTo(-s*0.6, s, -s*0.6, s*0.8, -s*0.4, s*0.8); // Left hook
                ctx.lineTo(s*0.4, s*0.8);
                ctx.bezierCurveTo(s*0.6, s*0.8, s*0.6, s, s*0.4, s); // Right hook
                
                ctx.stroke();
            }

            jump() {
                if (this.jumpCooldown > 0) return;
                
                // --- SPLIT JUMP PHYSICS FOR MODES ---
                if (this.mode === 'MONAS') {
                    // Gentle impulse for floaty mode
                    this.vy = -4.8; // Bouncier but controlled (was -6.0)
                } else {
                    // Snappy jump for Hex mode
                    this.vy = CONFIG.PLAYER_JUMP_FORCE; // -7.5
                }
                
                this.jumpCooldown = game.isMobile ? 8 : 5;
                if (Math.random() > 0.7) GlitchFX.trigger(40, 'jump');
                
                for (let i = 0; i < (game.isMobile ? 10 : 12); i++) {
                    const type = Math.random() > 0.7 ? 'hexagram' : Math.random() > 0.4 ? 'triangle' : 'circle';
                    game.particles.push(new Particle(this.x, this.y, '#fff', 3, type));
                }
                if (game.settings.sfx) SFX.jump();
                Haptics.jump();
                GlitchFX.trigger(50, 'rgb');
            }
        }

        class Pillar {
            constructor(lvlIndex, currentGap) {
                this.x = window.innerWidth;
                this.w = CONFIG.PILLAR_WIDTH;
                this.gap = currentGap;
                const maxTop = window.innerHeight - this.gap - 50;
                const minTop = 30;
                this.top = Math.random() * (maxTop - minTop) + minTop;
                this.baseTop = this.top; 
                this.marked = false;
                this.lvl = lvlIndex;
                this.rotation = Math.random() * Math.PI * 2;
                this.innerPattern = Math.floor(Math.random() * 3);
                this.pulse = 0;
                this.hasWarning = game.isMobile && Math.random() > 0.5;
                this.warningAlpha = 1;
            }
            
            update(speed) { 
                this.x -= speed;
                this.pulse += 0.05;
                this.rotation += 0.005;
                if (this.hasWarning) { this.warningAlpha -= 0.01; }
                const breathe = Math.sin(game.frames * 0.05) * 5;
                this.top = this.baseTop + breathe;
            }
            
            collides(pLeft, pRight, pTop, pBottom) {
                 const pillarLeft = this.x;
                 const pillarRight = this.x + this.w;
                 const topPillarBottom = this.top;
                 const topPillarTop = 0;
                 const bottomPillarTop = this.top + this.gap;
                 const bottomPillarBottom = window.innerHeight;
                 
                 const horizontalOverlap = pRight > pillarLeft && pLeft < pillarRight;
                 const hittingTopPillar = horizontalOverlap && pBottom > topPillarTop && pTop < topPillarBottom;
                 const hittingBottomPillar = horizontalOverlap && pTop < bottomPillarBottom && pBottom > bottomPillarTop;
                 
                 return hittingTopPillar || hittingBottomPillar;
            }
            
            draw(ctx, conf) {
                const hue = (game.frames * 0.5 + this.x * 0.1) % 360;
                const mainColor = `hsl(${hue}, 100%, 60%)`;
                const innerColor = `hsl(${(hue + 60) % 360}, 100%, 70%)`;
                const glowColor = `hsl(${hue}, 100%, 50%)`;
                
                if (this.hasWarning && this.x < window.innerWidth * 0.7 && this.warningAlpha > 0) {
                    ctx.save();
                    ctx.globalAlpha = this.warningAlpha * 0.3;
                    ctx.fillStyle = '#ff003c';
                    ctx.fillRect(this.x - 10, 0, this.w + 20, window.innerHeight);
                    ctx.restore();
                }
                
                ctx.save();
                ctx.translate(this.x + this.w/2, 0);
                
                optimizedShadow.apply(ctx, 30, glowColor);
                ctx.strokeStyle = mainColor;
                ctx.lineWidth = 4;
                ctx.fillStyle = "rgba(0,0,0,0.7)";
                const topHeight = this.top + 10;
                ctx.beginPath();
                ctx.moveTo(-this.w/2, -10);
                ctx.lineTo(this.w/2, -10);
                
                const jagCount = 5;
                for (let i = 0; i <= jagCount; i++) {
                    const x = this.w/2 - (i * this.w/jagCount);
                    const y = -10 + (i % 2 === 0 ? 8 : -4);
                    ctx.lineTo(x, y);
                }
                
                ctx.lineTo(-this.w/2, topHeight);
                ctx.lineTo(-this.w/2, -10);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.save();
                ctx.translate(0, topHeight/2);
                ctx.rotate(this.rotation);
                ctx.globalAlpha = 0.4;
                ctx.strokeStyle = innerColor;
                ctx.lineWidth = 1.5;
                this.drawPattern(ctx, Math.min(this.w, topHeight) * 0.3);
                ctx.restore();

                const botY = this.top + this.gap;
                const botHeight = window.innerHeight - botY + 10;
                ctx.beginPath();
                ctx.moveTo(-this.w/2, botY);
                ctx.lineTo(this.w/2, botY);
                for (let i = 0; i <= jagCount; i++) {
                    const x = this.w/2 - (i * this.w/jagCount);
                    const y = botY + (i % 2 === 0 ? -4 : 8);
                    ctx.lineTo(x, y);
                }
                
                ctx.lineTo(this.w/2, botY + botHeight);
                ctx.lineTo(-this.w/2, botY + botHeight);
                ctx.lineTo(-this.w/2, botY);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.save();
                ctx.translate(0, botY + botHeight/2);
                ctx.rotate(-this.rotation);
                ctx.globalAlpha = 0.4;
                ctx.strokeStyle = innerColor;
                ctx.lineWidth = 1.5;
                this.drawPattern(ctx, Math.min(this.w, botHeight) * 0.3);
                ctx.restore();
                
                ctx.restore();
                optimizedShadow.clear(ctx);
                ctx.globalAlpha = 1.0;
            }

            drawPattern(ctx, size) {
                if (this.innerPattern === 0) {
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = Math.cos(angle) * size;
                        const y = Math.sin(angle) * size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                } else if (this.innerPattern === 1) {
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size * 0.866, size * 0.5);
                    ctx.lineTo(-size * 0.866, size * 0.5);
                    ctx.closePath();
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.moveTo(-size, 0);
                    ctx.lineTo(size, 0);
                    ctx.moveTo(0, -size);
                    ctx.lineTo(0, size);
                    ctx.stroke();
                }
            }
        }

        class Orb {
            constructor(x, y) {
                this.x = x;
                this.y = y; 
                this.r = 9;
                this.collected = false;
                this.float = Math.random() * Math.PI * 2;
                this.pulse = 0;
                this.rotation = 0;
            }
            
            update(speed) {
                this.x -= speed;
                this.float += 0.1;
                this.pulse += 0.15;
                this.rotation += 0.02;
                this.y += Math.sin(this.float) * 0.8;
            }
            
            draw(ctx) {
                if (this.collected) return;
                const pulseSize = this.r + Math.sin(this.pulse) * 3;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                optimizedShadow.apply(ctx, 25, '#ffd700');
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
                ctx.stroke();
                
                optimizedShadow.apply(ctx, 30, '#fff');
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.9;
                const r = pulseSize * 0.7;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i * 60) * Math.PI / 180;
                    const x = Math.cos(angle) * r;
                    const y = Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
        }

        class Pentagram {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 20;
                this.collected = false;
                this.rotation = 0;
                this.hue = Math.random() * 360;
            }
            update(speed) {
                this.x -= speed;
                this.rotation += 0.1;
                this.hue += 10;
            }
            draw(ctx) {
                if (this.collected) return;
                const color = `hsl(${this.hue}, 100%, 70%)`;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                optimizedShadow.apply(ctx, 20, color);
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                for(let k = 0; k < 5; k++) {
                    const angle = (k * 4 * Math.PI / 5) - (Math.PI / 2);
                    const px = Math.cos(angle) * this.size;
                    const py = Math.sin(angle) * this.size;
                    if(k===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.stroke();
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
        }

        class Particle {
            constructor(x, y, c, speed, type = 'circle') {
                this.x = x;
                this.y = y; 
                this.c = c;
                this.vx = (Math.random() - 0.5) * speed;
                this.vy = (Math.random() - 0.5) * speed;
                this.life = 1; 
                this.size = Math.random() * 3 + 2;
                this.type = type;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.2;
                this.glow = Math.random() > 0.5;
            }
            
            update() { 
                this.x += this.vx;
                this.y += this.vy; 
                this.vx *= 0.97;
                this.vy *= 0.97;
                this.life -= 0.03; 
                this.rotation += this.rotationSpeed;
                this.size *= 0.98;
                if (game.isMobile) { this.life -= 0.01; }
            }
            
            draw(ctx) {
                if (this.life <= 0) return;
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.c;
                if (this.glow && this.life > 0.3) {
                    optimizedShadow.apply(ctx, 20 * this.life, this.c);
                }
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                if (this.type === 'hexagram') {
                    const r = this.size * 0.8;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 'triangle') {
                    const r = this.size;
                    ctx.beginPath();
                    ctx.moveTo(0, -r);
                    ctx.lineTo(r * 0.866, r * 0.5);
                    ctx.lineTo(-r * 0.866, r * 0.5);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
        }
        
        // --- STAR CLASSES FOR DIFFERENT MODES ---
        class Star {
            constructor() {
                this.x = Math.random() * window.innerWidth;
                this.y = Math.random() * window.innerHeight;
                this.size = Math.random() * 2;
                this.speed = Math.random() * 0.5 + 0.1;
                this.alpha = Math.random() * 0.5 + 0.2;
                this.twinkle = Math.random() * Math.PI * 2;
            }
            update() {
                this.y += this.speed;
                if (this.y > window.innerHeight) {
                    this.y = 0;
                    this.x = Math.random() * window.innerWidth;
                }
                this.twinkle += 0.05;
                this.alpha = 0.3 + Math.sin(this.twinkle) * 0.2;
            }
            draw(ctx) {
                const conf = game.gameLevels[game.currentLevelIdx];
                ctx.fillStyle = conf ? conf.accent : '#fff';
                ctx.globalAlpha = this.alpha;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1.0;
            }
        }

        class WarpStar {
            constructor() { this.reset(); }
            reset() {
                this.x = (Math.random() - 0.5) * window.innerWidth;
                this.y = (Math.random() - 0.5) * window.innerHeight;
                this.z = Math.random() * window.innerWidth;
                this.pz = this.z;
            }
            update(speed, isVoid) {
                const speedFactor = isVoid ? 25 : 10;
                this.z -= speed * speedFactor * 0.1;
                if (this.z < 1) {
                    this.reset();
                    this.z = window.innerWidth;
                    this.pz = this.z;
                }
            }
            draw(ctx, cx, cy, color) {
                const sx = (this.x / this.z) * 100 + cx;
                const sy = (this.y / this.z) * 100 + cy;
                const alpha = (window.innerWidth - this.z) / window.innerWidth;
                ctx.fillStyle = color;
                ctx.globalAlpha = alpha;
                const size = (1 - this.z / window.innerWidth) * 3;
                ctx.fillRect(sx, sy, size, size);
                ctx.globalAlpha = 1.0;
            }
        }

        let game;
        document.addEventListener('DOMContentLoaded', () => {
            game = new Game();
        });
    </script>
</body>
</html>

        canvas { display: block; width: 100%; height: 100%; }

        /* CRT Scanline Effect */
        .scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
            opacity: 0.4;
        }
        
        .vignette {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, black 130%);
            pointer-events: none;
            z-index: 11;
        }

        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 20;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            transition: opacity 0.3s ease;
            padding: 20px;
            box-sizing: border-box;
        }

        #startScreen {
            background-size: cover;
            background-position: center;
            animation: bgBreath 15s infinite alternate ease-in-out;
        }
        
        #startScreen::before {
            content: '';
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: -1;
            backdrop-filter: blur(3px);
        }

        @keyframes bgBreath {
            0% { transform: scale(1); }
            100% { transform: scale(1.02); }
        }

        .hidden { opacity: 0 !important; pointer-events: none !important; display: none !important; }

        /* --- BUTTONS: GLOWING & CHANGING COLORS --- */
        .mystic-btn {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #fff;
            color: #fff;
            padding: 12px 20px;
            font-size: 0.9rem;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 3px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 220px;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(5px);
            margin: 8px;
            /* Constant color cycling animation for ALL buttons */
            animation: chromaticPulse 4s infinite alternate;
        }

        @keyframes chromaticPulse {
            0% { 
                border-color: #ff003c; 
                box-shadow: 0 0 10px #ff003c, inset 0 0 5px #ff003c;
                color: #fff;
            }
            33% {
                border-color: #ffd700;
                box-shadow: 0 0 15px #ffd700, inset 0 0 8px #ffd700;
                color: #ffeebb;
            }
            66% {
                border-color: #00f0ff;
                box-shadow: 0 0 10px #00f0ff, inset 0 0 5px #00f0ff;
                color: #e0ffff;
            }
            100% {
                border-color: #ff00ff;
                box-shadow: 0 0 10px #ff00ff, inset 0 0 5px #ff00ff;
                color: #fff;
            }
        }

        .mystic-btn:hover {
            background: #fff;
            color: #000 !important;
            animation: none;
            transform: scale(1.05);
            box-shadow: 0 0 30px #fff;
            border-color: #fff;
        }

        .mode-select-container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* --- TITLE TEXT: GLITCH & GLOW --- */
        .title-text {
            font-family: 'Cinzel Decorative', cursive;
            font-size: 5rem;
            color: #fff;
            position: relative;
            margin-bottom: 5px;
            letter-spacing: -2px;
            animation: glitchSkew 3s infinite linear alternate-reverse, titleGlow 4s infinite alternate;
        }
        
        @keyframes titleGlow {
            0% { text-shadow: -1px 0 #ff003c; }
            50% { text-shadow: 0 0 20px #ffd700, -2px 0 #ff003c; }
            100% { text-shadow: 0 0 10px #00f0ff, 2px 0 #00f0ff; }
        }

        .title-text::before, .title-text::after {
            content: "Sex Magick";
            position: absolute; left: 0; top: 0; width: 100%; height: 100%;
            background: #000; overflow: hidden; opacity: 0.7;
        }
        
        .title-text::before {
            left: 2px; text-shadow: -1px 0 #ff003c;
            clip: rect(24px, 550px, 90px, 0);
            animation: glitch-anim-1 2.5s infinite linear alternate-reverse;
        }
        
        .title-text::after {
            left: -2px; text-shadow: -1px 0 #00ffff;
            clip: rect(85px, 550px, 140px, 0);
            animation: glitch-anim-2 3s infinite linear alternate-reverse;
        }

        @keyframes glitchSkew {
            0% { transform: skew(0deg); }
            10% { transform: skew(-2deg); }
            20% { transform: skew(2deg); }
            30% { transform: skew(0deg); }
            40% { transform: skew(0deg); }
            50% { transform: skew(0deg); }
            60% { transform: skew(0deg); }
            70% { transform: skew(0deg); }
            80% { transform: skew(0deg); }
            90% { transform: skew(0deg); }
            100% { transform: skew(0deg); }
        }

        @keyframes glitch-anim-1 {
            0% { clip: rect(20px, 9999px, 80px, 0); }
            20% { clip: rect(70px, 9999px, 10px, 0); }
            40% { clip: rect(20px, 9999px, 80px, 0); }
            60% { clip: rect(10px, 9999px, 60px, 0); }
            80% { clip: rect(50px, 9999px, 20px, 0); }
            100% { clip: rect(60px, 9999px, 70px, 0); }
        }
        @keyframes glitch-anim-2 {
            0% { clip: rect(70px, 9999px, 10px, 0); }
            20% { clip: rect(10px, 9999px, 60px, 0); }
            40% { clip: rect(50px, 9999px, 20px, 0); }
            60% { clip: rect(20px, 9999px, 80px, 0); }
            80% { clip: rect(60px, 9999px, 70px, 0); }
            100% { clip: rect(20px, 9999px, 80px, 0); }
        }

        .level-indicator {
            position: absolute; bottom: 40px; width: 100%; text-align: center;
            font-size: 1.2rem; font-family: 'Cinzel Decorative', serif;
            font-weight: 700; letter-spacing: 8px; z-index: 15;
            text-transform: uppercase; color: rgba(255, 255, 255, 0.85);
            text-shadow: 2px 0px 0px rgba(255, 0, 60, 0.7), -2px 0px 0px rgba(0, 255, 255, 0.7);
            mix-blend-mode: screen; opacity: 0.8;
            animation: holoFloat 4s ease-in-out infinite; 
        }

        @keyframes holoFloat {
            0%, 100% { transform: translateY(0); opacity: 0.8; }
            50% { transform: translateY(-5px); opacity: 0.6; text-shadow: 3px 0px 0px rgba(255, 0, 60, 0.5), -3px 0px 0px rgba(0, 255, 255, 0.5); }
        }

        .score-display {
            position: absolute; top: 12%; width: 100%;
            text-align: center; font-size: 8rem;
            font-family: 'Cinzel Decorative', serif;
            color: rgba(255, 255, 255, 0.15); 
            z-index: 5; pointer-events: none;
            mix-blend-mode: overlay; font-weight: 900;
        }

        .void-active .score-display {
            color: rgba(0, 255, 255, 0.3);
            text-shadow: 0 0 20px rgba(0,255,255,0.5);
            animation: shake 0.5s infinite;
        }
        @keyframes shake { 0% { transform: translate(1px, 1px); } 100% { transform: translate(-1px, -1px); } }

        .leaderboard-container {
            background: rgba(10, 10, 10, 0.6);
            border: 1px solid rgba(255, 0, 60, 0.3);
            padding: 20px; margin-top: 15px; width: 320px;
            pointer-events: auto; backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(0,0,0,0.5); border-radius: 4px;
        }
        .leaderboard-title {
            color: var(--secondary);
            font-family: 'Cinzel Decorative', cursive;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 8px; margin-bottom: 10px;
            letter-spacing: 2px; font-size: 1.1rem;
        }
        .leaderboard-row {
            display: flex; justify-content: space-between;
            font-family: 'Orbitron', monospace;
            font-size: 0.85rem; padding: 4px 0; color: #ccc;
        }
        .rank-1 { color: #ffd700; text-shadow: 0 0 8px rgba(255, 215, 0, 0.5); font-weight: bold; }

        .progress-bar {
            width: 300px; height: 2px; background: #333; margin: 25px 0;
            position: relative;
        }
        .progress-fill {
            height: 100%; background: var(--primary); width: 0%;
            transition: width 0.2s ease; box-shadow: 0 0 10px var(--primary);
        }

        .instructions {
            position: absolute; bottom: 100px; width: 100%; text-align: center;
            font-size: 0.7rem; color: rgba(255, 255, 255, 0.4); letter-spacing: 4px;
            z-index: 15; font-family: 'Orbitron', sans-serif;
            animation: fadeOut 5s ease-in-out forwards; animation-delay: 2s; 
            pointer-events: none;
        }
        @keyframes fadeOut { 0% { opacity: 1; } 100% { opacity: 0; visibility: hidden; } }

        .pause-btn {
            position: absolute; top: 30px; right: 30px; width: 40px; height: 40px;
            background: rgba(0, 0, 0, 0.5); border: 1px solid var(--primary);
            color: var(--primary);
            border-radius: 50%; cursor: pointer; z-index: 25;
            display: flex; justify-content: center; align-items: center; font-size: 1.2rem;
            pointer-events: auto; backdrop-filter: blur(4px); transition: 0.3s;
        }
        .pause-btn:hover { background: var(--primary); color: #000; }

        .stats-panel {
            position: absolute; top: 30px; left: 30px;
            background: rgba(0, 0, 0, 0.5); border-left: 2px solid var(--primary);
            padding: 8px 12px; font-size: 0.7rem; color: #888; z-index: 25;
            pointer-events: auto; font-family: 'Orbitron', monospace; text-align: left;
            backdrop-filter: blur(4px);
        }
        
        .mobile-controls {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 30;
        }
        .mobile-jump-area {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 40%;
            pointer-events: auto; background: transparent;
            display: flex; justify-content: center; align-items: center;
        }
        .mobile-jump-indicator {
            background: rgba(255, 0, 60, 0.1);
            border: 1px solid rgba(255, 0, 60, 0.4);
            border-radius: 50%; width: 70px; height: 70px;
            display: flex; justify-content: center; align-items: center;
            color: rgba(255,255,255,0.7);
            font-size: 0.7rem; letter-spacing: 2px; text-transform: uppercase;
            backdrop-filter: blur(2px); animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { transform: scale(1); opacity: 0.5; } 50% { transform: scale(1.05); opacity: 0.8; } 100% { transform: scale(1); opacity: 0.5; } }

        /* --- RESPONSIVE ADAPTATION --- */
        @media (max-width: 768px) {
            .title-text { font-size: 3.5rem !important; }
            .score-display { font-size: 6rem !important; top: 15% !important; }
            .level-indicator { font-size: 1rem !important; bottom: 80px !important; letter-spacing: 5px !important;}
            .mystic-btn { padding: 12px 15px !important; font-size: 0.8rem !important; min-width: 150px !important; }
            .instructions { bottom: 140px !important; font-size: 0.6rem !important; }
            .leaderboard-container { width: 85% !important; padding: 15px; }
            .mode-select-container { gap: 10px; }
        }
        
        .loader {
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-top: 2px solid var(--primary);
            border-radius: 50%; width: 30px; height: 30px;
            animation: spin 1s linear infinite; margin: 0 auto 15px auto;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="scanlines"></div>
        <div class="vignette"></div>
        
        <div id="scoreUi" class="score-display">0</div>
        <div id="levelUi" class="level-indicator">INITIATION</div>
        
        <div id="mobileControls" class="mobile-controls hidden">
            <div class="mobile-jump-area">
                <div class="mobile-jump-indicator">TAP</div>
            </div>
        </div>
        
        <div id="startScreen" class="ui-layer" style="background-image: url('https://lh3.googleusercontent.com/d/1BXrXXd9TKSqCFNwvS-cJpNORbyvP6fkR=s0');">
            <div style="z-index: 2;">
                <h1 class="title-text">Sex Magick</h1>
                <p style="letter-spacing: 6px; color: #ff003c; margin-bottom: 30px; font-size: 0.9rem; text-shadow: 0 0 5px #ff003c; font-family: 'Orbitron'; text-transform: uppercase;">Do Your Will Foo</p>
            </div>
            
            <div id="loadingMsg">
                <div class="loader"></div>
                <p id="loadingText" style="letter-spacing: 4px; font-size: 0.8rem; color: #aaa; font-family: 'Orbitron';">CHARGING SIGIL...</p>
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill"></div>
                </div>
            </div>

            <div id="menuButtons" class="hidden" style="width: 100%; display: flex; flex-direction: column; align-items: center;">
                
                <div class="mode-select-container">
                    <button id="startHexBtn" class="mystic-btn">RITE OF HEXAGRAM</button>
                    <button id="startMonasBtn" class="mystic-btn">RITE OF MONAS</button>
                </div>
                
                <button id="settingsBtn" class="mystic-btn" style="min-width: 150px; padding: 10px; font-size: 0.8rem;">SETTINGS</button>
                
                <div class="leaderboard-container">
                    <div class="leaderboard-title">:: HIGH GNOSIS ::</div>
                    <div id="leaderboardList">LOADING SCORES...</div>
                </div>
                
                <p id="trackName" style="margin-top: 10px; font-size: 0.6rem; color: #444; letter-spacing: 1px;">SOURCE: GITHUB CDN</p>
            </div>
        </div>

        <div id="gameOverScreen" class="ui-layer hidden" style="background: rgba(0,0,0,0.85);">
            <h1 class="title-text" style="color: #ff003c; font-size: 3.5rem;">Good job foo</h1>
            <p style="font-size: 1rem; letter-spacing: 4px; margin-bottom: 20px; font-family: 'Orbitron'; color: #888;">RITUAL ENDED</p>
            <p class="text-xl mb-6 text-gray-300">WILL: <span id="finalScore" style="color: #fff; font-weight:bold; text-shadow: 0 0 10px #fff;">0</span></p>
            <p id="uploadStatus" style="color: var(--secondary); font-size: 0.8rem; margin-bottom: 10px;">CONNECTING TO ETHER...</p>
            <p id="highScoreMsg" style="color: #ffd700; margin-bottom: 20px; font-size: 0.9rem; letter-spacing: 2px;"></p>
            
            <button id="restartBtn" class="mystic-btn">REINCARNATE</button>
            <button id="voidBtn" class="mystic-btn">RETURN TO VOID</button>
        </div>

        <div id="pauseScreen" class="ui-layer hidden">
            <h1 class="title-text" style="font-size: 3rem; color: #ffd700;">MEDITATION</h1>
            <button id="resumeBtn" class="mystic-btn">RESUME</button>
            <button id="menuBtn" class="mystic-btn">ABORT</button>
        </div>

        <div id="settingsScreen" class="ui-layer hidden" style="background: rgba(0,0,0,0.9);">
            <h1 class="title-text" style="font-size: 2.5rem;">SACRED RITES</h1>
            <div style="width: 300px; margin: 20px 0; background: rgba(20,20,20,0.6); padding: 25px; border: 1px solid var(--primary); backdrop-filter: blur(10px);">
                <div style="display: flex; justify-content: space-between; margin: 15px 0; border-bottom: 1px solid #444; padding-bottom: 10px;">
                    <span>CHANT (MUSIC)</span>
                    <input type="checkbox" id="musicToggle" checked style="accent-color: var(--primary);">
                </div>
                <div style="display: flex; justify-content: space-between; margin: 15px 0; border-bottom: 1px solid #444; padding-bottom: 10px;">
                    <span>RESONANCE (SFX)</span>
                    <input type="checkbox" id="sfxToggle" checked style="accent-color: var(--primary);">
                </div>
                <div style="display: flex; justify-content: space-between; margin: 15px 0;">
                    <span>KUNDALINI (VIBE)</span>
                    <input type="checkbox" id="vibrationToggle" checked style="accent-color: var(--primary);">
                </div>
            </div>
            <button id="backBtn" class="mystic-btn">RETURN</button>
        </div>

        <button id="pauseBtn" class="pause-btn hidden">||</button>
        
        <div id="statsPanel" class="stats-panel">
            <div style="color: var(--primary); font-weight: bold; margin-bottom: 5px;">:: GNOSIS ::</div>
            FPS: <span id="fpsCounter" style="color: #fff;">0</span><br>
            AUDIO: <span id="audioStatus" style="color: #fff;">STANDBY</span>
        </div>

        <div id="instructions" class="instructions hidden">
            [ TAP / SPACE TO ASCEND ]
        </div>
    </div>

    <script>
        const AUDIO_BASE = "https://raw.githubusercontent.com/bookthief666/93-protocol-game-assets-/8c1973f1dada601ef830fa99ebfbbb67906b10cd/";
        const CDN_PREFIX = "https://cdn.jsdelivr.net/gh/bookthief666/93-protocol-game-assets-@662f3d608769e9e945295ac00d668447d974dc5c/";

        const CONFIG = {
            DEBUG: false,
            MENU_MUSIC: AUDIO_BASE + "iamerror%20-%20The%20Zelda%20Song%20(Hyr00l).mp3",
            GAME_PLAYLIST: [
                AUDIO_BASE + "iamerror%20-%20The%20Zelda%20Song%20(Hyr00l).mp3",
                AUDIO_BASE + "iamerror%20-%20Hyr00l%20Rough.mp4",
                AUDIO_BASE + "forget%20me%20remix%2093.flac",
                AUDIO_BASE + "eyedea%20_%201950s%20void%20the%C3%B4ry%20.mp3",
                AUDIO_BASE + "bookthief%F0%9F%A5%80%20-%20booothief-%20All%20gay%F0%9F%98%87%202024-07-10%2001_11%20(1).m4a",
                AUDIO_BASE + "bookthief%F0%9F%A5%80%20-%20How%20Much%20Does%20One%20Pay%202024-07-31%2018_24.m4a",
                AUDIO_BASE + "bookthief%20x%20inv.s.b.l.ty-%20Liquid%20Sovereignty.flac",
                AUDIO_BASE + "Post%20Mvdern%20-%20Pleiades%2018MAR25.flac",
                AUDIO_BASE + "MONOLITH%20bounce%201.mp3",
                AUDIO_BASE + "LEX_LFL_80_wurli_loop_ate_bit_Cm.wav"
            ],
            GAMEOVER_PLAYLIST: [
                AUDIO_BASE + "Post%20Mvdern%20-%20Pleiades%2018MAR25.flac",
                AUDIO_BASE + "LEX_LFL_80_wurli_loop_ate_bit_Cm.wav"
            ],
            BASE_URL: "https://lh3.googleusercontent.com/d/",
            IMG_SUFFIX: "=s0",
            
            // --- PHYSICS CONSTANTS ---
            INITIAL_GAME_SPEED: 3.8,
            SPEED_INCREASE_PER_LEVEL: 0.08, 
            MAX_GAME_SPEED: 8.5, 
            PILLAR_SPAWN_BASE: 140, 
            PILLAR_WIDTH: 45,
            PILLAR_GAP: 200, 
            PILLAR_GAP_DECREASE_PER_5_LEVELS: 10, 
            MIN_PILLAR_GAP: 110, 
            ORB_SPAWN_CHANCE: 0.5,
            // These will be overridden by Mode selection
            PLAYER_JUMP_FORCE: -7.5,
            GRAVITY: 0.45,
            MAX_FALL_SPEED: 11,
            PLAYER_RADIUS: 16, 
            HITBOX_OFFSET: 4, 
            MOBILE_CONTROL_DEADZONE: 50,
            VOID_DURATION: 300, 
            VOID_INTERVAL: 5, 
        };

        const originalLevels = [
            { name: "MALKUTH", id: "1jI7bl3hsVOuzYf6u35L4bhHq5JUiBDa1" },
            { name: "YESOD", id: "1tHgxNvDO5md4z24hS81eTa9uva25mtr5" },
            { name: "HOD", id: "1Mtp6cP6lwGbPRhLWjQKKDijrLX53K4UR" },
            { name: "NETZACH", id: "1y1i5lxL1jVp37bIz1mtJh4-Puce-E5k0" },
            { name: "TIPHARETH", id: "12png0vOPyJC1Ab4Vffcw2R_K-yRw1sqj" },
            { name: "GEBURAH", id: "1le2Hox1ORxhL28fv7WujO0410vM6jUEJ" },
            { name: "CHESED", id: "1Gsq1xSx9ivfVEq6W2nCMrO-dOIMrSYrW" },
            { name: "DA'ATH", id: "1o601hrLi5RpuGL_kiVEoPXxXk2SCbM2z" },
            { name: "BINAH", id: "1iSYJfPsaYjA1rmRTsujLcn1Do-lBydF7" },
            { name: "CHOKMAH", id: "1PvOC62nv5HdsE1cuCF8RENY9Z8HTabn7" },
            { name: "KETHER", id: "1Ym_eyrXJEQUBA7Lg_2oUc6dQ-gy9yfGs" }
        ];

        const newImageIDs = [
            "1pJ5CUGyKXgkSgEREkKos1Kch5FmfUyxE", "1spT4HpO_4q9joE4x6bLjZQRlFTS9j-ie", "1YGzyjcjiCoPCLbYjJEiqT8USUhe4S6hM", "1ELjoJU7KDC88nUk_Vs57OKUG9oLl5E8N",
            "1faa2c3QFWhZ8UgvyZ_ZrlnyFsnsKRclm", "10W5oYkoqB9LC3YjvB_aozR0kG3hWaHka", "1l9Jdm0EQh8sgWh1W0wsXQCzrQM19Bfm9", "1BrHTF2dvfbRkyYfXAbPUiujwE1AJskY4",
            "1KqV8IYF7KDbmgHS3ph6eRQKl4uAAFG_u", "1sZ02UH_vb1xLaOvyETqptc5FuvOtVKd4", "1hLKOGYXCBemcIKt8OLEX4dHTn6bd88cr", "1g_DQeG6qldMBxHzZ82MOVoxk9APwb4NO",
            "1-SIvE5EZyUd7FKXJ7eyB4JCrtOpQoF18", "1S4y4YSCjxSb-b_U1BfMw_0PhabJ-METm", "1OL-kWl-TJNcZFPcsCAtynW2NWp-YYjGd", "1ApPgou40N2Q6GlNKNuyoQ2Gk5DqAfmw_",
            "1OeH1GMu2rDcwzdtWFZSB1WWe0OjkmxV0", "12Z92v9Mu9yNOnDTtK-bjMRZ8_2BAW2eW", "1Erf3DKxZpfbG57oGcUCjuHIhajsweLZz", "1qK22CJhJ1XgElL156uOQxYrucaRG16p0",
            "1euwdAWg-xQw7isR-JAiZ-krXQXOS8pi0", "1A3hT3mJibINtsr8CVxTmp71QsYgPB2JZ", "1QUVr-RK2kP7IIAuy0wX3pOZRQuyr-o-e", "1eF02YMyYBcgx7Ga20pXgoltzWXPYznfD",
            "1zx1vrrbuSA4xCFKXAHgXbkG1rX8PUPel", "1ds1iqXf90gy9PUFs80t4QOxamkJj0u1I", "14-t6dPPv5MeXe7LWPIp7Tjc8x4w5Vj2d", "1pUtIizMzVhjzB46dhah5mgz6Tr-vaSLO",
            "1ZOEkUW8q2s5zerS7BubYJU69RHk7_Zlo", "15ZHj0fLYu-4rEQy43BMJKDgXnnQ5FeyP", "1ZzgVT0O6XQzW3DUP4i1aoKd_DD5wV5LZ", "1rZHZM0bR_j6uiYZLS82J0BkbIfEUoXvY",
            "1CNrQ_EeMXQgHJGXxe7EHysQi_A0A9UE7", "1ubCqIg7ETOIsHGfBjQfVsRzjlZIpBP6E", "1pojzjR-uiQ0oTHRJxXXCW_w0hlJUCqyb", "1SnclBlH6sflhaTWzFhbcNedzNeh25-BV",
            "1thfc-9DnM4GhCi0zTbcX4MH-yaQEpomX", "1BXrXXd9TKSqCFNwvS-cJpNORbyvP6fkR", "1D1bOksatIt6Jw6Zq8Sbmhbq_GC_2EQHh", "1eP_Xnk80YnL3w3Q69wQmVo9_F0OaA3Wo",
            "1ARDOipcr0lB1GYf3gmhqlHXlpC23Q2JE", "1io39jfggXQl-OyvSFGIpgOtoIzHbml3M", "1o0rJmx3vEKITMx1ixP5iruOX2ujOT6VO", "1Irw61utgSGdip21OgTcYqz56LpWWS9fb",
            "19V2ObVoQn9R9bt1ZgMNEBJokaAjYdX_9", "1WWvLnkkPBN7Q0ZsGi16FL1anhPlti3Qd", "1HoYqC0SLc3nrSDnoW9KJ2-z8AnRWIz5M", "1oS0J3F-zh5H48-Qs5Mrm10dPR993kF-b",
            "1bRwsBEuZiAIZW_5f3WOZVI6-KVnCEslk", "1GLza2_RmR4c_KD_KGxbXPOoCAw9SITKl", "1uWFSChozQmHEnuJwXqiPNApXuAwPAzKS", "1t2hNBEudzIo19kuP8ksPY_cNetDdTd8P",
            "1KhMBL7a3NSggVerbyy53fQ-dLq11adwj", "1wgxalTR68YM7oIku8JYZYKtG50atEnG_", "1BceMgnHgVn9U_7EYnXQu9HDwEQY1UBa_", "14_iwYDQjp34-R_iby8QadKnI9m3zVnOu",
            "1cZ_ci9J80jnqCAdag8SQofYZw1dfsX3C", "15z3bGrCqUy8SQjX1dO5C1vlN3y4-soai", "10xAFw98B39Ou0SSeB4eWyoY2D_OLLPgz", "1CexZQw11p33u1-YA7JhPAkGV6NBCgd6e",
            "16t1EdHfHRpb7GmqNAfo2iKKm57qLfbKn", "12wQOhUztVCVEFV21fPDq-JXGi5zxdkeQ", "1-0u9JUH0oUHD1--5iaySxRpO_PuyxkH6", "1wnITY3i6XxOr1b3l6P0cT10LkEHQauO5"
        ].filter((value, index, self) => self.indexOf(value) === index);

        const esotericNames = [
            "KUNDALINI", "HIEROS GAMOS", "SACRED UNION", "RED TINCTURE", "WHITE GLUTEN", 
            "CUP OF BABALON", "BLOOD OF SAINTS", "CITY OF PYRAMIDS", "NIGHT OF PAN", 
            "HADIT'S FLAME", "NUIT'S EMBRACE", "LAW OF THELEMA", "LOVE UNDER WILL", 
            "GREAT WORK", "STONE OF WISE", "ELIXIR OF LIFE", "RED LION", "WHITE EAGLE",
            "ABRAHADABRA", "LASHTAL", "KA", "BA", "KHU", "SCARLET WOMAN", "THE BEAST",
            "AEON OF HORUS", "93", "AGAPE", "THELEMA", "VIA OVUM", "SPERMATOZOON",
            "HOMUNCULUS", "DIVINE EROS", "TANTRA", "YONI", "LINGAM", "O.T.O.", "A.'.A.'.",
            "STAR SAPPHIRE", "MASS OF PHOENIX", "LIBER AL", "RESH", "SAMEKH", "TZADDI"
        ];
        
        let MASTER_POOL = [...originalLevels];
        
        const palette = ["#ff003c", "#ff00ff", "#9d00ff", "#00f0ff", "#00ff9d", "#d4ff00", "#ff8800"];
        newImageIDs.forEach((id, index) => {
            const nameIndex = index % esotericNames.length;
            MASTER_POOL.push({
                name: esotericNames[nameIndex],
                id: id,
                color: "#000",
                accent: palette[index % palette.length],
                img: null,
                loaded: false
            });
        });

        // --- LOOTLOCKER CONFIG ---
        const LEADERBOARD_ID = "global_ritual";
        const API_KEY = "dev_44a2b8e7798a416eba598ee295a91d55";
        const Leaderboard = {
            token: null,
            async init() {
                const stored = localStorage.getItem("ritual_id");
                let payload = { game_version: "1.0", development_mode: true };
                if(stored) payload.guest_player_id = stored;
                try {
                    const r = await fetch("https://api.lootlocker.io/game/v2/session/guest", {
                        method: "POST",
                        headers: { "Content-Type": "application/json", "x-session-token": API_KEY },
                        body: JSON.stringify(payload)
                    });
                    const d = await r.json();
                    if(d.session_token) {
                        this.token = d.session_token;
                        localStorage.setItem("ritual_id", d.player_id);
                        this.fetchTop();
                    } else {
                        document.getElementById('leaderboardList').innerHTML = "OFFLINE";
                    }
                } catch(e) {
                    document.getElementById('leaderboardList').innerHTML = "OFFLINE";
                }
            },
            async fetchTop() {
                if(!this.token) return;
                try {
                    const r = await fetch(`https://api.lootlocker.io/game/v1/leaderboards/${LEADERBOARD_ID}/list?count=5`, {
                        headers: { "x-session-token": this.token }
                    });
                    const d = await r.json();
                    const list = document.getElementById('leaderboardList');
                    if(d.items && d.items.length > 0) {
                        list.innerHTML = d.items.map((i, idx) => `
                            <div class="leaderboard-row ${idx===0?'rank-1':''}">
                                <span>#${i.rank} ${i.player.id ? i.player.id.toString().substring(0,6) : "MAGE"}...</span>
                                <span>${i.score}</span>
                            </div>
                        `).join('');
                    } else {
                        list.innerHTML = "NO RITUALS YET";
                    }
                } catch(e) {}
            },
            async submit(score) {
                if(!this.token) return;
                const status = document.getElementById('uploadStatus');
                status.innerText = "UPLOADING...";
                try {
                    await fetch(`https://api.lootlocker.io/game/v1/leaderboards/${LEADERBOARD_ID}/submit`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json", "x-session-token": this.token },
                        body: JSON.stringify({ score: score })
                    });
                    status.innerText = "UPLOAD COMPLETE";
                    this.fetchTop();
                } catch(e) {
                    status.innerText = "UPLOAD FAILED";
                }
            }
        };

        const GameState = {
            START: 'start',
            LOADING: 'loading',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAME_OVER: 'gameover',
            SETTINGS: 'settings'
        };

        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        const optimizedShadow = {
            apply(ctx, blur, color) {
                if (isMobile) {
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = 'transparent';
                } else {
                    ctx.shadowBlur = blur;
                    ctx.shadowColor = color;
                }
            },
            clear(ctx) {
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }
        };

        const GlitchFX = {
            active: false, duration: 0, intensity: 1, type: 'rgb',
            rgbSplit(ctx, intensity) {
                const offset = Math.floor(Math.random() * 3 * intensity);
                const rOffset = Math.random() > 0.5 ? offset : -offset;
                const gOffset = Math.random() > 0.5 ? offset : -offset;
                const bOffset = Math.random() > 0.5 ? offset : -offset;
                if (Math.random() > 0.3) return null;
                return {
                    rOffset, gOffset, bOffset,
                    draw: function(ctx, width, height) {
                        const imageData = ctx.getImageData(0, 0, width, height);
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = width; tempCanvas.height = height;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.putImageData(imageData, 0, 0);
                        ctx.save();
                        ctx.globalCompositeOperation = 'screen';
                        ctx.globalAlpha = 0.8; ctx.drawImage(tempCanvas, rOffset, 0);
                        ctx.globalAlpha = 0.8; ctx.drawImage(tempCanvas, 0, gOffset);
                        ctx.globalAlpha = 0.8;
                        ctx.drawImage(tempCanvas, bOffset, bOffset);
                        ctx.restore();
                    }
                };
            },
            apply(ctx, currentTime) {
                if (!this.active || this.duration <= 0) return;
                const progress = this.duration / 100;
                this.intensity = Math.min(1, progress * 2);
                if (Math.random() > 0.8) {
                    const rgbEffect = this.rgbSplit(ctx, this.intensity);
                    if (rgbEffect) rgbEffect.draw(ctx, ctx.canvas.width, ctx.canvas.height);
                }
                this.duration -= 16;
                if (this.duration <= 0) { this.active = false; this.intensity = 1; }
            },
            trigger(duration = 100, type = 'all') {
                this.active = true;
                this.duration = duration; this.type = type; this.intensity = 1;
            }
        };

        const SFX = {
            audioContext: null,
            init() { if (!this.audioContext) this.audioContext = new (window.AudioContext || window.webkitAudioContext)(); },
            playTone(freq, type, duration, vol, detune = 0) {
                if (!game?.settings?.sfx) return;
                if (!this.audioContext) this.init();
                if (this.audioContext.state === 'suspended') this.audioContext.resume();
                try {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    osc.type = type;
                    osc.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                    osc.detune.setValueAtTime(detune, this.audioContext.currentTime);
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    gain.gain.setValueAtTime(vol, this.audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                    osc.start();
                    osc.stop(this.audioContext.currentTime + duration);
                } catch(e){}
            },
            jump() { this.playTone(400, 'square', 0.08, 0.1); this.playTone(600, 'sine', 0.05, 0.05, 100); },
            collect() { this.playTone(800, 'sine', 0.2, 0.1); this.playTone(1200, 'triangle', 0.1, 0.05, 50); },
            crash() { this.playTone(100, 'sawtooth', 0.5, 0.3); this.playTone(80, 'square', 0.3, 0.2, -100); },
            voidEnter() { this.playTone(200, 'sawtooth', 0.5, 0.2, -50); this.playTone(800, 'sine', 1.0, 0.1, 50); }, 
            levelUp() { 
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.5);
                osc.connect(gain); gain.connect(this.audioContext.destination);
                gain.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                osc.start(); osc.stop(this.audioContext.currentTime + 0.5);
            }
        };

        const Haptics = {
            // Enhanced Haptic Patterns
            jump() { if (game?.settings?.vibration && navigator.vibrate) navigator.vibrate([20]); },
            collect() { if (game?.settings?.vibration && navigator.vibrate) navigator.vibrate([30, 30, 30]); },
            crash() { if (game?.settings?.vibration && navigator.vibrate) navigator.vibrate([200, 50, 100, 50, 50]); },
            levelUp() { if (game?.settings?.vibration && navigator.vibrate) navigator.vibrate([100, 30, 100, 30, 100]); },
            start() { if (game?.settings?.vibration && navigator.vibrate) navigator.vibrate([50, 50, 50]); }
        };

        const AudioSys = {
            bgm: null, localBlobUrl: null, currentMode: 'none', retryCount: 0, playlistQueue: [],
            setStatus(msg) {
                const el = document.getElementById('audioStatus');
                if (el) { el.textContent = msg; el.style.color = '#fff'; setTimeout(() => el.style.color = 'var(--primary)', 200); }
            },
            init() { this.setupAudioElement(CONFIG.MENU_MUSIC); this.currentMode = 'menu'; this.setStatus("MENU AUDIO RDY"); },
            setupAudioElement(src) {
                if (this.bgm) { this.bgm.pause(); this.bgm.src = ""; this.bgm.onended = null; }
                this.bgm = new Audio();
                this.bgm.src = src; this.bgm.volume = 0.8; this.bgm.preload = "auto";
                this.bgm.onwaiting = () => this.setStatus("BUFFERING...");
                this.bgm.onplaying = () => { this.setStatus("PLAYING"); this.retryCount = 0; };
                this.bgm.onerror = (e) => { console.warn("Audio error:", e); this.setStatus("LOAD ERROR"); };
            },
            shuffleQueue() {
                 this.playlistQueue = [...CONFIG.GAME_PLAYLIST];
                 for (let i = this.playlistQueue.length - 1; i > 0; i--) {
                     const j = Math.floor(Math.random() * (i + 1));
                     [this.playlistQueue[i], this.playlistQueue[j]] = [this.playlistQueue[j], this.playlistQueue[i]];
                 }
            },
            switchToGameMusic() {
                if (this.localBlobUrl) return;
                this.currentMode = 'game';
                if (this.playlistQueue.length === 0) this.shuffleQueue();
                const track = this.playlistQueue.pop(); 
                this.setStatus("LOADING NEXT TRACK");
                this.setupAudioElement(track);
                this.bgm.loop = false;
                this.bgm.onended = () => { if(this.currentMode === 'game') this.switchToGameMusic(); };
                this.play();
            },
            switchToGameOverMusic() {
                if (this.localBlobUrl) return;
                this.currentMode = 'gameover';
                const randomIndex = Math.floor(Math.random() * CONFIG.GAMEOVER_PLAYLIST.length);
                const track = CONFIG.GAMEOVER_PLAYLIST[randomIndex];
                this.setStatus("RITUAL ENDED");
                this.setupAudioElement(track);
                this.bgm.loop = true;
                this.play();
            },
            switchToMenuMusic() {
                if (this.localBlobUrl) return;
                this.currentMode = 'menu'; this.setStatus("LOADING MENU");
                this.setupAudioElement(CONFIG.MENU_MUSIC);
                this.bgm.loop = true;
            },
            play() { if (!this.bgm) return; const p = this.bgm.play(); if (p !== undefined) p.catch(e => { console.warn(e); this.setStatus("AUTOPLAY BLOCK"); }); },
            pause() { if (this.bgm) { this.bgm.pause(); this.setStatus("PAUSED"); } },
            resume() { if (this.bgm && this.bgm.paused) { this.bgm.play(); this.setStatus("RESUMED"); } },
            stop() { if (this.bgm) { this.bgm.pause(); this.bgm.currentTime = 0; this.setStatus("STOPPED"); } }
        };

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.root = document.documentElement;
                this.state = GameState.START;
                this.currentLevelIdx = 0;
                this.frames = 0;
                this.score = 0;
                this.highScore = localStorage.getItem('93protocol_highscore') || 0;
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED;
                this.shake = 0;
                this.lastFrameTime = 0;
                this.fps = 0;
                this.isMobile = isMobile;
                this.scaleFactor = 1;
                this.baseWidth = 800;
                this.baseHeight = 450;
                this.glitchEffect = false;
                this.glitchTimer = 0;
                this.tunnelOffset = 0;
                this.hitStop = 0;
                this.screenFlash = null;
                this.voidMode = false;
                this.voidTimer = 0;
                this.preVoidSpeed = 0;
                
                this.gameMode = 'HEX'; // 'HEX' or 'MONAS'

                this.backgroundParticles = [];
                this.player = null;
                this.particles = [];
                this.stars = []; // For standard stars
                this.warpStars = []; // For Monas warp stars
                this.obstacles = [];
                this.collectibles = [];
                this.pentagrams = [];
                this.gameLevels = []; 
                this.settings = { music: true, sfx: true, vibration: true };
                
                this.loadSettings();
                this.initEventListeners();
                this.resizeCanvas();
                this.preloadAllImages();
                this.createBackgroundParticles();
                
                AudioSys.init();
                SFX.init();
            }
            
            createBackgroundParticles() {
                this.backgroundParticles = [];
                for (let i = 0; i < 25; i++) { 
                    this.backgroundParticles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        z: Math.random() * 2 + 0.5,
                        size: Math.random() * 3 + 2,
                        speed: Math.random() * 0.5 + 0.1,
                        color: palette[Math.floor(Math.random() * palette.length)],
                        opacity: Math.random() * 0.4 + 0.1,
                        shape: Math.floor(Math.random() * 3) 
                    });
                }
            }
            
            triggerOrbGlitch() {
                GlitchFX.trigger(80, 'orb');
                this.screenFlash = { active: true, duration: 10, color: '#ffd700', intensity: 0.3 };
            }
            
            triggerLevelUpGlitch() {
                GlitchFX.trigger(150, 'level');
                this.screenFlash = {
                    active: true, duration: 20,
                    color: this.gameLevels[this.currentLevelIdx]?.accent || '#ff003c', intensity: 0.4
                };
            }
            
            triggerDeathGlitch() {
                GlitchFX.trigger(200, 'death');
                this.screenFlash = { active: true, duration: 30, color: '#ff003c', intensity: 0.6 };
            }
            
            applyScreenFlash() {
                if (!this.screenFlash || !this.screenFlash.active) return;
                this.ctx.save();
                this.ctx.fillStyle = this.screenFlash.color;
                this.ctx.globalAlpha = this.screenFlash.intensity * (this.screenFlash.duration / 30);
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.restore();
                this.screenFlash.duration--;
                if (this.screenFlash.duration <= 0) { this.screenFlash.active = false; }
            }
            
            initEventListeners() {
                window.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && this.state === GameState.PLAYING) this.playerJump();
                    else if (e.code === 'Escape') this.togglePause();
                });
                window.addEventListener('mousedown', (e) => {
                    if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'LABEL' && this.state === GameState.PLAYING) this.playerJump();
                });
                window.addEventListener('touchstart', (e) => {
                    if (this.state === GameState.PLAYING) {
                        e.preventDefault();
                        const touchY = e.touches[0].clientY;
                        if (touchY > window.innerHeight * 0.6) { this.playerJump(); }
                    }
                }, { passive: false });

                document.getElementById('startHexBtn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.gameMode = 'HEX';
                    if (this.settings.music) AudioSys.switchToGameMusic();
                    this.startGame();
                });
                document.getElementById('startMonasBtn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.gameMode = 'MONAS';
                    if (this.settings.music) AudioSys.switchToGameMusic();
                    this.startGame();
                });

                document.getElementById('restartBtn').addEventListener('click', (e) => {
                     e.stopPropagation();
                     if (this.settings.music) AudioSys.switchToGameMusic();
                     this.restartGame();
                });
                document.getElementById('voidBtn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.returnToMenu();
                });
                document.getElementById('pauseBtn').addEventListener('click', (e) => { e.stopPropagation(); this.togglePause(); });
                document.getElementById('resumeBtn').addEventListener('click', (e) => { e.stopPropagation(); this.togglePause(); });
                document.getElementById('menuBtn').addEventListener('click', (e) => { e.stopPropagation(); this.returnToMenu(); });
                document.getElementById('settingsBtn').addEventListener('click', (e) => { e.stopPropagation(); this.showSettings(); });
                document.getElementById('backBtn').addEventListener('click', (e) => { e.stopPropagation(); this.hideSettings(); });
                
                document.getElementById('musicToggle').addEventListener('change', (e) => {
                    this.settings.music = e.target.checked;
                    this.saveSettings();
                    if (!this.settings.music) AudioSys.stop();
                    else if (this.state === GameState.PLAYING) AudioSys.play();
                });
                document.getElementById('sfxToggle').addEventListener('change', (e) => {
                    this.settings.sfx = e.target.checked; this.saveSettings();
                });
                document.getElementById('vibrationToggle').addEventListener('change', (e) => {
                    this.settings.vibration = e.target.checked; this.saveSettings();
                });
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            loadSettings() {
                const saved = localStorage.getItem('93protocol_settings');
                if (saved) this.settings = { ...this.settings, ...JSON.parse(saved) };
                document.getElementById('musicToggle').checked = this.settings.music;
                document.getElementById('sfxToggle').checked = this.settings.sfx;
                document.getElementById('vibrationToggle').checked = this.settings.vibration;
            }
            
            saveSettings() { localStorage.setItem('93protocol_settings', JSON.stringify(this.settings)); }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.calculateScaleFactor();
                this.adjustForScreenSize();
            }
            
            calculateScaleFactor() {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const targetRatio = 16/9;
                if (width/height > targetRatio) { this.scaleFactor = height / this.baseHeight; } else { this.scaleFactor = width / this.baseWidth; }
                this.scaleFactor = Math.max(0.6, Math.min(this.scaleFactor, 1.5));
            }
            
            adjustForScreenSize() {
                const screenHeight = this.canvas.height;
                const screenWidth = this.canvas.width;
                let baseGap = CONFIG.PILLAR_GAP;
                
                // --- PORTRAIT MODE FIX ---
                // If height > width (Portrait), give more gap to compensate for low reaction time
                if (screenHeight > screenWidth) {
                    baseGap = Math.max(250, baseGap * 1.3); 
                } else if (screenHeight < 600) { 
                    baseGap = Math.min(270, baseGap * 1.08); 
                } else if (screenHeight > 800) { 
                    baseGap = Math.max(240, baseGap * 0.95); 
                }
                this.currentBaseGap = baseGap;
            }
            
            preloadAllImages() {
                const progressFill = document.getElementById('progressFill');
                const loadingText = document.getElementById('loadingText');
                let loadedCount = 0;
                const failsafe = setTimeout(() => { if (loadedCount < MASTER_POOL.length) { this.finishLoading(); } }, 5000);
                MASTER_POOL.forEach(lvl => {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.onload = () => {
                        lvl.img = img;
                        lvl.loaded = true;
                        loadedCount++;
                        const percent = Math.floor((loadedCount / MASTER_POOL.length) * 100);
                        progressFill.style.width = `${percent}%`;
                        loadingText.innerText = `CHARGING SIGIL... ${loadedCount}/${MASTER_POOL.length}`;
                        if (loadedCount >= MASTER_POOL.length) { clearTimeout(failsafe); this.finishLoading(); }
                    };
                    img.onerror = () => {
                        loadedCount++;
                        if (loadedCount >= MASTER_POOL.length) { clearTimeout(failsafe); this.finishLoading(); }
                    };
                    img.src = CONFIG.BASE_URL + lvl.id + CONFIG.IMG_SUFFIX;
                });
            }
            
            finishLoading() {
                Leaderboard.init();
                setTimeout(() => {
                    document.getElementById('loadingMsg').classList.add('hidden');
                    document.getElementById('menuButtons').classList.remove('hidden');
                }, 500);
            }
            
            prepareLevels() {
                let shuffled = [...MASTER_POOL];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                this.gameLevels = shuffled.map((lvl, index) => {
                    return { ...lvl, threshold: index * 5 };
                });
            }

            startGame() {
                this.prepareLevels();
                this.state = GameState.PLAYING;
                document.getElementById('startScreen').classList.add('hidden');
                document.getElementById('scoreUi').classList.remove('hidden');
                document.getElementById('pauseBtn').classList.remove('hidden');
                document.getElementById('instructions').classList.remove('hidden');
                
                if (this.isMobile) {
                    document.getElementById('mobileControls').classList.remove('hidden');
                    setTimeout(() => { document.getElementById('mobileControls').classList.add('hidden'); }, 5000);
                }
                
                if (CONFIG.DEBUG) document.getElementById('statsPanel').classList.remove('hidden');
                this.initGame();
                Haptics.start();
                this.gameLoop();
            }
            
            initGame() {
                this.player = new Player(this.gameMode);
                this.obstacles = [];
                this.collectibles = [];
                this.pentagrams = [];
                this.particles = [];
                
                // Initialize background based on mode
                this.stars = [];
                this.warpStars = [];
                
                if (this.gameMode === 'MONAS') {
                    for (let i = 0; i < 50; i++) this.warpStars.push(new WarpStar());
                } else {
                    for (let i = 0; i < 40; i++) this.stars.push(new Star());
                }

                this.score = 0;
                this.currentLevelIdx = 0;
                this.frames = 0;
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED;
                this.shake = 0;
                this.tunnelOffset = 0;
                this.hitStop = 0;
                this.voidMode = false;
                this.voidTimer = 0;
                document.getElementById('scoreUi').innerText = "0";
                document.getElementById('game-container').classList.remove('void-active');
                this.applyLevel();
            }
            
            applyLevel() {
                if (this.currentLevelIdx >= this.gameLevels.length) return;
                const l = this.gameLevels[this.currentLevelIdx];
                document.getElementById('levelUi').innerText = l.name;
                document.getElementById('levelUi').style.color = l.accent;
                document.getElementById('levelUi').style.textShadow = `0 0 15px ${l.accent}`;
                this.root.style.setProperty('--primary', l.accent);
                let newSpeed = CONFIG.INITIAL_GAME_SPEED + (this.currentLevelIdx * CONFIG.SPEED_INCREASE_PER_LEVEL);
                this.gameSpeed = Math.min(newSpeed, CONFIG.MAX_GAME_SPEED);
                if (this.currentLevelIdx > 0) {
                    this.triggerGlitchEffect();
                    Haptics.levelUp();
                    if (this.settings.sfx) SFX.levelUp();
                }
            }
            
            startVoidMode() {
                this.voidMode = true;
                this.voidTimer = CONFIG.VOID_DURATION;
                this.preVoidSpeed = this.gameSpeed;
                this.gameSpeed = this.gameSpeed * 1.8; 
                this.obstacles = [];
                this.collectibles = [];
                this.screenFlash = { active: true, duration: 20, color: '#00ffff', intensity: 0.5 };
                document.getElementById('game-container').classList.add('void-active');
                document.getElementById('levelUi').innerText = "THE VOID";
                document.getElementById('levelUi').style.color = "#00ffff";
                if (this.settings.sfx) SFX.voidEnter();
            }
            
            endVoidMode() {
                this.voidMode = false;
                this.gameSpeed = this.preVoidSpeed;
                document.getElementById('game-container').classList.remove('void-active');
                this.applyLevel(); 
            }

            triggerGlitchEffect() { this.glitchEffect = true; this.glitchTimer = 300; }
            
            applyGlitchEffect() {
                if (!this.glitchEffect) return;
                const ctx = this.ctx;
                const intensity = this.glitchTimer / 300;
                if (Math.random() > 0.7) {
                    const shiftX = Math.floor(Math.random() * 10 * intensity) - 5;
                    const shiftY = Math.floor(Math.random() * 10 * intensity) - 5;
                    ctx.save();
                    ctx.translate(shiftX, shiftY);
                    ctx.restore();
                }
                if (Math.random() > 0.8) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fillRect(0, Math.floor(Math.random() * this.canvas.height), this.canvas.width, 1);
                }
                this.glitchTimer -= 16;
                if (this.glitchTimer <= 0) { this.glitchEffect = false; }
            }
            
            getCurrentGap() {
                const baseGap = this.currentBaseGap || CONFIG.PILLAR_GAP;
                const levelsCompleted = Math.floor(this.currentLevelIdx / 5);
                const gapReduction = levelsCompleted * CONFIG.PILLAR_GAP_DECREASE_PER_5_LEVELS;
                const calculatedGap = Math.max(CONFIG.MIN_PILLAR_GAP, baseGap - gapReduction);
                return calculatedGap + (Math.sin(this.frames * 0.05) * 10);
            }
            
            checkLevel() {
                const nextIdx = this.currentLevelIdx + 1;
                if (nextIdx >= this.gameLevels.length) return;
                const next = this.gameLevels[nextIdx];
                if (this.score >= next.threshold) {
                    this.currentLevelIdx++;
                    if (this.currentLevelIdx % CONFIG.VOID_INTERVAL === 0) {
                        this.startVoidMode();
                    } else {
                        this.applyLevel();
                        this.shake = 12;
                        this.hitStop = 3;
                        this.triggerLevelUpGlitch();
                        for (let i = 0; i < 30; i++) {
                            this.particles.push(new Particle(
                                this.canvas.width / 2, this.canvas.height / 2, 
                                this.gameLevels[this.currentLevelIdx].accent, 12,
                                Math.random() > 0.5 ? 'hexagram' : 'triangle'
                            ));
                        }
                        if (this.settings.sfx) SFX.levelUp();
                        Haptics.levelUp();
                    }
                }
            }
            
            playerJump() {
                if (this.state === GameState.PLAYING) {
                    this.player.jump();
                    Haptics.jump();
                    GlitchFX.trigger(50, 'rgb');
                }
            }
            
            togglePause() {
                if (this.state === GameState.PLAYING) {
                    this.state = GameState.PAUSED;
                    document.getElementById('pauseScreen').classList.remove('hidden');
                    AudioSys.pause();
                } else if (this.state === GameState.PAUSED) {
                    this.state = GameState.PLAYING;
                    document.getElementById('pauseScreen').classList.add('hidden');
                    AudioSys.resume();
                    this.gameLoop();
                }
            }
            
            showSettings() {
                document.getElementById('startScreen').classList.add('hidden');
                document.getElementById('settingsScreen').classList.remove('hidden');
                this.state = GameState.SETTINGS;
            }
            
            hideSettings() {
                document.getElementById('settingsScreen').classList.add('hidden');
                document.getElementById('startScreen').classList.remove('hidden');
                this.state = GameState.START;
            }
            
            returnToMenu() {
                this.state = GameState.START;
                document.getElementById('pauseScreen').classList.add('hidden');
                document.getElementById('gameOverScreen').classList.add('hidden');
                document.getElementById('startScreen').classList.remove('hidden');
                document.getElementById('scoreUi').classList.add('hidden');
                document.getElementById('pauseBtn').classList.add('hidden');
                document.getElementById('instructions').classList.add('hidden');
                document.getElementById('statsPanel').classList.add('hidden');
                document.getElementById('mobileControls').classList.add('hidden');
                document.getElementById('game-container').classList.remove('void-active');
                if (this.settings.music) AudioSys.switchToMenuMusic();
            }
            
            gameOver() {
                if (this.state === GameState.GAME_OVER || this.voidMode) return;
                this.state = GameState.GAME_OVER;
                this.shake = 15;
                this.triggerDeathGlitch();
                if (this.settings.sfx) SFX.crash();
                Haptics.crash();
                for (let i = 0; i < 25; i++) {
                    this.particles.push(new Particle(
                        this.player.x, this.player.y, '#ff003c', 10,
                        Math.random() > 0.3 ? 'hexagram' : 'triangle'
                    ));
                }
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('93protocol_highscore', this.highScore);
                    document.getElementById('highScoreMsg').textContent = "NEW GNOSIS ATTAINED";
                } else {
                    document.getElementById('highScoreMsg').textContent = `BEST: ${this.highScore}`;
                }
                Leaderboard.submit(this.score);
                if (this.settings.music) AudioSys.switchToGameOverMusic(); else AudioSys.stop();
                document.getElementById('finalScore').innerText = this.score;
                document.getElementById('scoreUi').classList.add('hidden');
                document.getElementById('pauseBtn').classList.add('hidden');
                document.getElementById('instructions').classList.add('hidden');
                document.getElementById('statsPanel').classList.add('hidden');
                document.getElementById('mobileControls').classList.add('hidden');
                document.getElementById('gameOverScreen').classList.remove('hidden');
            }
            
            restartGame() {
                this.state = GameState.PLAYING;
                this.prepareLevels();
                document.getElementById('gameOverScreen').classList.add('hidden');
                document.getElementById('scoreUi').classList.remove('hidden');
                document.getElementById('pauseBtn').classList.remove('hidden');
                document.getElementById('instructions').classList.remove('hidden');
                if (this.isMobile) {
                    document.getElementById('mobileControls').classList.remove('hidden');
                    setTimeout(() => { document.getElementById('mobileControls').classList.add('hidden'); }, 5000);
                }
                if (CONFIG.DEBUG) document.getElementById('statsPanel').classList.remove('hidden');
                this.initGame();
                this.gameLoop();
            }
            
            gameLoop(currentTime = 0) {
                if (this.state !== GameState.PLAYING) return;
                if (this.lastFrameTime) {
                    this.fps = Math.round(1000 / (currentTime - this.lastFrameTime));
                    if (CONFIG.DEBUG) document.getElementById('fpsCounter').textContent = this.fps;
                }
                this.lastFrameTime = currentTime;
                if (this.hitStop > 0) {
                    this.hitStop--;
                    this.drawScene(currentTime);
                    requestAnimationFrame((time) => this.gameLoop(time));
                    return;
                }

                this.frames++;
                if (this.frames % 30 === 0 && Math.random() > 0.8) { GlitchFX.trigger(10, 'random'); }
                if (this.voidMode) {
                    this.voidTimer--;
                    if (this.voidTimer <= 0) { this.endVoidMode(); }
                }
                
                this.tunnelOffset += this.tunnelSpeed * (1 + this.gameSpeed * 0.1) || 10;
                this.updateGameObjects();
                this.drawScene(currentTime);
                requestAnimationFrame((time) => this.gameLoop(time));
            }

            drawScene(currentTime) {
                const lvl = this.gameLevels[this.currentLevelIdx];
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                const tunnelColor = this.voidMode ? '#00ffff' : lvl.accent;
                this.drawHyperspaceTunnel(tunnelColor);

                // --- BACKGROUND LOGIC SPLIT BASED ON MODE ---
                if (this.gameMode === 'MONAS') {
                    // 3D Expanding Stars for MONAS mode
                    const cx = this.canvas.width / 2;
                    const cy = this.canvas.height / 2;
                    // SLOW EXPANSION UPDATE
                    this.warpStars.forEach(s => {
                        // If in Void mode, speed up; otherwise, use 0.3x multiplier for slow floaty effect
                        const warpSpeed = this.voidMode ? this.gameSpeed : (this.gameSpeed * 0.3);
                        s.update(warpSpeed, this.voidMode);
                        s.draw(this.ctx, cx, cy, tunnelColor);
                    });
                } else {
                    // Standard Scrolling Stars for HEX mode
                    this.drawBackgroundParticles(tunnelColor);
                    // Draw Standard Stars
                    this.stars.forEach(s => {
                         s.update();
                         s.draw(this.ctx);
                    });
                }
                
                GlitchFX.apply(this.ctx, currentTime);
                this.applyScreenFlash();
                if (this.glitchEffect) this.applyGlitchEffect();
                
                this.ctx.save();
                if (this.shake > 0) {
                    this.ctx.translate((Math.random() - 0.5) * this.shake, (Math.random() - 0.5) * this.shake);
                    this.shake *= 0.9;
                }
                this.drawGameObjects();
                this.ctx.restore();
            }
            
            drawHyperspaceTunnel(color) {
                const ctx = this.ctx;
                const cx = this.canvas.width / 2;
                const cy = this.canvas.height / 2;
                const maxRadius = Math.max(this.canvas.width, this.canvas.height) * 0.8;
                const breath = (Math.sin(Date.now() * 0.002 * (1 + this.gameSpeed * 0.1)) + 1) * 0.5;
                
                ctx.strokeStyle = color;
                ctx.lineWidth = 1.5;
                optimizedShadow.apply(ctx, 15, color);
                const baseRotation = this.frames * 0.005;
                for (let i = 0; i < 8; i++) {
                    const progress = ((this.tunnelOffset + i * 60) % 300) / 300;
                    const radius = progress * maxRadius;
                    if (radius < 50) continue;
                    ctx.globalAlpha = (1 - progress * 0.8) * (0.8 + breath * 0.2);
                    ctx.save();
                    ctx.translate(cx, cy);
                    ctx.rotate(baseRotation + (i * 0.1)); 
                    ctx.beginPath();
                    for(let k = 0; k < 5; k++) {
                        const angle = (k * 4 * Math.PI / 5) - (Math.PI / 2);
                        const px = Math.cos(angle) * radius;
                        const py = Math.sin(angle) * radius;
                        if(k===0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                }
                optimizedShadow.clear(ctx);
                ctx.globalAlpha = 1;
                
                // Render Background Image (Common)
                const lvl = this.gameLevels[this.currentLevelIdx];
                if (!this.voidMode && lvl.loaded && lvl.img && lvl.img.complete) {
                    ctx.globalAlpha = 0.6;
                    try {
                        const img = lvl.img;
                        const canvasRatio = this.canvas.width / this.canvas.height;
                        const imgRatio = img.width / img.height;
                        let drawWidth, drawHeight, drawX, drawY;
                        if (canvasRatio > imgRatio) {
                            drawHeight = this.canvas.height;
                            drawWidth = img.width * (drawHeight / img.height);
                            drawX = (this.canvas.width - drawWidth) / 2;
                            drawY = 0;
                        } else {
                            drawWidth = this.canvas.width;
                            drawHeight = img.height * (drawWidth / img.width);
                            drawX = 0;
                            drawY = (this.canvas.height - drawHeight) / 2;
                        }
                        ctx.filter = 'blur(1px)';
                        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                        ctx.filter = 'none';
                    } catch (e) {}
                    ctx.globalAlpha = 1.0;
                }
            }

            drawBackgroundParticles(tunnelColor) {
                // Used for HEX mode
                 this.backgroundParticles.forEach(p => {
                    p.y += p.speed * (1 + this.gameSpeed * 0.1);
                    if (p.y > this.canvas.height) { 
                        p.y = 0; 
                        p.x = Math.random() * this.canvas.width;
                        p.shape = Math.floor(Math.random() * 3);
                    }
                    this.ctx.fillStyle = p.color;
                    this.ctx.globalAlpha = p.opacity;
                    this.ctx.save();
                    this.ctx.translate(p.x, p.y);
                    this.ctx.rotate(this.frames * 0.02);
                    if (p.shape === 0) { 
                        this.ctx.beginPath(); this.ctx.moveTo(0, -p.size); this.ctx.lineTo(p.size, p.size); this.ctx.lineTo(-p.size, p.size); this.ctx.fill();
                    } else if (p.shape === 1) { 
                        this.ctx.beginPath(); this.ctx.moveTo(0, -p.size); this.ctx.lineTo(p.size, 0); this.ctx.lineTo(0, p.size); this.ctx.lineTo(-p.size, 0); this.ctx.fill();
                    } else { 
                        this.ctx.fillRect(-p.size/2, -p.size*1.5, p.size, p.size*3);
                        this.ctx.fillRect(-p.size*1.5, -p.size/2, p.size*3, p.size);
                    }
                    this.ctx.restore();
                });
                this.ctx.globalAlpha = 1;
            }
            
            updateGameObjects() {
                const currentGap = this.getCurrentGap();
                const spawnRate = Math.floor(CONFIG.PILLAR_SPAWN_BASE / (this.gameSpeed / 3)); 
                
                if (!this.voidMode && this.frames % Math.max(20, spawnRate) === 0) {
                    const p = new Pillar(this.currentLevelIdx, currentGap);
                    this.obstacles.push(p);
                    if (Math.random() > (1 - CONFIG.ORB_SPAWN_CHANCE)) {
                        this.collectibles.push(new Orb(p.x + p.w / 2, p.top + p.gap / 2));
                    }
                }
                
                if (this.voidMode && this.frames % 10 === 0) {
                     const y = Math.random() * (this.canvas.height - 100) + 50;
                     this.pentagrams.push(new Pentagram(window.innerWidth, y));
                }
                
                this.obstacles.forEach((o, i) => {
                    o.update(this.gameSpeed);
                    const hitboxReduction = CONFIG.HITBOX_OFFSET;
                    const pLeft = this.player.x - this.player.r + hitboxReduction;
                    const pRight = this.player.x + this.player.r - hitboxReduction;
                    const pTop = this.player.y - this.player.r + hitboxReduction;
                    const pBottom = this.player.y + this.player.r - hitboxReduction;
                    
                    if (o.collides(pLeft, pRight, pTop, pBottom)) { this.gameOver(); }
                    
                    if (!o.marked && o.x + o.w < this.player.x) {
                        this.score++;
                        o.marked = true;
                        document.getElementById('scoreUi').innerText = this.score;
                        this.checkLevel();
                    }
                    if (o.x < -100) this.obstacles.splice(i, 1);
                });
                
                this.collectibles.forEach((c, i) => {
                    c.update(this.gameSpeed);
                    const dist = Math.hypot(this.player.x - c.x, this.player.y - c.y);
                    if (dist < this.player.r + c.r && !c.collected) {
                        this.score += 5;
                        document.getElementById('scoreUi').innerText = this.score;
                        c.collected = true;
                        this.triggerOrbGlitch();
                        this.hitStop = 3;
                        for (let k = 0; k < 20; k++) {
                            this.particles.push(new Particle(c.x, c.y, '#ffd700', 8));
                        }
                        if (this.settings.sfx) SFX.collect();
                        Haptics.collect();
                        this.collectibles.splice(i, 1);
                        this.checkLevel();
                    }
                    if (c.x < -50) this.collectibles.splice(i, 1);
                });

                this.pentagrams.forEach((p, i) => {
                    p.update(this.gameSpeed);
                    const dist = Math.hypot(this.player.x - p.x, this.player.y - p.y);
                    if (dist < this.player.r + p.size && !p.collected) {
                        this.score += 10;
                        document.getElementById('scoreUi').innerText = this.score;
                        p.collected = true;
                        for (let k = 0; k < 10; k++) {
                            this.particles.push(new Particle(p.x, p.y, '#00ffff', 12, 'hexagram'));
                        }
                        if (this.settings.sfx) SFX.collect();
                        this.pentagrams.splice(i, 1);
                    }
                    if (p.x < -50) this.pentagrams.splice(i, 1);
                });
                
                this.player.update();
                
                this.particles.forEach((p, i) => {
                    p.update();
                    if (p.life <= 0) this.particles.splice(i, 1);
                });
            }
            
            drawGameObjects() {
                const currentLvlConfig = this.gameLevels[this.currentLevelIdx];
                this.obstacles.forEach(o => o.draw(this.ctx, currentLvlConfig));
                this.collectibles.forEach(c => c.draw(this.ctx));
                this.pentagrams.forEach(p => p.draw(this.ctx));
                this.player.draw(this.ctx, currentLvlConfig);
                this.particles.forEach(p => p.draw(this.ctx));
            }
        }

        class Player {
            constructor(mode) {
                this.mode = mode; // 'HEX' or 'MONAS'
                this.x = window.innerWidth * 0.25;
                this.y = window.innerHeight / 2;
                this.vy = 0;
                this.r = CONFIG.PLAYER_RADIUS;
                this.rot = 0;
                this.trail = [];
                // Monas gets longer, smoother trail
                this.trailLength = (mode === 'MONAS') ? 20 : 12; 
                this.jumpCooldown = 0;
                this.scaleX = 1;
                this.scaleY = 1;
            }
            
            update() {
                // --- SPLIT PHYSICS FOR MODES ---
                if (this.mode === 'MONAS') {
                    // FLOANTY PHYSICS (Low Gravity, High Drag)
                    // This creates a "gliding" feel where you hang in the air
                    this.vy += 0.25; // Lower gravity than HEX (0.45)
                    // Add subtle air resistance
                    this.vy *= 0.98;
                } else {
                    // SNAPPY HEX PHYSICS (Standard Flappy Style)
                    this.vy += CONFIG.GRAVITY; // 0.45
                }
                
                if (this.vy > CONFIG.MAX_FALL_SPEED) this.vy = CONFIG.MAX_FALL_SPEED;
                
                this.y += this.vy;
                this.rot += 0.03;
                
                const stretch = Math.min(Math.abs(this.vy) * 0.04, 0.3);
                if (this.vy < 0) { this.scaleY = 1 + stretch; this.scaleX = 1 - stretch * 0.5; } 
                else { this.scaleY = 1 - stretch * 0.5; this.scaleX = 1 + stretch; }

                if (this.y > window.innerHeight - this.r * 1.5) { game.gameOver(); }
                if (this.y < this.r * 1.5) { this.y = this.r * 1.5; this.vy = 0; }
                
                if (this.jumpCooldown > 0) { this.jumpCooldown--; }
                
                // Trail update
                if (game.frames % 1 === 0) { 
                    this.trail.unshift({
                        x: this.x, y: this.y, r: this.r, life: 1.0,
                        rot: this.rot, scaleX: this.scaleX, scaleY: this.scaleY
                    });
                    if (this.trail.length > this.trailLength) this.trail.pop();
                }
                
                // MONAS gets slow decay, HEX gets fast decay
                const decay = (this.mode === 'MONAS') ? 0.02 : 0.08;
                this.trail.forEach(t => t.life -= decay);
            }
            
            draw(ctx, conf) {
                const hue = (game.frames * 2) % 360;
                const strokeColor = `hsl(${hue}, 100%, 60%)`;
                const shadowColor = `hsl(${hue}, 100%, 50%)`;

                // --- DRAW TRAIL ---
                this.trail.forEach((t, i) => {
                    if (t.life > 0) {
                        ctx.save();
                        // Increased opacity for neon look
                        ctx.globalAlpha = t.life * 0.6;
                        ctx.translate(t.x, t.y);
                        ctx.scale(t.scaleX, t.scaleY);
                        ctx.rotate(t.rot + (this.vy * 0.05));
                        
                        // Apply specific look based on mode
                        if (this.mode === 'MONAS') {
                            // Gold/Blue neon for Monas
                            optimizedShadow.apply(ctx, 20 * t.life, '#ffd700');
                            ctx.strokeStyle = '#ffd700';
                            ctx.lineWidth = 2;
                            this.drawMonasShape(ctx, t.r * 1.4 * t.life); // Larger scale
                        } else {
                            // Red/Pink neon for Hex
                            optimizedShadow.apply(ctx, 20 * t.life, '#ff003c');
                            ctx.strokeStyle = '#ff003c';
                            ctx.lineWidth = 1 + t.life;
                            this.drawHexShape(ctx, t.r * 0.8 * t.life);
                        }
                        
                        ctx.restore();
                    }
                });

                ctx.globalAlpha = 1.0;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.scaleX, this.scaleY);
                ctx.rotate(this.rot + (this.vy * 0.05));
                
                const r = this.r * 1.2;
                optimizedShadow.apply(ctx, 25, shadowColor);
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 3;
                
                // --- DRAW MAIN AVATAR ---
                if (this.mode === 'MONAS') {
                    // Scale up Monas by 1.5x for visibility
                    this.drawMonasShape(ctx, r * 1.5);
                } else {
                    this.drawHexShape(ctx, r);
                }

                if (game.isMobile) {
                    ctx.save();
                    ctx.strokeStyle = shadowColor;
                    ctx.lineWidth = 8;
                    ctx.globalAlpha = 0.3;
                    ctx.stroke();
                    ctx.restore();
                }

                const pulse = Math.sin(game.frames * 0.1) * 0.5 + 1;
                ctx.fillStyle = "#fff";
                optimizedShadow.apply(ctx, 40 * pulse, "#fff");
                ctx.beginPath();
                ctx.arc(0, 0, 3 * pulse, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
            
            // --- UNICURSAL HEXAGRAM SHAPE ---
            drawHexShape(ctx, r) {
                // Unicursal hexagram points
                const points = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (i * 60 - 90) * Math.PI / 180;
                    points.push({ x: Math.cos(angle) * r, y: Math.sin(angle) * r });
                }
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                ctx.lineTo(points[2].x, points[2].y);
                ctx.lineTo(points[5].x, points[5].y);
                ctx.lineTo(points[3].x, points[3].y);
                ctx.lineTo(points[1].x, points[1].y);
                ctx.lineTo(points[4].x, points[4].y);
                ctx.lineTo(points[0].x, points[0].y);
                ctx.closePath();
                ctx.stroke();
            }

            // --- MONAS HIEROGLYPHICA SHAPE ---
            drawMonasShape(ctx, r) {
                const s = r * 0.8; 
                ctx.beginPath();
                // 1. The Crescent (Top)
                ctx.arc(0, -s, s * 0.4, 0, Math.PI, false);
                // 2. The Sun (Circle)
                ctx.moveTo(s*0.4, -s*0.4);
                ctx.arc(0, -s*0.4, s*0.4, 0, Math.PI * 2);
                // 3. The Center Point
                ctx.moveTo(1, -s*0.4);
                ctx.arc(0, -s*0.4, 1, 0, Math.PI * 2);
                // 4. The Cross
                ctx.moveTo(0, 0); // Bottom of circle
                ctx.lineTo(0, s); // Down stem
                ctx.moveTo(-s*0.6, s*0.4); // Cross bar left
                ctx.lineTo(s*0.6, s*0.4); // Cross bar right
                // 5. The Aries (Bottom)
                ctx.moveTo(-s*0.4, s); 
                ctx.bezierCurveTo(-s*0.6, s, -s*0.6, s*0.8, -s*0.4, s*0.8); // Left hook
                ctx.lineTo(s*0.4, s*0.8);
                ctx.bezierCurveTo(s*0.6, s*0.8, s*0.6, s, s*0.4, s); // Right hook
                
                ctx.stroke();
            }

            jump() {
                if (this.jumpCooldown > 0) return;
                
                // --- SPLIT JUMP PHYSICS FOR MODES ---
                if (this.mode === 'MONAS') {
                    // Gentle impulse for floaty mode
                    this.vy = -6.0; 
                } else {
                    // Snappy jump for Hex mode
                    this.vy = CONFIG.PLAYER_JUMP_FORCE; // -7.5
                }
                
                this.jumpCooldown = game.isMobile ? 8 : 5;
                if (Math.random() > 0.7) GlitchFX.trigger(40, 'jump');
                
                for (let i = 0; i < (game.isMobile ? 10 : 12); i++) {
                    const type = Math.random() > 0.7 ? 'hexagram' : Math.random() > 0.4 ? 'triangle' : 'circle';
                    game.particles.push(new Particle(this.x, this.y, '#fff', 3, type));
                }
                if (game.settings.sfx) SFX.jump();
                Haptics.jump();
                GlitchFX.trigger(50, 'rgb');
            }
        }

        class Pillar {
            constructor(lvlIndex, currentGap) {
                this.x = window.innerWidth;
                this.w = CONFIG.PILLAR_WIDTH;
                this.gap = currentGap;
                const maxTop = window.innerHeight - this.gap - 50;
                const minTop = 30;
                this.top = Math.random() * (maxTop - minTop) + minTop;
                this.baseTop = this.top; 
                this.marked = false;
                this.lvl = lvlIndex;
                this.rotation = Math.random() * Math.PI * 2;
                this.innerPattern = Math.floor(Math.random() * 3);
                this.pulse = 0;
                this.hasWarning = game.isMobile && Math.random() > 0.5;
                this.warningAlpha = 1;
            }
            
            update(speed) { 
                this.x -= speed;
                this.pulse += 0.05;
                this.rotation += 0.005;
                if (this.hasWarning) { this.warningAlpha -= 0.01; }
                const breathe = Math.sin(game.frames * 0.05) * 5;
                this.top = this.baseTop + breathe;
            }
            
            collides(pLeft, pRight, pTop, pBottom) {
                 const pillarLeft = this.x;
                 const pillarRight = this.x + this.w;
                 const topPillarBottom = this.top;
                 const topPillarTop = 0;
                 const bottomPillarTop = this.top + this.gap;
                 const bottomPillarBottom = window.innerHeight;
                 
                 const horizontalOverlap = pRight > pillarLeft && pLeft < pillarRight;
                 const hittingTopPillar = horizontalOverlap && pBottom > topPillarTop && pTop < topPillarBottom;
                 const hittingBottomPillar = horizontalOverlap && pTop < bottomPillarBottom && pBottom > bottomPillarTop;
                 
                 return hittingTopPillar || hittingBottomPillar;
            }
            
            draw(ctx, conf) {
                const hue = (game.frames * 0.5 + this.x * 0.1) % 360;
                const mainColor = `hsl(${hue}, 100%, 60%)`;
                const innerColor = `hsl(${(hue + 60) % 360}, 100%, 70%)`;
                const glowColor = `hsl(${hue}, 100%, 50%)`;
                
                if (this.hasWarning && this.x < window.innerWidth * 0.7 && this.warningAlpha > 0) {
                    ctx.save();
                    ctx.globalAlpha = this.warningAlpha * 0.3;
                    ctx.fillStyle = '#ff003c';
                    ctx.fillRect(this.x - 10, 0, this.w + 20, window.innerHeight);
                    ctx.restore();
                }
                
                ctx.save();
                ctx.translate(this.x + this.w/2, 0);
                
                optimizedShadow.apply(ctx, 30, glowColor);
                ctx.strokeStyle = mainColor;
                ctx.lineWidth = 4;
                ctx.fillStyle = "rgba(0,0,0,0.7)";
                const topHeight = this.top + 10;
                ctx.beginPath();
                ctx.moveTo(-this.w/2, -10);
                ctx.lineTo(this.w/2, -10);
                
                const jagCount = 5;
                for (let i = 0; i <= jagCount; i++) {
                    const x = this.w/2 - (i * this.w/jagCount);
                    const y = -10 + (i % 2 === 0 ? 8 : -4);
                    ctx.lineTo(x, y);
                }
                
                ctx.lineTo(-this.w/2, topHeight);
                ctx.lineTo(-this.w/2, -10);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.save();
                ctx.translate(0, topHeight/2);
                ctx.rotate(this.rotation);
                ctx.globalAlpha = 0.4;
                ctx.strokeStyle = innerColor;
                ctx.lineWidth = 1.5;
                this.drawPattern(ctx, Math.min(this.w, topHeight) * 0.3);
                ctx.restore();

                const botY = this.top + this.gap;
                const botHeight = window.innerHeight - botY + 10;
                ctx.beginPath();
                ctx.moveTo(-this.w/2, botY);
                ctx.lineTo(this.w/2, botY);
                for (let i = 0; i <= jagCount; i++) {
                    const x = this.w/2 - (i * this.w/jagCount);
                    const y = botY + (i % 2 === 0 ? -4 : 8);
                    ctx.lineTo(x, y);
                }
                
                ctx.lineTo(this.w/2, botY + botHeight);
                ctx.lineTo(-this.w/2, botY + botHeight);
                ctx.lineTo(-this.w/2, botY);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.save();
                ctx.translate(0, botY + botHeight/2);
                ctx.rotate(-this.rotation);
                ctx.globalAlpha = 0.4;
                ctx.strokeStyle = innerColor;
                ctx.lineWidth = 1.5;
                this.drawPattern(ctx, Math.min(this.w, botHeight) * 0.3);
                ctx.restore();
                
                ctx.restore();
                optimizedShadow.clear(ctx);
                ctx.globalAlpha = 1.0;
            }

            drawPattern(ctx, size) {
                if (this.innerPattern === 0) {
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = Math.cos(angle) * size;
                        const y = Math.sin(angle) * size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                } else if (this.innerPattern === 1) {
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size * 0.866, size * 0.5);
                    ctx.lineTo(-size * 0.866, size * 0.5);
                    ctx.closePath();
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.moveTo(-size, 0);
                    ctx.lineTo(size, 0);
                    ctx.moveTo(0, -size);
                    ctx.lineTo(0, size);
                    ctx.stroke();
                }
            }
        }

        class Orb {
            constructor(x, y) {
                this.x = x;
                this.y = y; 
                this.r = 9;
                this.collected = false;
                this.float = Math.random() * Math.PI * 2;
                this.pulse = 0;
                this.rotation = 0;
            }
            
            update(speed) {
                this.x -= speed;
                this.float += 0.1;
                this.pulse += 0.15;
                this.rotation += 0.02;
                this.y += Math.sin(this.float) * 0.8;
            }
            
            draw(ctx) {
                if (this.collected) return;
                const pulseSize = this.r + Math.sin(this.pulse) * 3;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                optimizedShadow.apply(ctx, 25, '#ffd700');
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
                ctx.stroke();
                
                optimizedShadow.apply(ctx, 30, '#fff');
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.9;
                const r = pulseSize * 0.7;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i * 60) * Math.PI / 180;
                    const x = Math.cos(angle) * r;
                    const y = Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
        }

        class Pentagram {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 20;
                this.collected = false;
                this.rotation = 0;
                this.hue = Math.random() * 360;
            }
            update(speed) {
                this.x -= speed;
                this.rotation += 0.1;
                this.hue += 10;
            }
            draw(ctx) {
                if (this.collected) return;
                const color = `hsl(${this.hue}, 100%, 70%)`;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                optimizedShadow.apply(ctx, 20, color);
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                for(let k = 0; k < 5; k++) {
                    const angle = (k * 4 * Math.PI / 5) - (Math.PI / 2);
                    const px = Math.cos(angle) * this.size;
                    const py = Math.sin(angle) * this.size;
                    if(k===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.stroke();
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
        }

        class Particle {
            constructor(x, y, c, speed, type = 'circle') {
                this.x = x;
                this.y = y; 
                this.c = c;
                this.vx = (Math.random() - 0.5) * speed;
                this.vy = (Math.random() - 0.5) * speed;
                this.life = 1; 
                this.size = Math.random() * 3 + 2;
                this.type = type;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.2;
                this.glow = Math.random() > 0.5;
            }
            
            update() { 
                this.x += this.vx;
                this.y += this.vy; 
                this.vx *= 0.97;
                this.vy *= 0.97;
                this.life -= 0.03; 
                this.rotation += this.rotationSpeed;
                this.size *= 0.98;
                if (game.isMobile) { this.life -= 0.01; }
            }
            
            draw(ctx) {
                if (this.life <= 0) return;
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.c;
                if (this.glow && this.life > 0.3) {
                    optimizedShadow.apply(ctx, 20 * this.life, this.c);
                }
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                if (this.type === 'hexagram') {
                    const r = this.size * 0.8;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 'triangle') {
                    const r = this.size;
                    ctx.beginPath();
                    ctx.moveTo(0, -r);
                    ctx.lineTo(r * 0.866, r * 0.5);
                    ctx.lineTo(-r * 0.866, r * 0.5);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
        }
        
        // --- STAR CLASSES FOR DIFFERENT MODES ---
        class Star {
            constructor() {
                this.x = Math.random() * window.innerWidth;
                this.y = Math.random() * window.innerHeight;
                this.size = Math.random() * 2;
                this.speed = Math.random() * 0.5 + 0.1;
                this.alpha = Math.random() * 0.5 + 0.2;
                this.twinkle = Math.random() * Math.PI * 2;
            }
            update() {
                this.y += this.speed;
                if (this.y > window.innerHeight) {
                    this.y = 0;
                    this.x = Math.random() * window.innerWidth;
                }
                this.twinkle += 0.05;
                this.alpha = 0.3 + Math.sin(this.twinkle) * 0.2;
            }
            draw(ctx) {
                const conf = game.gameLevels[game.currentLevelIdx];
                ctx.fillStyle = conf ? conf.accent : '#fff';
                ctx.globalAlpha = this.alpha;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1.0;
            }
        }

        class WarpStar {
            constructor() { this.reset(); }
            reset() {
                this.x = (Math.random() - 0.5) * window.innerWidth;
                this.y = (Math.random() - 0.5) * window.innerHeight;
                this.z = Math.random() * window.innerWidth;
                this.pz = this.z;
            }
            update(speed, isVoid) {
                const speedFactor = isVoid ? 25 : 10;
                this.z -= speed * speedFactor * 0.1;
                if (this.z < 1) {
                    this.reset();
                    this.z = window.innerWidth;
                    this.pz = this.z;
                }
            }
            draw(ctx, cx, cy, color) {
                const sx = (this.x / this.z) * 100 + cx;
                const sy = (this.y / this.z) * 100 + cy;
                const alpha = (window.innerWidth - this.z) / window.innerWidth;
                ctx.fillStyle = color;
                ctx.globalAlpha = alpha;
                const size = (1 - this.z / window.innerWidth) * 3;
                ctx.fillRect(sx, sy, size, size);
                ctx.globalAlpha = 1.0;
            }
        }

        let game;
        document.addEventListener('DOMContentLoaded', () => {
            game = new Game();
        });
    </script>
</body>
</html>
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* CRT Scanline Effect */
        .scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
            opacity: 0.4;
        }
        
        /* Vignette for ominous feel */
        .vignette {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, black 130%);
            pointer-events: none;
            z-index: 11;
        }

        /* UI Overlay */
        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 20;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            transition: opacity 0.3s ease;
            padding: 20px;
            box-sizing: border-box;
        }

        /* Start Screen Specifics */
        #startScreen {
            background-size: cover;
            background-position: center;
            transition: background-image 1s ease-in-out;
            /* Psychedelic Background Animation */
            animation: bgBreath 10s infinite alternate;
        }
        
        /* Dark overlay to make text pop on top of image */
        #startScreen::before {
            content: '';
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: -1;
        }

        @keyframes bgBreath {
            0% { transform: scale(1); filter: hue-rotate(0deg); }
            100% { transform: scale(1.05); filter: hue-rotate(45deg); }
        }

        .hidden {
            opacity: 0 !important;
            pointer-events: none !important;
            display: none !important;
        }

        /* Neon Buttons */
        .mystic-btn {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--primary);
            color: #fff;
            padding: 15px 50px;
            font-size: 1.2rem;
            font-family: 'Cinzel Decorative', cursive;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 4px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 15px var(--primary), inset 0 0 10px var(--primary);
            margin: 10px;
            min-width: 260px;
            position: relative;
            overflow: hidden;
            text-shadow: 0 0 5px #fff;
            animation: psychedelicBorder 4s infinite linear;
        }

        @keyframes psychedelicBorder {
            0% { border-color: #ff003c; box-shadow: 0 0 15px #ff003c; }
            25% { border-color: #ff00ff; box-shadow: 0 0 15px #ff00ff; }
            50% { border-color: #00ffff; box-shadow: 0 0 15px #00ffff; }
            75% { border-color: #ffd700; box-shadow: 0 0 15px #ffd700; }
            100% { border-color: #ff003c; box-shadow: 0 0 15px #ff003c; }
        }

        .mystic-btn:hover {
            background: #fff;
            color: #000;
            transform: scale(1.05);
            text-shadow: none;
        }

        .mystic-btn:active {
            transform: scale(0.95);
        }

        .title-text {
            font-family: 'Cinzel Decorative', cursive;
            font-size: 5rem;
            color: #fff;
            text-shadow: 0 0 10px var(--primary);
            margin-bottom: 10px;
            letter-spacing: -2px;
            animation: pulseNeon 3s infinite alternate;
        }

        @keyframes pulseNeon {
            0% { text-shadow: 0 0 10px var(--primary), 0 0 20px var(--primary); opacity: 1; }
            100% { text-shadow: 0 0 20px var(--primary), 0 0 40px var(--primary), 0 0 80px var(--primary); opacity: 0.9; }
        }

        /* NEW: Floating Animation for UI */
        @keyframes gentleFloat {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }

        .level-indicator {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            font-size: 1.5rem;
            font-family: 'Cinzel Decorative', serif;
            font-weight: 700;
            letter-spacing: 6px;
            color: #fff;
            z-index: 15;
            text-shadow: 0 0 10px #000;
            text-transform: uppercase;
            animation: gentleFloat 4s ease-in-out infinite; 
        }

        .score-display {
            position: absolute;
            top: 10%;
            width: 100%;
            text-align: center;
            font-size: 9rem;
            font-family: 'Cinzel Decorative', serif;
            color: rgba(255, 255, 255, 0.1);
            z-index: 5;
            pointer-events: none;
            mix-blend-mode: screen;
            font-weight: 900;
            animation: gentleFloat 6s ease-in-out infinite reverse;
        }

        .progress-bar {
            width: 300px;
            height: 4px;
            background: #222;
            margin: 20px 0;
            position: relative;
            box-shadow: 0 0 10px #000;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width 0.2s ease;
            box-shadow: 0 0 15px var(--primary);
        }

        .instructions {
            position: absolute;
            bottom: 100px;
            width: 100%;
            text-align: center;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 3px;
            z-index: 15;
            font-family: 'Orbitron', sans-serif;
            animation: fadeOut 5s ease-in-out forwards;
            animation-delay: 2s; 
            pointer-events: none;
        }

        @keyframes fadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; visibility: hidden; }
        }

        .pause-btn {
            position: absolute;
            top: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--primary);
            color: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            z-index: 25;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            pointer-events: auto;
            box-shadow: 0 0 10px var(--primary);
            transition: 0.3s;
        }
        
        .pause-btn:hover {
            background: var(--primary);
            color: #000;
            box-shadow: 0 0 20px var(--primary);
        }

        .stats-panel {
            position: absolute;
            top: 30px;
            left: 30px;
            background: rgba(0, 0, 0, 0.7);
            border-left: 3px solid var(--primary);
            padding: 10px 15px;
            font-size: 0.8rem;
            color: #ccc;
            z-index: 25;
            pointer-events: auto;
            font-family: 'Orbitron', monospace;
            text-align: left;
            backdrop-filter: blur(4px);
        }
        
        /* Custom File Upload Styling */
        .file-upload-label {
            display: inline-block;
            margin-top: 20px;
            padding: 10px 20px;
            border: 1px dashed #666;
            color: #888;
            cursor: pointer;
            font-size: 0.8rem;
            transition: 0.3s;
            font-family: 'Orbitron', sans-serif;
        }
        .file-upload-label:hover {
            border-color: var(--primary);
            color: var(--primary);
            box-shadow: 0 0 10px rgba(255, 0, 60, 0.2);
        }

        /* Mobile Controls */
        .mobile-controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 30;
        }

        .mobile-jump-area {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40%;
            pointer-events: auto;
            background: transparent;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .mobile-jump-indicator {
            background: rgba(255, 0, 60, 0.3);
            border: 2px solid rgba(255, 0, 60, 0.7);
            border-radius: 50%;
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 0.8rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            backdrop-filter: blur(5px);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.1); opacity: 0.9; }
            100% { transform: scale(1); opacity: 0.7; }
        }

        /* Responsive Styles */
        @media (max-width: 768px) {
            .title-text { font-size: 3.5rem !important; margin-bottom: 20px; }
            .score-display { font-size: 6rem !important; top: 8% !important; }
            .level-indicator { font-size: 1.2rem !important; bottom: 70px !important; letter-spacing: 4px !important; }
            .mystic-btn { padding: 12px 30px !important; font-size: 1rem !important; min-width: 220px !important; margin: 8px !important; }
            .instructions { bottom: 130px !important; font-size: 0.7rem !important; letter-spacing: 2px !important; }
            .stats-panel { top: 15px !important; left: 15px !important; font-size: 0.7rem !important; padding: 8px 12px !important; }
            .pause-btn { top: 15px !important; right: 15px !important; width: 45px !important; height: 45px !important; font-size: 1.2rem !important; }
            .progress-bar { width: 250px !important; }
            #gameOverScreen .title-text { font-size: 3rem !important; }
            #pauseScreen .title-text { font-size: 2.5rem !important; }
            #settingsScreen .title-text { font-size: 2rem !important; }
        }

        @media (max-width: 480px) {
            .title-text { font-size: 2.8rem !important; }
            .score-display { font-size: 5rem !important; top: 6% !important; }
            .level-indicator { font-size: 1rem !important; bottom: 60px !important; }
            .mystic-btn { min-width: 200px !important; padding: 10px 25px !important; font-size: 0.9rem !important; letter-spacing: 2px !important; }
            .instructions { font-size: 0.65rem !important; letter-spacing: 1.5px !important; bottom: 140px !important; }
            .progress-bar { width: 200px !important; }
        }

        @media (orientation: portrait) and (max-height: 700px) {
            .title-text { font-size: 2.5rem !important; }
            .score-display { font-size: 4.5rem !important; }
            .level-indicator { bottom: 50px !important; }
            .instructions { bottom: 100px !important; }
        }

        @media (orientation: landscape) {
            .title-text { font-size: 3rem !important; }
            .score-display { font-size: 4rem !important; top: 5% !important; }
            .level-indicator { bottom: 20px !important; font-size: 1rem !important; }
            .mystic-btn { padding: 8px 20px !important; margin: 5px !important; min-width: 180px !important; }
            .instructions { bottom: 70px !important; font-size: 0.6rem !important; }
            .mobile-jump-area { height: 50%; }
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .title-text { font-size: 2.2rem !important; }
            .score-display { font-size: 3rem !important; }
            .mystic-btn { padding: 6px 15px !important; font-size: 0.8rem !important; min-width: 150px !important; }
        }

        /* Safe area padding */
        @supports (padding: max(0px)) {
            .ui-layer {
                padding-left: max(20px, env(safe-area-inset-left));
                padding-right: max(20px, env(safe-area-inset-right));
                padding-top: max(20px, env(safe-area-inset-top));
                padding-bottom: max(20px, env(safe-area-inset-bottom));
            }
        }

        .loader {
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid var(--primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="scanlines"></div>
        <div class="vignette"></div>
        
        <div id="scoreUi" class="score-display">0</div>
        <div id="levelUi" class="level-indicator">INITIATION</div>
        
        <div id="mobileControls" class="mobile-controls hidden">
            <div class="mobile-jump-area">
                <div class="mobile-jump-indicator">TAP</div>
            </div>
        </div>
        
        <div id="startScreen" class="ui-layer" style="background-image: url('https://lh3.googleusercontent.com/d/1BXrXXd9TKSqCFNwvS-cJpNORbyvP6fkR=s0');">
            <h1 class="title-text">Sex Magick</h1>
            <p style="letter-spacing: 8px; color: #ff003c; margin-bottom: 40px; font-size: 1.1rem; text-shadow: 0 0 10px #ff003c; font-family: 'Cinzel Decorative', cursive;">Do Your Will Foo</p>
            
            <div id="loadingMsg">
                <div class="loader"></div>
                <p id="loadingText" style="letter-spacing: 4px; font-size: 0.9rem; margin-top: 15px; font-family: 'Cinzel Decorative';">CHARGING SIGIL...</p>
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill"></div>
                </div>
            </div>

            <div id="menuButtons" class="hidden">
                <button id="startBtn" class="mystic-btn">INVOKE</button>
                <button id="settingsBtn" class="mystic-btn">RITES</button>
            </div>
        </div>

        <div id="gameOverScreen" class="ui-layer hidden" style="background: rgba(0,0,0,0.85);">
            <h1 class="title-text" style="color: #ff003c; font-size: 4rem;">Good job foo</h1>
            <p style="font-size: 1.2rem; letter-spacing: 4px; margin-bottom: 20px; font-family: 'Cinzel Decorative';">RITUAL FAILED</p>
            <p class="text-xl mb-6 text-gray-300">WILL: <span id="finalScore" style="color: #fff; font-weight:bold; text-shadow: 0 0 10px #fff;">0</span></p>
            <p id="highScoreMsg" style="color: #ffd700; margin-bottom: 30px; font-size: 1rem; letter-spacing: 2px;"></p>
            <button id="restartBtn" class="mystic-btn">REINCARNATE</button>
            <button id="goMenuBtn" class="mystic-btn" style="margin-top: 10px; font-size: 1rem; border-color: #ffd700;">RETURN TO VOID</button>
        </div>

        <div id="pauseScreen" class="ui-layer hidden">
            <h1 class="title-text" style="font-size: 3.5rem; color: #ffd700;">MEDITATION</h1>
            <button id="resumeBtn" class="mystic-btn">RESUME</button>
            <button id="menuBtn" class="mystic-btn">ABORT</button>
        </div>

        <div id="settingsScreen" class="ui-layer hidden" style="background: rgba(0,0,0,0.9);">
            <h1 class="title-text" style="font-size: 2.5rem;">SACRED RITES</h1>
            <div style="width: 320px; margin: 20px 0; background: rgba(20,20,20,0.8); padding: 20px; border: 1px solid var(--primary);">
                <div style="display: flex; justify-content: space-between; margin: 15px 0; border-bottom: 1px solid #444; padding-bottom: 10px;">
                    <span>CHANT (MUSIC)</span>
                    <input type="checkbox" id="musicToggle" checked style="accent-color: var(--primary);">
                </div>
                <div style="display: flex; justify-content: space-between; margin: 15px 0; border-bottom: 1px solid #444; padding-bottom: 10px;">
                    <span>RESONANCE (SFX)</span>
                    <input type="checkbox" id="sfxToggle" checked style="accent-color: var(--primary);">
                </div>
                <div style="display: flex; justify-content: space-between; margin: 15px 0;">
                    <span>KUNDALINI (VIBE)</span>
                    <input type="checkbox" id="vibrationToggle" checked style="accent-color: var(--primary);">
                </div>
            </div>
            <button id="backBtn" class="mystic-btn">RETURN</button>
        </div>

        <button id="pauseBtn" class="pause-btn hidden">||</button>
        
        <div id="statsPanel" class="stats-panel">
            <div style="color: var(--primary); font-weight: bold; margin-bottom: 5px;">:: GNOSIS ::</div>
            FPS: <span id="fpsCounter" style="color: #fff;">0</span><br>
            AUDIO: <span id="audioStatus" style="color: #fff;">STANDBY</span>
        </div>

        <div id="instructions" class="instructions hidden">
            [ TAP / SPACE TO ASCEND ]
        </div>
    </div>

    <script>
        const CDN_PREFIX = "https://cdn.jsdelivr.net/gh/bookthief666/93-protocol-game-assets-@8c1973f1dada601ef830fa99ebfbbb67906b10cd/";

        const CONFIG = {
            DEBUG: true, 
            MENU_MUSIC: CDN_PREFIX + "iamerror%20-%20The%20Zelda%20Song%20(Hyr00l).mp3",
            GAME_PLAYLIST: [
                CDN_PREFIX + "bookthief%F0%9F%A5%80%20-%20booothief-%20All%20gay%F0%9F%98%87%202024-07-10%2001_11%20(1).m4a",
                CDN_PREFIX + "bookthief%20x%20inv.s.b.l.ty-%20Liquid%20Sovereignty.flac",
                CDN_PREFIX + "bookthief%F0%9F%A5%80%20-%20How%20Much%20Does%20One%20Pay%202024-07-31%2018_24.m4a",
                CDN_PREFIX + "iamerror%20-%20Hyr00l%20Rough.mp4",
                CDN_PREFIX + "eyedea%20_%201950s%20void%20the%C3%B4ry%20.mp3",
                CDN_PREFIX + "forget%20me%20remix%2093.flac",
                CDN_PREFIX + "iamerror%20-%20The%20Zelda%20Song%20(Hyr00l).mp3",
                CDN_PREFIX + "Vae!%20Puto%20Deus%20Fio!%20(3).mp3",
                CDN_PREFIX + "MONOLITH%20bounce%201.mp3",
                CDN_PREFIX + "Forest%20of%20Fellatio%20%5BTTn3kjGwXi0%5D.mp3",
                CDN_PREFIX + "IAMERROR%20-%20The%20Iceclops%20Cometh.mp3",
                CDN_PREFIX + "Post%20Mvdern%20-%20Pleiades%2018MAR25.flac"
            ],
            GAMEOVER_PLAYLIST: [
                CDN_PREFIX + "LEX_LFL_80_wurli_loop_ate_bit_Cm.wav",
                CDN_PREFIX + "Post%20Mvdern%20-%20Pleiades%2018MAR25.flac"
            ],
            BASE_URL: "https://lh3.googleusercontent.com/d/",
            IMG_SUFFIX: "=s0",
            
            // SLOWER START SETTINGS:
            INITIAL_GAME_SPEED: 2.5, // Reduced start speed
            SPEED_INCREASE_PER_LEVEL: 0.15, // Reduced acceleration
            PILLAR_SPAWN_RATE: 120,
            PILLAR_WIDTH: 45,
            PILLAR_GAP: 250, 
            PILLAR_GAP_DECREASE_PER_5_LEVELS: 8, 
            MIN_PILLAR_GAP: 180, 
            ORB_SPAWN_CHANCE: 0.5,
            PLAYER_JUMP_FORCE: -6.5,
            GRAVITY: 0.20,
            
            PLAYER_RADIUS: 16, 
            HITBOX_OFFSET: 4, 
            MOBILE_CONTROL_DEADZONE: 50,
        };
        const originalLevels = [
            { name: "MALKUTH", id: "1jI7bl3hsVOuzYf6u35L4bhHq5JUiBDa1" },
            { name: "YESOD", id: "1tHgxNvDO5md4z24hS81eTa9uva25mtr5" },
            { name: "HOD", id: "1Mtp6cP6lwGbPRhLWjQKKDijrLX53K4UR" },
            { name: "NETZACH", id: "1y1i5lxL1jVp37bIz1mtJh4-Puce-E5k0" },
            { name: "TIPHARETH", id: "12png0vOPyJC1Ab4Vffcw2R_K-yRw1sqj" },
            { name: "GEBURAH", id: "1le2Hox1ORxhL28fv7WujO0410vM6jUEJ" },
            { name: "CHESED", id: "1Gsq1xSx9ivfVEq6W2nCMrO-dOIMrSYrW" },
            { name: "DA'ATH", id: "1o601hrLi5RpuGL_kiVEoPXxXk2SCbM2z" },
            { name: "BINAH", id: "1iSYJfPsaYjA1rmRTsujLcn1Do-lBydF7" },
            { name: "CHOKMAH", id: "1PvOC62nv5HdsE1cuCF8RENY9Z8HTabn7" },
            { name: "KETHER", id: "1Ym_eyrXJEQUBA7Lg_2oUc6dQ-gy9yfGs" }
        ];
        const newImageIDs = [
            "1pJ5CUGyKXgkSgEREkKos1Kch5FmfUyxE", "1spT4HpO_4q9joE4x6bLjZQRlFTS9j-ie", "1YGzyjcjiCoPCLbYjJEiqT8USUhe4S6hM", "1ELjoJU7KDC88nUk_Vs57OKUG9oLl5E8N",
            "1faa2c3QFWhZ8UgvyZ_ZrlnyFsnsKRclm", "10W5oYkoqB9LC3YjvB_aozR0kG3hWaHka", "1l9Jdm0EQh8sgWh1W0wsXQCzrQM19Bfm9", "1BrHTF2dvfbRkyYfXAbPUiujwE1AJskY4",
            "1KqV8IYF7KDbmgHS3ph6eRQKl4uAAFG_u", "1sZ02UH_vb1xLaOvyETqptc5FuvOtVKd4", "1hLKOGYXCBemcIKt8OLEX4dHTn6bd88cr", "1g_DQeG6qldMBxHzZ82MOVoxk9APwb4NO",
            "1-SIvE5EZyUd7FKXJ7eyB4JCrtOpQoF18", "1S4y4YSCjxSb-b_U1BfMw_0PhabJ-METm", "1OL-kWl-TJNcZFPcsCAtynW2NWp-YYjGd", "1ApPgou40N2Q6GlNKNuyoQ2Gk5DqAfmw_",
            "1OeH1GMu2rDcwzdtWFZSB1WWe0OjkmxV0", "12Z92v9Mu9yNOnDTtK-bjMRZ8_2BAW2eW", "1Erf3DKxZpfbG57oGcUCjuHIhajsweLZz", "1qK22CJhJ1XgElL156uOQxYrucaRG16p0",
            "1euwdAWg-xQw7isR-JAiZ-krXQXOS8pi0", "1A3hT3mJibINtsr8CVxTmp71QsYgPB2JZ", "1QUVr-RK2kP7IIAuy0wX3pOZRQuyr-o-e", "1eF02YMyYBcgx7Ga20pXgoltzWXPYznfD",
            "1zx1vrrbuSA4xCFKXAHgXbkG1rX8PUPel", "1ds1iqXf90gy9PUFs80t4QOxamkJj0u1I", "14-t6dPPv5MeXe7LWPIp7Tjc8x4w5Vj2d", "1pUtIizMzVhjzB46dhah5mgz6Tr-vaSLO",
            "1ZOEkUW8q2s5zerS7BubYJU69RHk7_Zlo", "15ZHj0fLYu-4rEQy43BMJKDgXnnQ5FeyP", "1ZzgVT0O6XQzW3DUP4i1aoKd_DD5wV5LZ", "1rZHZM0bR_j6uiYZLS82J0BkbIfEUoXvY",
            "1CNrQ_EeMXQgHJGXxe7EHysQi_A0A9UE7", "1ubCqIg7ETOIsHGfBjQfVsRzjlZIpBP6E", "1pojzjR-uiQ0oTHRJxXXCW_w0hlJUCqyb", "1SnclBlH6sflhaTWzFhbcNedzNeh25-BV",
            "1thfc-9DnM4GhCi0zTbcX4MH-yaQEpomX", "1BXrXXd9TKSqCFNwvS-cJpNORbyvP6fkR", "1D1bOksatIt6Jw6Zq8Sbmhbq_GC_2EQHh", "1eP_Xnk80YnL3w3Q69wQmVo9_F0OaA3Wo",
            "1ARDOipcr0lB1GYf3gmhqlHXlpC23Q2JE", "1io39jfggXQl-OyvSFGIpgOtoIzHbml3M", "1o0rJmx3vEKITMx1ixP5iruOX2ujOT6VO", "1Irw61utgSGdip21OgTcYqz56LpWWS9fb",
            "19V2ObVoQn9R9bt1ZgMNEBJokaAjYdX_9", "1WWvLnkkPBN7Q0ZsGi16FL1anhPlti3Qd", "1HoYqC0SLc3nrSDnoW9KJ2-z8AnRWIz5M", "1oS0J3F-zh5H48-Qs5Mrm10dPR993kF-b",
            "1bRwsBEuZiAIZW_5f3WOZVI6-KVnCEslk", "1GLza2_RmR4c_KD_KGxbXPOoCAw9SITKl", "1uWFSChozQmHEnuJwXqiPNApXuAwPAzKS", "1t2hNBEudzIo19kuP8ksPY_cNetDdTd8P",
            "1KhMBL7a3NSggVerbyy53fQ-dLq11adwj", "1wgxalTR68YM7oIku8JYZYKtG50atEnG_", "1BceMgnHgVn9U_7EYnXQu9HDwEQY1UBa_", "14_iwYDQjp34-R_iby8QadKnI9m3zVnOu",
            "1cZ_ci9J80jnqCAdag8SQofYZw1dfsX3C", "15z3bGrCqUy8SQjX1dO5C1vlN3y4-soai", "10xAFw98B39Ou0SSeB4eWyoY2D_OLLPgz", "1CexZQw11p33u1-YA7JhPAkGV6NBCgd6e",
            "16t1EdHfHRpb7GmqNAfo2iKKm57qLfbKn", "12wQOhUztVCVEFV21fPDq-JXGi5zxdkeQ", "1-0u9JUH0oUHD1--5iaySxRpO_PuyxkH6", "1wnITY3i6XxOr1b3l6P0cT10LkEHQauO5"
        ].filter((value, index, self) => self.indexOf(value) === index);
        const esotericNames = [
            "KUNDALINI", "HIEROS GAMOS", "SACRED UNION", "RED TINCTURE", "WHITE GLUTEN", 
            "CUP OF BABALON", "BLOOD OF SAINTS", "CITY OF PYRAMIDS", "NIGHT OF PAN", 
            "HADIT'S FLAME", "NUIT'S EMBRACE", "LAW OF THELEMA", "LOVE UNDER WILL", 
            "GREAT WORK", "STONE OF WISE", "ELIXIR OF LIFE", "RED LION", "WHITE EAGLE",
            "ABRAHADABRA", "LASHTAL", "KA", "BA", "KHU", "SCARLET WOMAN", "THE BEAST",
            "AEON OF HORUS", "93", "AGAPE", "THELEMA", "VIA OVUM", "SPERMATOZOON",
            "HOMUNCULUS", "DIVINE EROS", "TANTRA", "YONI", "LINGAM", "O.T.O.", "A.'.A.'.",
            "STAR SAPPHIRE", "MASS OF PHOENIX", "LIBER AL", "RESH", "SAMEKH", "TZADDI"
        ];
        let MASTER_POOL = [...originalLevels];
        
        const palette = ["#ff003c", "#ff00ff", "#9d00ff", "#00f0ff", "#00ff9d", "#d4ff00", "#ff8800"];
        newImageIDs.forEach((id, index) => {
            const nameIndex = index % esotericNames.length;
            MASTER_POOL.push({
                name: esotericNames[nameIndex],
                id: id,
                color: "#000",
                accent: palette[index % palette.length],
                img: null,
                loaded: false
            });
        });
        const GameState = {
            START: 'start',
            LOADING: 'loading',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAME_OVER: 'gameover',
            SETTINGS: 'settings'
        };
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        const optimizedShadow = {
            apply(ctx, blur, color) {
                if (isMobile) {
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = 'transparent';
                } else {
                    ctx.shadowBlur = blur;
                    ctx.shadowColor = color;
                }
            },
            clear(ctx) {
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }
        };

        const GlitchFX = {
            active: false,
            duration: 0,
            intensity: 1,
            type: 'rgb',
            
            rgbSplit(ctx, intensity) {
                const offset = Math.floor(Math.random() * 3 * intensity);
                const rOffset = Math.random() > 0.5 ? offset : -offset;
                const gOffset = Math.random() > 0.5 ? offset : -offset;
                const bOffset = Math.random() > 0.5 ? offset : -offset;
                if (Math.random() > 0.3) return null;
                return {
                    rOffset, gOffset, bOffset,
                    draw: function(ctx, width, height) {
                        const imageData = ctx.getImageData(0, 0, width, height);
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = width;
                        tempCanvas.height = height;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.putImageData(imageData, 0, 0);
                        
                        ctx.save();
                        ctx.globalCompositeOperation = 'screen';
                        ctx.globalAlpha = 0.8;
                        ctx.drawImage(tempCanvas, rOffset, 0);
                        ctx.globalAlpha = 0.8;
                        ctx.drawImage(tempCanvas, 0, gOffset);
                        ctx.globalAlpha = 0.8;
                        ctx.drawImage(tempCanvas, bOffset, bOffset);
                        ctx.restore();
                    }
                };
            },
            
            staticEffect(ctx, intensity) {
                ctx.save();
                ctx.globalAlpha = 0.1 * intensity;
                for (let i = 0; i < 5; i++) { 
                    const x = Math.random() * ctx.canvas.width;
                    const y = Math.random() * ctx.canvas.height;
                    const size = Math.random() * 10 * intensity + 2;
                    ctx.fillStyle = Math.random() > 0.5 ? '#ff003c' : '#00ffff';
                    ctx.fillRect(x, y, size, 1);
                    if (Math.random() > 0.7) {
                        ctx.fillStyle = Math.random() > 0.5 ? '#ff00ff' : '#00ff9d';
                        ctx.fillRect(x, y + 2, 1, size);
                    }
                }
                ctx.restore();
            },
            
            scanlineDistort(ctx, intensity) {
                if (Math.random() > 0.5) return;
                ctx.save();
                ctx.globalAlpha = 0.05 * intensity;
                ctx.fillStyle = '#fff';
                const lineCount = Math.floor(3 * intensity);
                for (let i = 0; i < lineCount; i++) {
                    const y = Math.floor(Math.random() * ctx.canvas.height);
                    const height = Math.random() * 2 + 1;
                    const wave = Math.sin(Date.now() * 0.01 + i) * 10 * intensity;
                    ctx.fillRect(0, y, ctx.canvas.width, height);
                    ctx.fillRect(wave, y + 5, ctx.canvas.width, 1);
                }
                ctx.restore();
            },
            
            blockDisplace(ctx, intensity) {
                if (Math.random() > 0.7) return;
                ctx.save();
                ctx.globalAlpha = 0.3 * intensity;
                for (let i = 0; i < 2; i++) {
                    const x = Math.random() * ctx.canvas.width;
                    const y = Math.random() * ctx.canvas.height;
                    const width = Math.random() * 50 * intensity + 20;
                    const height = Math.random() * 50 * intensity + 20;
                    const offsetX = (Math.random() - 0.5) * 10 * intensity;
                    const offsetY = (Math.random() - 0.5) * 10 * intensity;
                    ctx.fillStyle = Math.random() > 0.5 ? '#ff003c' : '#00ffff';
                    ctx.fillRect(x + offsetX, y + offsetY, width, height);
                }
                ctx.restore();
            },
            
            apply(ctx, currentTime) {
                if (!this.active || this.duration <= 0) return;
                const progress = this.duration / 100;
                this.intensity = Math.min(1, progress * 2);
                if (Math.random() > 0.5) this.staticEffect(ctx, this.intensity);
                if (Math.random() > 0.6) this.scanlineDistort(ctx, this.intensity);
                if (Math.random() > 0.7) this.blockDisplace(ctx, this.intensity);
                if (Math.random() > 0.8) {
                    const rgbEffect = this.rgbSplit(ctx, this.intensity);
                    if (rgbEffect) rgbEffect.draw(ctx, ctx.canvas.width, ctx.canvas.height);
                }
                this.duration -= 16;
                if (this.duration <= 0) {
                    this.active = false;
                    this.intensity = 1;
                }
            },
            
            trigger(duration = 100, type = 'all') {
                this.active = true;
                this.duration = duration;
                this.type = type;
                this.intensity = 1;
            }
        };

        const SFX = {
            audioContext: null,
            init() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
            },
            playTone(freq, type, duration, vol, detune = 0) {
                if (!game?.settings?.sfx) return;
                if (!this.audioContext) this.init();
                if (this.audioContext.state === 'suspended') this.audioContext.resume();
                
                try {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    
                    osc.type = type;
                    osc.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                    osc.detune.setValueAtTime(detune, this.audioContext.currentTime);
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    gain.gain.setValueAtTime(vol, this.audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                    
                    osc.start();
                    osc.stop(this.audioContext.currentTime + duration);
                } catch(e){}
            },
            jump() { 
                this.playTone(400, 'square', 0.08, 0.1);
                this.playTone(600, 'sine', 0.05, 0.05, 100);
            },
            collect() { 
                this.playTone(800, 'sine', 0.2, 0.1);
                this.playTone(1200, 'triangle', 0.1, 0.05, 50);
            },
            crash() { 
                this.playTone(100, 'sawtooth', 0.5, 0.3);
                this.playTone(80, 'square', 0.3, 0.2, -100);
            },
            levelUp() { 
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.5);
                osc.connect(gain);
                gain.connect(this.audioContext.destination);
                gain.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                osc.start();
                osc.stop(this.audioContext.currentTime + 0.5);
            }
        };

        const Haptics = {
            jump() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([15]);
                }
            },
            collect() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([30, 20, 30]);
                }
            },
            crash() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([150, 30, 80, 30, 40]);
                }
            },
            levelUp() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([80, 20, 80, 20, 80]);
                }
            }
        };

        const AudioSys = {
            bgm: null,
            localBlobUrl: null,
            currentMode: 'none', 
            retryCount: 0,
            
            setStatus(msg) {
                const el = document.getElementById('audioStatus');
                if (el) {
                    el.textContent = msg;
                    el.style.color = '#fff';
                    setTimeout(() => el.style.color = 'var(--primary)', 200);
                }
            },

            init() {
                this.setupAudioElement(CONFIG.MENU_MUSIC);
                this.currentMode = 'menu';
                this.setStatus("MENU AUDIO RDY");
            },

            setupAudioElement(src) {
                if (this.bgm) {
                    this.bgm.pause();
                    this.bgm.src = "";
                    this.bgm.load();
                }
                this.bgm = new Audio();
                this.bgm.src = src;
                this.bgm.loop = true;
                this.bgm.volume = 0.8;
                this.bgm.preload = "auto";
                
                this.bgm.onwaiting = () => this.setStatus("BUFFERING...");
                this.bgm.onplaying = () => {
                    this.setStatus("PLAYING");
                    this.retryCount = 0;
                };
                
                this.bgm.onerror = (e) => {
                    console.warn("Audio error:", e);
                    this.setStatus("LOAD ERROR");
                };
            },

            loadLocalFile(file) {
                if (this.localBlobUrl) URL.revokeObjectURL(this.localBlobUrl);
                this.localBlobUrl = URL.createObjectURL(file);
                this.setupAudioElement(this.localBlobUrl);
                this.setStatus("FILE LOADED");
            },
            
            switchToGameMusic() {
                if (this.localBlobUrl) return;
                const randomIndex = Math.floor(Math.random() * CONFIG.GAME_PLAYLIST.length);
                const track = CONFIG.GAME_PLAYLIST[randomIndex];
                this.currentMode = 'game';
                this.setStatus("LOADING TRK " + (randomIndex + 1));
                this.setupAudioElement(track);
                this.play();
            },

            switchToGameOverMusic() {
                if (this.localBlobUrl) return;
                const randomIndex = Math.floor(Math.random() * CONFIG.GAMEOVER_PLAYLIST.length);
                const track = CONFIG.GAMEOVER_PLAYLIST[randomIndex];
                this.currentMode = 'gameover';
                this.setStatus("DEATH SOUND");
                this.setupAudioElement(track);
                this.bgm.loop = false; 
                this.play();
            },

            switchToMenuMusic() {
                if (this.localBlobUrl) return;
                this.currentMode = 'menu';
                this.setStatus("LOADING MENU");
                this.setupAudioElement(CONFIG.MENU_MUSIC);
            },
            
            play() {
                if (!this.bgm) return;
                const playPromise = this.bgm.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => this.setStatus("PLAYING")).catch(error => {
                        console.warn("Play failed:", error);
                        this.setStatus("AUTOPLAY BLOCK");
                    });
                }
            },
            
            pause() { if (this.bgm) { this.bgm.pause(); this.setStatus("PAUSED"); } },
            resume() { if (this.bgm && this.bgm.paused) { this.bgm.play(); this.setStatus("RESUMED"); } },
            stop() { if (this.bgm) { this.bgm.pause(); this.bgm.currentTime = 0; this.setStatus("STOPPED"); } }
        };

        const ALCHEMICAL_SYMBOLS = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.root = document.documentElement;
                
                this.state = GameState.START;
                this.currentLevelIdx = 0;
                this.frames = 0;
                this.score = 0;
                this.highScore = localStorage.getItem('93protocol_highscore') || 0;
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED;
                this.shake = 0;
                this.lastFrameTime = 0;
                this.fps = 0;
                this.isMobile = isMobile;
                this.aspectRatio = 16/9;
                this.baseWidth = 800;
                this.baseHeight = 450;
                this.scaleFactor = 1;
                this.glitchEffect = false;
                this.glitchTimer = 0;
                this.glitchDuration = 300;
                this.tunnelOffset = 0;
                this.tunnelSpeed = 0.5;
                this.hitStop = 0;
                this.screenFlash = null;
                this.backgroundParticles = [];
                
                this.player = null;
                this.particles = [];
                this.stars = [];
                this.obstacles = [];
                this.collectibles = [];
                this.gameLevels = []; 
                this.currentBaseGap = CONFIG.PILLAR_GAP;
                
                this.settings = { music: true, sfx: true, vibration: true };
                
                this.loadSettings();
                this.initEventListeners();
                this.resizeCanvas();
                this.preloadAllImages();
                this.createBackgroundParticles();
                
                AudioSys.init();
                SFX.init();
                this.randomizeMenuBackground();
            }
            
            randomizeMenuBackground() {
                if(newImageIDs.length > 0) {
                    const randomId = newImageIDs[Math.floor(Math.random() * newImageIDs.length)];
                    const url = CONFIG.BASE_URL + randomId + CONFIG.IMG_SUFFIX;
                    document.getElementById('startScreen').style.backgroundImage = `url('${url}')`;
                }
            }
            
            createBackgroundParticles() {
                for (let i = 0; i < 25; i++) { 
                    this.backgroundParticles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        z: Math.random() * 2 + 0.5,
                        size: Math.random() * 3 + 2,
                        speed: Math.random() * 0.5 + 0.1,
                        color: palette[Math.floor(Math.random() * palette.length)],
                        opacity: Math.random() * 0.4 + 0.1,
                        shape: Math.floor(Math.random() * 3) 
                    });
                }
            }
            
            triggerOrbGlitch() {
                GlitchFX.trigger(80, 'orb');
                this.screenFlash = { active: true, duration: 10, color: '#ffd700', intensity: 0.3 };
            }
            
            triggerLevelUpGlitch() {
                GlitchFX.trigger(150, 'level');
                this.screenFlash = { active: true, duration: 20, color: this.gameLevels[this.currentLevelIdx]?.accent || '#ff003c', intensity: 0.4 };
            }
            
            triggerDeathGlitch() {
                GlitchFX.trigger(200, 'death');
                this.screenFlash = { active: true, duration: 30, color: '#ff003c', intensity: 0.6 };
            }
            
            applyScreenFlash() {
                if (!this.screenFlash || !this.screenFlash.active) return;
                this.ctx.save();
                this.ctx.fillStyle = this.screenFlash.color;
                this.ctx.globalAlpha = this.screenFlash.intensity * (this.screenFlash.duration / 30);
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.restore();
                this.screenFlash.duration--;
                if (this.screenFlash.duration <= 0) {
                    this.screenFlash.active = false;
                }
            }
            
            initEventListeners() {
                window.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && this.state === GameState.PLAYING) this.playerJump();
                    else if (e.code === 'Escape') this.togglePause();
                });
                window.addEventListener('mousedown', (e) => {
                    if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'LABEL' && this.state === GameState.PLAYING) this.playerJump();
                });
                window.addEventListener('touchstart', (e) => {
                    if (this.state === GameState.PLAYING) {
                        e.preventDefault();
                        const touchY = e.touches[0].clientY;
                        if (touchY > window.innerHeight * 0.6) {
                            this.playerJump();
                        }
                    }
                }, { passive: false });
                document.getElementById('startBtn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (this.settings.music) AudioSys.switchToGameMusic();
                    this.startGame();
                });
                document.getElementById('restartBtn').addEventListener('click', (e) => {
                     e.stopPropagation();
                     if (this.settings.music) AudioSys.switchToGameMusic();
                     this.restartGame();
                });
                document.getElementById('goMenuBtn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.returnToMenu();
                });
                document.getElementById('pauseBtn').addEventListener('click', (e) => { e.stopPropagation(); this.togglePause(); });
                document.getElementById('resumeBtn').addEventListener('click', (e) => { e.stopPropagation(); this.togglePause(); });
                document.getElementById('menuBtn').addEventListener('click', (e) => { e.stopPropagation(); this.returnToMenu(); });
                document.getElementById('settingsBtn').addEventListener('click', (e) => { e.stopPropagation(); this.showSettings(); });
                document.getElementById('backBtn').addEventListener('click', (e) => { e.stopPropagation(); this.hideSettings(); });
                
                document.getElementById('musicToggle').addEventListener('change', (e) => {
                    this.settings.music = e.target.checked;
                    this.saveSettings();
                    if (!this.settings.music) AudioSys.stop();
                    else if (this.state === GameState.PLAYING) AudioSys.play();
                });
                document.getElementById('sfxToggle').addEventListener('change', (e) => {
                    this.settings.sfx = e.target.checked;
                    this.saveSettings();
                });
                document.getElementById('vibrationToggle').addEventListener('change', (e) => {
                    this.settings.vibration = e.target.checked;
                    this.saveSettings();
                });
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            loadSettings() {
                const saved = localStorage.getItem('93protocol_settings');
                if (saved) this.settings = { ...this.settings, ...JSON.parse(saved) };
                document.getElementById('musicToggle').checked = this.settings.music;
                document.getElementById('sfxToggle').checked = this.settings.sfx;
                document.getElementById('vibrationToggle').checked = this.settings.vibration;
            }
            
            saveSettings() { localStorage.setItem('93protocol_settings', JSON.stringify(this.settings));
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.calculateScaleFactor();
                this.adjustForScreenSize();
            }
            
            calculateScaleFactor() {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const targetRatio = 16/9;
                const currentRatio = width/height;
                if (currentRatio > targetRatio) {
                    this.scaleFactor = height / this.baseHeight;
                } else {
                    this.scaleFactor = width / this.baseWidth;
                }
                
                this.scaleFactor = Math.max(0.6, Math.min(this.scaleFactor, 1.5));
            }
            
            adjustForScreenSize() {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const isPortrait = height > width;
                
                // Adaptive GAP settings for Portrait Mode
                if (isPortrait) {
                    // Widen the gap significantly for portrait mode to make it playable
                    this.currentBaseGap = 290; 
                    
                    // If screen is very narrow, shrink player slightly
                    if (width < 400) {
                        if (this.player) this.player.r = 13;
                    }
                } else {
                    this.currentBaseGap = CONFIG.PILLAR_GAP; // 250
                    if (this.player) this.player.r = CONFIG.PLAYER_RADIUS; // 16
                }
            }
            
            preloadAllImages() {
                const progressFill = document.getElementById('progressFill');
                const loadingText = document.getElementById('loadingText');
                let loadedCount = 0;
                
                const failsafe = setTimeout(() => {
                    if (loadedCount < MASTER_POOL.length) {
                        console.warn("Loading timed out. Forcing start.");
                        this.finishLoading();
                    }
                }, 5000);
                MASTER_POOL.forEach(lvl => {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.onload = () => {
                        lvl.img = img;
                        lvl.loaded = true;
                        loadedCount++;
                        const percent = Math.floor((loadedCount / MASTER_POOL.length) * 100);
                        progressFill.style.width = `${percent}%`;
                        loadingText.innerText = `CHARGING SIGIL... ${loadedCount}/${MASTER_POOL.length}`;
                        if (loadedCount >= MASTER_POOL.length) {
                            clearTimeout(failsafe);
                            this.finishLoading();
                        }
                    };
                    img.onerror = () => {
                        console.warn(`Failed to load image: ${lvl.id}`);
                        loadedCount++;
                        if (loadedCount >= MASTER_POOL.length) {
                            clearTimeout(failsafe);
                            this.finishLoading();
                        }
                    };
                    img.src = CONFIG.BASE_URL + lvl.id + CONFIG.IMG_SUFFIX;
                });
            }
            
            finishLoading() {
                setTimeout(() => {
                    document.getElementById('loadingMsg').classList.add('hidden');
                    document.getElementById('menuButtons').classList.remove('hidden');
                }, 500);
            }
            
            prepareLevels() {
                let shuffled = [...MASTER_POOL];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                this.gameLevels = shuffled.map((lvl, index) => {
                    return { ...lvl, threshold: index * 5 };
                });
            }

            startGame() {
                this.prepareLevels();
                this.state = GameState.PLAYING;
                document.getElementById('startScreen').classList.add('hidden');
                document.getElementById('scoreUi').classList.remove('hidden');
                document.getElementById('pauseBtn').classList.remove('hidden');
                document.getElementById('instructions').classList.remove('hidden');
                
                if (this.isMobile) {
                    document.getElementById('mobileControls').classList.remove('hidden');
                    setTimeout(() => {
                        document.getElementById('mobileControls').classList.add('hidden');
                    }, 5000);
                }
                
                if (CONFIG.DEBUG) document.getElementById('statsPanel').classList.remove('hidden');
                this.initGame();
                this.gameLoop();
            }
            
            initGame() {
                this.player = new Player();
                this.obstacles = [];
                this.collectibles = [];
                this.particles = [];
                this.stars = [];
                for (let i = 0; i < 40; i++) this.stars.push(new Star());
                this.score = 0;
                this.currentLevelIdx = 0;
                this.frames = 0;
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED;
                this.shake = 0;
                this.tunnelOffset = 0;
                this.hitStop = 0;
                document.getElementById('scoreUi').innerText = "0";
                
                // Recalculate adaptive settings on start
                this.adjustForScreenSize();
                
                this.applyLevel();
            }
            
            applyLevel() {
                if (this.currentLevelIdx >= this.gameLevels.length) return;
                const l = this.gameLevels[this.currentLevelIdx];
                document.getElementById('levelUi').innerText = l.name;
                document.getElementById('levelUi').style.color = l.accent;
                document.getElementById('levelUi').style.textShadow = `0 0 15px ${l.accent}`;
                this.root.style.setProperty('--primary', l.accent);
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED + (this.currentLevelIdx * CONFIG.SPEED_INCREASE_PER_LEVEL);
                
                if (this.currentLevelIdx > 0) {
                    this.triggerGlitchEffect();
                    Haptics.levelUp();
                    if (this.settings.sfx) SFX.levelUp();
                }
            }
            
            triggerGlitchEffect() {
                this.glitchEffect = true;
                this.glitchTimer = this.glitchDuration;
            }
            
            applyGlitchEffect() {
                if (!this.glitchEffect) return;
                const ctx = this.ctx;
                const intensity = this.glitchTimer / this.glitchDuration;
                if (Math.random() > 0.7) {
                    const shiftX = Math.floor(Math.random() * 10 * intensity) - 5;
                    const shiftY = Math.floor(Math.random() * 10 * intensity) - 5;
                    ctx.save();
                    ctx.translate(shiftX, shiftY);
                    ctx.restore();
                }
                
                if (Math.random() > 0.8) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fillRect(0, Math.floor(Math.random() * this.canvas.height), this.canvas.width, 1);
                }
                
                this.glitchTimer -= 16;
                if (this.glitchTimer <= 0) {
                    this.glitchEffect = false;
                }
            }
            
            getCurrentGap() {
                // Use the adaptive base gap instead of fixed config
                const baseGap = this.currentBaseGap; 
                const levelsCompleted = Math.floor(this.currentLevelIdx / 5);
                const gapReduction = levelsCompleted * CONFIG.PILLAR_GAP_DECREASE_PER_5_LEVELS;
                const calculatedGap = Math.max(CONFIG.MIN_PILLAR_GAP, baseGap - gapReduction);
                return calculatedGap;
            }
            
            checkLevel() {
                const nextIdx = this.currentLevelIdx + 1;
                if (nextIdx >= this.gameLevels.length) return;
                const next = this.gameLevels[nextIdx];
                if (this.score >= next.threshold) {
                    this.currentLevelIdx++;
                    this.applyLevel();
                    this.shake = 12;
                    this.hitStop = 3;
                    this.triggerLevelUpGlitch();
                    for (let i = 0; i < 30; i++) {
                        this.particles.push(new Particle(
                            this.canvas.width / 2, this.canvas.height / 2, 
                            this.gameLevels[this.currentLevelIdx].accent, 12,
                            Math.random() > 0.5 ? 'hexagram' : 'triangle'
                        ));
                    }
                    if (this.settings.sfx) SFX.levelUp();
                    Haptics.levelUp();
                }
            }
            
            playerJump() {
                if (this.state === GameState.PLAYING) {
                    this.player.jump();
                    Haptics.jump();
                    GlitchFX.trigger(50, 'rgb');
                }
            }
            
            togglePause() {
                if (this.state === GameState.PLAYING) {
                    this.state = GameState.PAUSED;
                    document.getElementById('pauseScreen').classList.remove('hidden');
                    AudioSys.pause();
                } else if (this.state === GameState.PAUSED) {
                    this.state = GameState.PLAYING;
                    document.getElementById('pauseScreen').classList.add('hidden');
                    AudioSys.resume();
                    this.gameLoop();
                }
            }
            
            showSettings() {
                document.getElementById('startScreen').classList.add('hidden');
                document.getElementById('settingsScreen').classList.remove('hidden');
                this.state = GameState.SETTINGS;
            }
            
            hideSettings() {
                document.getElementById('settingsScreen').classList.add('hidden');
                document.getElementById('startScreen').classList.remove('hidden');
                this.state = GameState.START;
            }
            
            returnToMenu() {
                this.state = GameState.START;
                document.getElementById('gameOverScreen').classList.add('hidden');
                document.getElementById('pauseScreen').classList.add('hidden');
                document.getElementById('startScreen').classList.remove('hidden');
                document.getElementById('scoreUi').classList.add('hidden');
                document.getElementById('pauseBtn').classList.add('hidden');
                document.getElementById('instructions').classList.add('hidden');
                document.getElementById('statsPanel').classList.add('hidden');
                document.getElementById('mobileControls').classList.add('hidden');
                this.randomizeMenuBackground();
                if (this.settings.music) AudioSys.switchToMenuMusic();
            }
            
            gameOver() {
                if (this.state === GameState.GAME_OVER) return;
                this.state = GameState.GAME_OVER;
                this.shake = 15;
                this.triggerDeathGlitch();
                if (this.settings.sfx) SFX.crash();
                Haptics.crash();
                
                for (let i = 0; i < 25; i++) {
                    this.particles.push(new Particle(
                        this.player.x, this.player.y,
                        '#ff003c', 10,
                        Math.random() > 0.3 ? 'hexagram' : 'triangle'
                    ));
                }
                
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('93protocol_highscore', this.highScore);
                    document.getElementById('highScoreMsg').textContent = "NEW GNOSIS ATTAINED";
                } else {
                    document.getElementById('highScoreMsg').textContent = `BEST: ${this.highScore}`;
                }
                
                if (this.settings.music) AudioSys.switchToGameOverMusic();
                
                document.getElementById('finalScore').innerText = this.score;
                document.getElementById('scoreUi').classList.add('hidden');
                document.getElementById('pauseBtn').classList.add('hidden');
                document.getElementById('instructions').classList.add('hidden');
                document.getElementById('statsPanel').classList.add('hidden');
                document.getElementById('mobileControls').classList.add('hidden');
                document.getElementById('gameOverScreen').classList.remove('hidden');
            }
            
            restartGame() {
                this.state = GameState.PLAYING;
                this.prepareLevels();
                document.getElementById('gameOverScreen').classList.add('hidden');
                document.getElementById('scoreUi').classList.remove('hidden');
                document.getElementById('pauseBtn').classList.remove('hidden');
                document.getElementById('instructions').classList.remove('hidden');
                if (this.isMobile) {
                    document.getElementById('mobileControls').classList.remove('hidden');
                    setTimeout(() => {
                        document.getElementById('mobileControls').classList.add('hidden');
                    }, 5000);
                }
                if (CONFIG.DEBUG) document.getElementById('statsPanel').classList.remove('hidden');
                this.initGame();
                this.gameLoop();
            }
            
            gameLoop(currentTime = 0) {
                if (this.state !== GameState.PLAYING) return;
                if (this.lastFrameTime) {
                    this.fps = Math.round(1000 / (currentTime - this.lastFrameTime));
                    if (CONFIG.DEBUG) document.getElementById('fpsCounter').textContent = this.fps;
                }
                this.lastFrameTime = currentTime;
                
                if (this.hitStop > 0) {
                    this.hitStop--;
                    this.drawScene(currentTime);
                    requestAnimationFrame((time) => this.gameLoop(time));
                    return;
                }

                this.frames++;
                
                if (Math.random() > 0.995 && this.frames % 60 === 0) {
                    GlitchFX.trigger(30, 'random');
                }
                
                this.tunnelOffset += this.tunnelSpeed * (1 + this.gameSpeed * 0.1);
                
                this.updateGameObjects();
                this.drawScene(currentTime);
                
                requestAnimationFrame((time) => this.gameLoop(time));
            }

            drawScene(currentTime) {
                const lvl = this.gameLevels[this.currentLevelIdx];
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawHyperspaceTunnel(lvl);
                GlitchFX.apply(this.ctx, currentTime);
                this.applyScreenFlash();
                if (this.glitchEffect) {
                    this.applyGlitchEffect();
                }
                this.ctx.save();
                if (this.shake > 0) {
                    this.ctx.translate((Math.random() - 0.5) * this.shake, (Math.random() - 0.5) * this.shake);
                    this.shake *= 0.9;
                }
                this.drawGameObjects();
                this.ctx.restore();
            }
            
            drawHyperspaceTunnel(lvl) {
                const ctx = this.ctx;
                const cx = this.canvas.width / 2;
                const cy = this.canvas.height / 2;
                const maxRadius = Math.max(this.canvas.width, this.canvas.height) * 0.8;
                
                const breath = (Math.sin(Date.now() * 0.002 * (1 + this.gameSpeed * 0.1)) + 1) * 0.5;
                
                ctx.strokeStyle = lvl.accent;
                ctx.lineWidth = 1.5;
                optimizedShadow.apply(ctx, 15, lvl.accent);
                
                const baseRotation = this.frames * 0.005;

                for (let i = 0; i < 8; i++) {
                    const progress = ((this.tunnelOffset + i * 60) % 300) / 300;
                    const radius = progress * maxRadius;
                    if (radius < 50) continue;
                    ctx.globalAlpha = (1 - progress * 0.8) * (0.8 + breath * 0.2);
                    ctx.save();
                    ctx.translate(cx, cy);
                    ctx.rotate(baseRotation + (i * 0.1)); 
                    ctx.beginPath();
                    for(let k = 0; k < 5; k++) {
                        const angle = (k * 4 * Math.PI / 5) - (Math.PI / 2); 
                        const px = Math.cos(angle) * radius;
                        const py = Math.sin(angle) * radius;
                        if(k===0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                }
                
                optimizedShadow.clear(ctx);
                ctx.globalAlpha = 1;
                
                if (Math.random() > 0.95 && this.frames % 30 === 0) {
                    ctx.save();
                    ctx.globalAlpha = 0.05;
                    ctx.fillStyle = lvl.accent;
                    const y = Math.random() * this.canvas.height;
                    ctx.fillRect(0, y, this.canvas.width, 1);
                    ctx.restore();
                }
                
                this.backgroundParticles.forEach(p => {
                    p.y += p.speed * (1 + this.gameSpeed * 0.1);
                    if (p.y > this.canvas.height) { 
                        p.y = 0; 
                        p.x = Math.random() * this.canvas.width;
                        p.shape = Math.floor(Math.random() * 3);
                    }
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.opacity;
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(this.frames * 0.02);
                    if (p.shape === 0) { 
                        ctx.beginPath();
                        ctx.moveTo(0, -p.size);
                        ctx.lineTo(p.size, p.size);
                        ctx.lineTo(-p.size, p.size);
                        ctx.fill();
                    } else if (p.shape === 1) { 
                        ctx.beginPath();
                        ctx.moveTo(0, -p.size);
                        ctx.lineTo(p.size, 0);
                        ctx.lineTo(0, p.size);
                        ctx.lineTo(-p.size, 0);
                        ctx.fill();
                    } else { 
                        ctx.fillRect(-p.size/2, -p.size*1.5, p.size, p.size*3);
                        ctx.fillRect(-p.size*1.5, -p.size/2, p.size*3, p.size);
                    }
                    ctx.restore();
                });
                ctx.globalAlpha = 1;
                
                ctx.globalAlpha = 0.6;
                if (lvl.loaded && lvl.img && lvl.img.complete) {
                    try {
                        const img = lvl.img;
                        const canvasRatio = this.canvas.width / this.canvas.height;
                        const imgRatio = img.width / img.height;
                        let drawWidth, drawHeight, drawX, drawY;
                        if (canvasRatio > imgRatio) {
                            drawHeight = this.canvas.height;
                            drawWidth = img.width * (drawHeight / img.height);
                            drawX = (this.canvas.width - drawWidth) / 2;
                            drawY = 0;
                        } else {
                            drawWidth = this.canvas.width;
                            drawHeight = img.height * (drawWidth / img.width);
                            drawX = 0;
                            drawY = (this.canvas.height - drawHeight) / 2;
                        }
                        ctx.filter = 'blur(1px)';
                        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                        ctx.filter = 'none';
                    } catch (e) {}
                }
                ctx.globalAlpha = 1.0;
                
                // Draw falling stars (Symbols)
                this.stars.forEach(s => {
                    s.update();
                    s.draw(this.ctx);
                });
            }
            
            updateGameObjects() {
                const currentGap = this.getCurrentGap();
                if (this.frames % Math.floor(CONFIG.PILLAR_SPAWN_RATE / (1 + this.gameSpeed * 0.05)) === 0) {
                    const p = new Pillar(this.currentLevelIdx, currentGap);
                    this.obstacles.push(p);
                    if (Math.random() > (1 - CONFIG.ORB_SPAWN_CHANCE)) {
                        this.collectibles.push(new Orb(p.x + p.w / 2, p.top + p.gap / 2));
                    }
                }
                
                this.obstacles.forEach((o, i) => {
                    o.update(this.gameSpeed);
                    const hitboxReduction = CONFIG.HITBOX_OFFSET;
                    const pLeft = this.player.x - this.player.r + hitboxReduction;
                    const pRight = this.player.x + this.player.r - hitboxReduction;
                    const pTop = this.player.y - this.player.r + hitboxReduction;
                    const pBottom = this.player.y + this.player.r - hitboxReduction;
                    const pillarLeft = o.x;
                    const pillarRight = o.x + o.w;
                    const topPillarBottom = o.top;
                    const topPillarTop = 0;
                    const bottomPillarTop = o.top + o.gap;
                    const bottomPillarBottom = this.canvas.height;
                    const horizontalOverlap = pRight > pillarLeft && pLeft < pillarRight;
                    const hittingTopPillar = horizontalOverlap && pBottom > topPillarTop && pTop < topPillarBottom;
                    const hittingBottomPillar = horizontalOverlap && pTop < bottomPillarBottom && pBottom > bottomPillarTop;
                    if (hittingTopPillar || hittingBottomPillar) {
                        this.gameOver();
                    }
                    if (!o.marked && o.x + o.w < this.player.x) {
                        this.score++;
                        o.marked = true;
                        document.getElementById('scoreUi').innerText = this.score;
                        this.checkLevel();
                    }
                    if (o.x < -100) this.obstacles.splice(i, 1);
                });
                
                this.collectibles.forEach((c, i) => {
                    c.update(this.gameSpeed);
                    const dist = Math.hypot(this.player.x - c.x, this.player.y - c.y);
                    if (dist < this.player.r + c.r && !c.collected) {
                        this.score += 5;
                        document.getElementById('scoreUi').innerText = this.score;
                        c.collected = true;
                        this.triggerOrbGlitch();
                        this.hitStop = 3;
                        for (let k = 0; k < 20; k++) {
                            this.particles.push(new Particle(
                                c.x, c.y, 
                                '#ffd700', 8,
                                Math.random() > 0.6 ? 'hexagram' : 
                                Math.random() > 0.3 ? 'triangle' : 'diamond'
                            ));
                        }
                        if (this.settings.sfx) SFX.collect();
                        Haptics.collect();
                        this.collectibles.splice(i, 1);
                        this.checkLevel();
                    }
                    if (c.x < -50) this.collectibles.splice(i, 1);
                });
                
                this.player.update();
                
                this.particles.forEach((p, i) => {
                    p.update();
                    if (p.life <= 0) this.particles.splice(i, 1);
                });
            }
            
            drawGameObjects() {
                const currentLvlConfig = this.gameLevels[this.currentLevelIdx];
                this.obstacles.forEach(o => o.draw(this.ctx, currentLvlConfig));
                this.collectibles.forEach(c => c.draw(this.ctx));
                this.player.draw(this.ctx, currentLvlConfig);
                this.particles.forEach(p => p.draw(this.ctx));
            }
        }

        class Player {
            constructor() {
                this.x = window.innerWidth * 0.25;
                this.y = window.innerHeight / 2;
                this.vy = 0;
                this.r = CONFIG.PLAYER_RADIUS;
                this.rot = 0;
                this.trail = [];
                this.trailLength = game.isMobile ? 8 : 12;
                this.jumpCooldown = 0;
                this.scaleX = 1;
                this.scaleY = 1;
            }
            
            update() {
                this.vy += CONFIG.GRAVITY;
                this.y += this.vy;
                this.rot += 0.03;
                
                const stretch = Math.min(Math.abs(this.vy) * 0.04, 0.3);
                if (this.vy < 0) { 
                    this.scaleY = 1 + stretch;
                    this.scaleX = 1 - stretch * 0.5;
                } else { 
                    this.scaleY = 1 - stretch * 0.5;
                    this.scaleX = 1 + stretch;
                }

                if (this.y > window.innerHeight - this.r * 1.5) {
                    game.gameOver();
                }
                if (this.y < this.r * 1.5) { 
                    this.y = this.r * 1.5;
                    this.vy = 0; 
                }
                
                if (this.jumpCooldown > 0) {
                    this.jumpCooldown--;
                }
                
                if (game.frames % 2 === 0) {
                    this.trail.unshift({
                        x: this.x, 
                        y: this.y, 
                        r: this.r, 
                        life: 1.0,
                        rot: this.rot,
                        scaleX: this.scaleX,
                        scaleY: this.scaleY
                    });
                    if (this.trail.length > this.trailLength) this.trail.pop();
                }
                
                this.trail.forEach(t => t.life -= 0.05);
            }
            
            draw(ctx, conf) {
                const hue = (game.frames * 2) % 360;
                const strokeColor = `hsl(${hue}, 100%, 60%)`;
                const shadowColor = `hsl(${hue}, 100%, 50%)`;
                this.trail.forEach((t, i) => {
                    if (t.life > 0) {
                        ctx.save();
                        ctx.globalAlpha = t.life * 0.6;
                        ctx.translate(t.x, t.y);
                        ctx.scale(t.scaleX, t.scaleY);
                        ctx.rotate(t.rot + (this.vy * 0.05));
                        
                        const trailR = t.r * 0.7 * t.life;
                        const points = [];
                        for (let j = 0; j < 6; j++) {
                            const angle = (j * 60 - 90) * Math.PI / 180;
                            points.push({ 
                                x: Math.cos(angle) * trailR, 
                                y: Math.sin(angle) * trailR 
                            });
                        }
                        
                        optimizedShadow.apply(ctx, 20 * t.life, shadowColor);
                        ctx.strokeStyle = strokeColor;
                        ctx.lineWidth = 2 * t.life;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';

                        ctx.beginPath();
                        ctx.moveTo(points[0].x, points[0].y);
                        ctx.lineTo(points[2].x, points[2].y);
                        ctx.lineTo(points[5].x, points[5].y);
                        ctx.lineTo(points[3].x, points[3].y);
                        ctx.lineTo(points[1].x, points[1].y);
                        ctx.lineTo(points[4].x, points[4].y);
                        ctx.lineTo(points[0].x, points[0].y);
                        ctx.stroke();
                        
                        if (game.isMobile) {
                            ctx.lineWidth = 6 * t.life;
                            ctx.globalAlpha = t.life * 0.2;
                            ctx.stroke();
                        }
                        
                        ctx.restore();
                    }
                });
                ctx.globalAlpha = 1.0;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.scaleX, this.scaleY);
                ctx.rotate(this.rot + (this.vy * 0.05));
                
                const r = this.r * 1.2;
                const points = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (i * 60 - 90) * Math.PI / 180;
                    points.push({ x: Math.cos(angle) * r, y: Math.sin(angle) * r });
                }
                
                optimizedShadow.apply(ctx, 25, shadowColor);
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                ctx.lineTo(points[2].x, points[2].y);
                ctx.lineTo(points[5].x, points[5].y);
                ctx.lineTo(points[3].x, points[3].y);
                ctx.lineTo(points[1].x, points[1].y);
                ctx.lineTo(points[4].x, points[4].y);
                ctx.lineTo(points[0].x, points[0].y);
                ctx.stroke();
                
                if (game.isMobile) {
                    ctx.save();
                    ctx.strokeStyle = shadowColor;
                    ctx.lineWidth = 8;
                    ctx.globalAlpha = 0.3;
                    ctx.stroke();
                    ctx.restore();
                }

                const pulse = Math.sin(game.frames * 0.1) * 0.5 + 1;
                ctx.fillStyle = "#fff";
                optimizedShadow.apply(ctx, 40 * pulse, "#fff");
                ctx.beginPath();
                ctx.arc(0, 0, 3 * pulse, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
            
            jump() {
                if (this.jumpCooldown > 0) return;
                this.vy = CONFIG.PLAYER_JUMP_FORCE;
                this.jumpCooldown = game.isMobile ? 8 : 5;
                if (Math.random() > 0.7) {
                    GlitchFX.trigger(40, 'jump');
                }
                
                for (let i = 0; i < (game.isMobile ? 10 : 12); i++) {
                    const type = Math.random() > 0.7 ? 'hexagram' : Math.random() > 0.4 ? 'triangle' : 'circle';
                    game.particles.push(new Particle(
                        this.x, this.y, '#fff', 3, type
                    ));
                }
                
                if (game.settings.sfx) SFX.jump();
                Haptics.jump();
                GlitchFX.trigger(50, 'rgb');
            }
        }

        class Pillar {
            constructor(lvlIndex, currentGap) {
                this.x = window.innerWidth;
                this.w = CONFIG.PILLAR_WIDTH;
                this.gap = currentGap;
                const maxTop = window.innerHeight - this.gap - 50;
                const minTop = 30;
                this.top = Math.random() * (maxTop - minTop) + minTop;
                this.marked = false;
                this.lvl = lvlIndex;
                this.rotation = Math.random() * Math.PI * 2;
                this.innerPattern = Math.floor(Math.random() * 3);
                this.pulse = 0;
                this.hasWarning = game.isMobile && Math.random() > 0.5;
                this.warningAlpha = 1;
            }
            
            update(speed) { 
                this.x -= speed;
                this.pulse += 0.05;
                this.rotation += 0.005;
                if (this.hasWarning) {
                    this.warningAlpha -= 0.01;
                }
            }
            
            draw(ctx, conf) {
                const hue = (game.frames * 0.5 + this.x * 0.1) % 360;
                const mainColor = `hsl(${hue}, 100%, 60%)`;
                const innerColor = `hsl(${(hue + 60) % 360}, 100%, 70%)`;
                const glowColor = `hsl(${hue}, 100%, 50%)`;
                
                if (this.hasWarning && this.x < window.innerWidth * 0.7 && this.warningAlpha > 0) {
                    ctx.save();
                    ctx.globalAlpha = this.warningAlpha * 0.3;
                    ctx.fillStyle = '#ff003c';
                    ctx.fillRect(this.x - 10, 0, this.w + 20, window.innerHeight);
                    ctx.restore();
                }
                
                ctx.save();
                ctx.translate(this.x + this.w/2, 0);
                
                optimizedShadow.apply(ctx, 30, glowColor);
                ctx.strokeStyle = mainColor;
                ctx.lineWidth = 4;
                ctx.fillStyle = "rgba(0,0,0,0.7)";
                const topHeight = this.top + 10;
                ctx.beginPath();
                ctx.moveTo(-this.w/2, -10);
                ctx.lineTo(this.w/2, -10);
                
                const jagCount = 5;
                for (let i = 0; i <= jagCount; i++) {
                    const x = this.w/2 - (i * this.w/jagCount);
                    const y = -10 + (i % 2 === 0 ? 8 : -4);
                    ctx.lineTo(x, y);
                }
                
                ctx.lineTo(-this.w/2, topHeight);
                ctx.lineTo(-this.w/2, -10);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                if (game.isMobile) {
                    ctx.save();
                    ctx.lineWidth = 10;
                    ctx.globalAlpha = 0.2;
                    ctx.stroke();
                    ctx.restore();
                }
                
                ctx.save();
                ctx.translate(0, topHeight/2);
                ctx.rotate(this.rotation);
                ctx.globalAlpha = 0.4;
                ctx.strokeStyle = innerColor;
                ctx.lineWidth = 1.5;
                optimizedShadow.apply(ctx, 15, innerColor);
                
                if (this.innerPattern === 0) {
                    const size = Math.min(this.w, topHeight) * 0.3;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = Math.cos(angle) * size;
                        const y = Math.sin(angle) * size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                } else if (this.innerPattern === 1) {
                    const size = Math.min(this.w, topHeight) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size * 0.866, size * 0.5);
                    ctx.lineTo(-size * 0.866, size * 0.5);
                    ctx.closePath();
                    ctx.stroke();
                } else {
                    const size = Math.min(this.w, topHeight) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(-size, 0);
                    ctx.lineTo(size, 0);
                    ctx.moveTo(0, -size);
                    ctx.lineTo(0, size);
                    ctx.stroke();
                }
                ctx.restore();
                const botY = this.top + this.gap;
                const botHeight = window.innerHeight - botY + 10;
                
                ctx.beginPath();
                ctx.moveTo(-this.w/2, botY);
                ctx.lineTo(this.w/2, botY);
                for (let i = 0; i <= jagCount; i++) {
                    const x = this.w/2 - (i * this.w/jagCount);
                    const y = botY + (i % 2 === 0 ? -4 : 8);
                    ctx.lineTo(x, y);
                }
                
                ctx.lineTo(this.w/2, botY + botHeight);
                ctx.lineTo(-this.w/2, botY + botHeight);
                ctx.lineTo(-this.w/2, botY);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                if (game.isMobile) {
                    ctx.save();
                    ctx.lineWidth = 10;
                    ctx.globalAlpha = 0.2;
                    ctx.stroke();
                    ctx.restore();
                }
                
                ctx.save();
                ctx.translate(0, botY + botHeight/2);
                ctx.rotate(-this.rotation);
                ctx.globalAlpha = 0.4;
                ctx.strokeStyle = innerColor;
                ctx.lineWidth = 1.5;
                
                if (this.innerPattern === 0) {
                    const size = Math.min(this.w, botHeight) * 0.3;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = Math.cos(angle) * size;
                        const y = Math.sin(angle) * size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                } else if (this.innerPattern === 1) {
                    const size = Math.min(this.w, botHeight) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size * 0.866, size * 0.5);
                    ctx.lineTo(-size * 0.866, size * 0.5);
                    ctx.closePath();
                    ctx.stroke();
                } else {
                    const size = Math.min(this.w, botHeight) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(-size, 0);
                    ctx.lineTo(size, 0);
                    ctx.moveTo(0, -size);
                    ctx.lineTo(0, size);
                    ctx.stroke();
                }
                ctx.restore();
                
                ctx.restore();
                optimizedShadow.clear(ctx);
                ctx.globalAlpha = 1.0;
            }
        }

        class Orb {
            constructor(x, y) {
                this.x = x;
                this.y = y; 
                this.r = 9;
                this.collected = false;
                this.float = Math.random() * Math.PI * 2;
                this.pulse = 0;
                this.rotation = 0;
            }
            
            update(speed) {
                this.x -= speed;
                this.float += 0.1;
                this.pulse += 0.15;
                this.rotation += 0.02;
                this.y += Math.sin(this.float) * 0.8;
            }
            
            draw(ctx) {
                if (this.collected) return;
                if (Math.random() > 0.97) {
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = '#ff00ff';
                    ctx.fillRect(this.x - this.r, this.y - this.r, this.r * 2, this.r * 2);
                    ctx.restore();
                }
                
                const pulseSize = this.r + Math.sin(this.pulse) * 3;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                optimizedShadow.apply(ctx, 25, '#ffd700');
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
                ctx.stroke();
                
                optimizedShadow.apply(ctx, 30, '#fff');
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.9;
                const r = pulseSize * 0.7;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i * 60) * Math.PI / 180;
                    const x = Math.cos(angle) * r;
                    const y = Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
                
                ctx.fillStyle = '#fff';
                optimizedShadow.apply(ctx, 40, '#fff');
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize * 0.2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
        }

        class Particle {
            constructor(x, y, c, speed, type = 'circle') {
                this.x = x;
                this.y = y; 
                this.c = c;
                this.vx = (Math.random() - 0.5) * speed;
                this.vy = (Math.random() - 0.5) * speed;
                this.life = 1; 
                this.size = Math.random() * 3 + 2;
                this.type = type;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.2;
                this.glow = Math.random() > 0.5;
            }
            
            update() { 
                this.x += this.vx;
                this.y += this.vy; 
                this.vx *= 0.97;
                this.vy *= 0.97;
                this.life -= 0.03; 
                this.rotation += this.rotationSpeed;
                this.size *= 0.98;
                if (game.isMobile) {
                    this.life -= 0.01;
                }
            }
            
            draw(ctx) {
                if (this.life <= 0) return;
                if (game.isMobile && this.type !== 'hexagram') {
                    ctx.globalAlpha = this.life * 0.5;
                    ctx.fillStyle = this.c;
                    ctx.fillRect(this.x - this.size, this.y - this.size, 
                                this.size * 2, this.size * 2);
                    ctx.globalAlpha = 1;
                    return;
                }
                
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.c;
                
                if (this.glow && this.life > 0.3) {
                    optimizedShadow.apply(ctx, 20 * this.life, this.c);
                }
                
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                if (this.type === 'hexagram') {
                    const r = this.size * 0.8;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 'triangle') {
                    const r = this.size;
                    ctx.beginPath();
                    ctx.moveTo(0, -r);
                    ctx.lineTo(r * 0.866, r * 0.5);
                    ctx.lineTo(-r * 0.866, r * 0.5);
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 'diamond') {
                    const r = this.size;
                    ctx.beginPath();
                    ctx.moveTo(0, -r);
                    ctx.lineTo(r, 0);
                    ctx.lineTo(0, r);
                    ctx.lineTo(-r, 0);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
        }
        
        class Star {
            constructor() {
                this.x = Math.random() * window.innerWidth;
                this.y = Math.random() * window.innerHeight;
                this.size = Math.random() * 10 + 8; // Size for text
                this.speed = Math.random() * 0.5 + 0.2;
                this.alpha = Math.random() * 0.5 + 0.2;
                this.symbol = ALCHEMICAL_SYMBOLS[Math.floor(Math.random() * ALCHEMICAL_SYMBOLS.length)];
                this.rotation = Math.random() * Math.PI * 2;
            }
            update() {
                this.y += this.speed;
                this.rotation += 0.01;
                if (this.y > window.innerHeight) {
                    this.y = -20;
                    this.x = Math.random() * window.innerWidth;
                    this.symbol = ALCHEMICAL_SYMBOLS[Math.floor(Math.random() * ALCHEMICAL_SYMBOLS.length)];
                }
                this.alpha = 0.3 + Math.sin(game.frames * 0.05 + this.x) * 0.2;
            }
            draw(ctx) {
                const conf = game.gameLevels[game.currentLevelIdx];
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.fillStyle = conf ? conf.accent : '#fff';
                ctx.globalAlpha = this.alpha;
                ctx.font = `${this.size}px "Cinzel Decorative"`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(this.symbol, 0, 0);
                ctx.restore();
                ctx.globalAlpha = 1.0;
            }
        }

        let game;
        document.addEventListener('DOMContentLoaded', () => {
            game = new Game();
        });
    </script>
</body>
</html>
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* CRT Scanline Effect */
        .scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
            opacity: 0.4;
        }
        
        /* Vignette for ominous feel */
        .vignette {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, black 130%);
            pointer-events: none;
            z-index: 11;
        }

        /* UI Overlay */
        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 20;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            transition: opacity 0.3s ease;
            padding: 20px;
            box-sizing: border-box;
        }

        /* Start Screen Specifics */
        #startScreen {
            background-size: cover;
            background-position: center;
            transition: background-image 1s ease-in-out;
            /* Psychedelic Background Animation */
            animation: bgBreath 10s infinite alternate;
        }
        
        /* Dark overlay to make text pop on top of image */
        #startScreen::before {
            content: '';
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: -1;
        }

        @keyframes bgBreath {
            0% { transform: scale(1); filter: hue-rotate(0deg); }
            100% { transform: scale(1.05); filter: hue-rotate(45deg); }
        }

        .hidden {
            opacity: 0 !important;
            pointer-events: none !important;
            display: none !important;
        }

        /* Neon Buttons */
        .mystic-btn {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--primary);
            color: #fff;
            padding: 15px 50px;
            font-size: 1.2rem;
            font-family: 'Cinzel Decorative', cursive;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 4px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 15px var(--primary), inset 0 0 10px var(--primary);
            margin: 10px;
            min-width: 260px;
            position: relative;
            overflow: hidden;
            text-shadow: 0 0 5px #fff;
            animation: psychedelicBorder 4s infinite linear;
        }

        @keyframes psychedelicBorder {
            0% { border-color: #ff003c; box-shadow: 0 0 15px #ff003c; }
            25% { border-color: #ff00ff; box-shadow: 0 0 15px #ff00ff; }
            50% { border-color: #00ffff; box-shadow: 0 0 15px #00ffff; }
            75% { border-color: #ffd700; box-shadow: 0 0 15px #ffd700; }
            100% { border-color: #ff003c; box-shadow: 0 0 15px #ff003c; }
        }

        .mystic-btn:hover {
            background: #fff;
            color: #000;
            transform: scale(1.05);
            text-shadow: none;
        }

        .mystic-btn:active {
            transform: scale(0.95);
        }

        .title-text {
            font-family: 'Cinzel Decorative', cursive;
            font-size: 5rem;
            color: #fff;
            text-shadow: 0 0 10px var(--primary);
            margin-bottom: 10px;
            letter-spacing: -2px;
            animation: pulseNeon 3s infinite alternate;
        }

        @keyframes pulseNeon {
            0% { text-shadow: 0 0 10px var(--primary), 0 0 20px var(--primary); opacity: 1; }
            100% { text-shadow: 0 0 20px var(--primary), 0 0 40px var(--primary), 0 0 80px var(--primary); opacity: 0.9; }
        }

        /* NEW: Floating Animation for UI */
        @keyframes gentleFloat {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }

        .level-indicator {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            font-size: 1.5rem;
            font-family: 'Cinzel Decorative', serif;
            font-weight: 700;
            letter-spacing: 6px;
            color: #fff;
            z-index: 15;
            text-shadow: 0 0 10px #000;
            text-transform: uppercase;
            animation: gentleFloat 4s ease-in-out infinite; 
        }

        .score-display {
            position: absolute;
            top: 10%;
            width: 100%;
            text-align: center;
            font-size: 9rem;
            font-family: 'Cinzel Decorative', serif;
            color: rgba(255, 255, 255, 0.1);
            z-index: 5;
            pointer-events: none;
            mix-blend-mode: screen;
            font-weight: 900;
            animation: gentleFloat 6s ease-in-out infinite reverse;
        }

        .progress-bar {
            width: 300px;
            height: 4px;
            background: #222;
            margin: 20px 0;
            position: relative;
            box-shadow: 0 0 10px #000;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width 0.2s ease;
            box-shadow: 0 0 15px var(--primary);
        }

        .instructions {
            position: absolute;
            bottom: 100px;
            width: 100%;
            text-align: center;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 3px;
            z-index: 15;
            font-family: 'Orbitron', sans-serif;
            animation: fadeOut 5s ease-in-out forwards;
            animation-delay: 2s; 
            pointer-events: none;
        }

        @keyframes fadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; visibility: hidden; }
        }

        .pause-btn {
            position: absolute;
            top: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--primary);
            color: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            z-index: 25;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            pointer-events: auto;
            box-shadow: 0 0 10px var(--primary);
            transition: 0.3s;
        }
        
        .pause-btn:hover {
            background: var(--primary);
            color: #000;
            box-shadow: 0 0 20px var(--primary);
        }

        .stats-panel {
            position: absolute;
            top: 30px;
            left: 30px;
            background: rgba(0, 0, 0, 0.7);
            border-left: 3px solid var(--primary);
            padding: 10px 15px;
            font-size: 0.8rem;
            color: #ccc;
            z-index: 25;
            pointer-events: auto;
            font-family: 'Orbitron', monospace;
            text-align: left;
            backdrop-filter: blur(4px);
        }
        
        /* Custom File Upload Styling */
        .file-upload-label {
            display: inline-block;
            margin-top: 20px;
            padding: 10px 20px;
            border: 1px dashed #666;
            color: #888;
            cursor: pointer;
            font-size: 0.8rem;
            transition: 0.3s;
            font-family: 'Orbitron', sans-serif;
        }
        .file-upload-label:hover {
            border-color: var(--primary);
            color: var(--primary);
            box-shadow: 0 0 10px rgba(255, 0, 60, 0.2);
        }

        /* Mobile Controls */
        .mobile-controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 30;
        }

        .mobile-jump-area {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40%;
            pointer-events: auto;
            background: transparent;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .mobile-jump-indicator {
            background: rgba(255, 0, 60, 0.3);
            border: 2px solid rgba(255, 0, 60, 0.7);
            border-radius: 50%;
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 0.8rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            backdrop-filter: blur(5px);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.1); opacity: 0.9; }
            100% { transform: scale(1); opacity: 0.7; }
        }

        /* Responsive Styles */
        @media (max-width: 768px) {
            .title-text { font-size: 3.5rem !important; margin-bottom: 20px; }
            .score-display { font-size: 6rem !important; top: 8% !important; }
            .level-indicator { font-size: 1.2rem !important; bottom: 70px !important; letter-spacing: 4px !important; }
            .mystic-btn { padding: 12px 30px !important; font-size: 1rem !important; min-width: 220px !important; margin: 8px !important; }
            .instructions { bottom: 130px !important; font-size: 0.7rem !important; letter-spacing: 2px !important; }
            .stats-panel { top: 15px !important; left: 15px !important; font-size: 0.7rem !important; padding: 8px 12px !important; }
            .pause-btn { top: 15px !important; right: 15px !important; width: 45px !important; height: 45px !important; font-size: 1.2rem !important; }
            .progress-bar { width: 250px !important; }
            #gameOverScreen .title-text { font-size: 3rem !important; }
            #pauseScreen .title-text { font-size: 2.5rem !important; }
            #settingsScreen .title-text { font-size: 2rem !important; }
        }

        @media (max-width: 480px) {
            .title-text { font-size: 2.8rem !important; }
            .score-display { font-size: 5rem !important; top: 6% !important; }
            .level-indicator { font-size: 1rem !important; bottom: 60px !important; }
            .mystic-btn { min-width: 200px !important; padding: 10px 25px !important; font-size: 0.9rem !important; letter-spacing: 2px !important; }
            .instructions { font-size: 0.65rem !important; letter-spacing: 1.5px !important; bottom: 140px !important; }
            .progress-bar { width: 200px !important; }
        }

        @media (orientation: portrait) and (max-height: 700px) {
            .title-text { font-size: 2.5rem !important; }
            .score-display { font-size: 4.5rem !important; }
            .level-indicator { bottom: 50px !important; }
            .instructions { bottom: 100px !important; }
        }

        @media (orientation: landscape) {
            .title-text { font-size: 3rem !important; }
            .score-display { font-size: 4rem !important; top: 5% !important; }
            .level-indicator { bottom: 20px !important; font-size: 1rem !important; }
            .mystic-btn { padding: 8px 20px !important; margin: 5px !important; min-width: 180px !important; }
            .instructions { bottom: 70px !important; font-size: 0.6rem !important; }
            .mobile-jump-area { height: 50%; }
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .title-text { font-size: 2.2rem !important; }
            .score-display { font-size: 3rem !important; }
            .mystic-btn { padding: 6px 15px !important; font-size: 0.8rem !important; min-width: 150px !important; }
        }

        /* Safe area padding */
        @supports (padding: max(0px)) {
            .ui-layer {
                padding-left: max(20px, env(safe-area-inset-left));
                padding-right: max(20px, env(safe-area-inset-right));
                padding-top: max(20px, env(safe-area-inset-top));
                padding-bottom: max(20px, env(safe-area-inset-bottom));
            }
        }

        .loader {
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid var(--primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="scanlines"></div>
        <div class="vignette"></div>
        
        <div id="scoreUi" class="score-display">0</div>
        <div id="levelUi" class="level-indicator">INITIATION</div>
        
        <div id="mobileControls" class="mobile-controls hidden">
            <div class="mobile-jump-area">
                <div class="mobile-jump-indicator">TAP</div>
            </div>
        </div>
        
        <div id="startScreen" class="ui-layer" style="background-image: url('https://lh3.googleusercontent.com/d/1BXrXXd9TKSqCFNwvS-cJpNORbyvP6fkR=s0');">
            <h1 class="title-text">Sex Magick</h1>
            <p style="letter-spacing: 8px; color: #ff003c; margin-bottom: 40px; font-size: 1.1rem; text-shadow: 0 0 10px #ff003c; font-family: 'Cinzel Decorative', cursive;">Do Your Will Foo</p>
            
            <div id="loadingMsg">
                <div class="loader"></div>
                <p id="loadingText" style="letter-spacing: 4px; font-size: 0.9rem; margin-top: 15px; font-family: 'Cinzel Decorative';">CHARGING SIGIL...</p>
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill"></div>
                </div>
            </div>

            <div id="menuButtons" class="hidden">
                <button id="startBtn" class="mystic-btn">INVOKE</button>
                <button id="settingsBtn" class="mystic-btn">RITES</button>
                
                <label for="fileUpload" class="file-upload-label">
                    [ OPTIONAL: LOAD LOCAL MP3 ]
                </label>
                <input type="file" id="fileUpload" accept="audio/*" style="display:none;">
                <p id="trackName" style="margin-top: 5px; font-size: 0.6rem; color: #555;">SOURCE: GITHUB CDN</p>
            </div>
        </div>

        <div id="gameOverScreen" class="ui-layer hidden" style="background: rgba(0,0,0,0.85);">
            <h1 class="title-text" style="color: #ff003c; font-size: 4rem;">Good job foo</h1>
            <p style="font-size: 1.2rem; letter-spacing: 4px; margin-bottom: 20px; font-family: 'Cinzel Decorative';">RITUAL FAILED</p>
            <p class="text-xl mb-6 text-gray-300">WILL: <span id="finalScore" style="color: #fff; font-weight:bold; text-shadow: 0 0 10px #fff;">0</span></p>
            <p id="highScoreMsg" style="color: #ffd700; margin-bottom: 30px; font-size: 1rem; letter-spacing: 2px;"></p>
            <button id="restartBtn" class="mystic-btn">REINCARNATE</button>
            <button id="goMenuBtn" class="mystic-btn" style="margin-top: 10px; font-size: 1rem; border-color: #ffd700;">RETURN TO VOID</button>
        </div>

        <div id="pauseScreen" class="ui-layer hidden">
            <h1 class="title-text" style="font-size: 3.5rem; color: #ffd700;">MEDITATION</h1>
            <button id="resumeBtn" class="mystic-btn">RESUME</button>
            <button id="menuBtn" class="mystic-btn">ABORT</button>
        </div>

        <div id="settingsScreen" class="ui-layer hidden" style="background: rgba(0,0,0,0.9);">
            <h1 class="title-text" style="font-size: 2.5rem;">SACRED RITES</h1>
            <div style="width: 320px; margin: 20px 0; background: rgba(20,20,20,0.8); padding: 20px; border: 1px solid var(--primary);">
                <div style="display: flex; justify-content: space-between; margin: 15px 0; border-bottom: 1px solid #444; padding-bottom: 10px;">
                    <span>CHANT (MUSIC)</span>
                    <input type="checkbox" id="musicToggle" checked style="accent-color: var(--primary);">
                </div>
                <div style="display: flex; justify-content: space-between; margin: 15px 0; border-bottom: 1px solid #444; padding-bottom: 10px;">
                    <span>RESONANCE (SFX)</span>
                    <input type="checkbox" id="sfxToggle" checked style="accent-color: var(--primary);">
                </div>
                <div style="display: flex; justify-content: space-between; margin: 15px 0;">
                    <span>KUNDALINI (VIBE)</span>
                    <input type="checkbox" id="vibrationToggle" checked style="accent-color: var(--primary);">
                </div>
            </div>
            <button id="backBtn" class="mystic-btn">RETURN</button>
        </div>

        <button id="pauseBtn" class="pause-btn hidden">||</button>
        
        <div id="statsPanel" class="stats-panel">
            <div style="color: var(--primary); font-weight: bold; margin-bottom: 5px;">:: GNOSIS ::</div>
            FPS: <span id="fpsCounter" style="color: #fff;">0</span><br>
            AUDIO: <span id="audioStatus" style="color: #fff;">STANDBY</span>
        </div>

        <div id="instructions" class="instructions hidden">
            [ TAP / SPACE TO ASCEND ]
        </div>
    </div>

    <script>
        const CDN_PREFIX = "https://cdn.jsdelivr.net/gh/bookthief666/93-protocol-game-assets-@662f3d608769e9e945295ac00d668447d974dc5c/";

        const CONFIG = {
            DEBUG: true, 
            MENU_MUSIC: CDN_PREFIX + "iamerror%20-%20The%20Zelda%20Song%20(Hyr00l).mp3",
            GAME_PLAYLIST: [
                CDN_PREFIX + "iamerror%20-%20Hyr00l%20Rough.mp4",
                CDN_PREFIX + "bookthief%F0%9F%A5%80%20-%20booothief-%20All%20gay%F0%9F%98%87%202024-07-10%2001_11%20(1).m4a",
                CDN_PREFIX + "Vae!%20Puto%20Deus%20Fio!%20(3).mp3",
                CDN_PREFIX + "IAMERROR%20-%20The%20Iceclops%20Cometh.mp3",
                CDN_PREFIX + "Forest%20of%20Fellatio%20%5BTTn3kjGwXi0%5D.mp3",
                CDN_PREFIX + "LEX_LFL_80_wurli_loop_ate_bit_Cm.wav",
                CDN_PREFIX + "iamerror%20-%20The%20Zelda%20Song%20(Hyr00l).mp3"
            ],
            BASE_URL: "https://lh3.googleusercontent.com/d/",
            IMG_SUFFIX: "=s0",
            
            // SLOWER START SETTINGS:
            INITIAL_GAME_SPEED: 2.0, 
            SPEED_INCREASE_PER_LEVEL: 0.1, 
            PILLAR_SPAWN_RATE: 120,
            PILLAR_WIDTH: 45,
            PILLAR_GAP: 250, 
            PILLAR_GAP_DECREASE_PER_5_LEVELS: 8, 
            MIN_PILLAR_GAP: 180, 
            ORB_SPAWN_CHANCE: 0.5,
            PLAYER_JUMP_FORCE: -6.5,
            GRAVITY: 0.20,
            
            PLAYER_RADIUS: 16, 
            HITBOX_OFFSET: 4, 
            MOBILE_CONTROL_DEADZONE: 50,
        };
        const originalLevels = [
            { name: "MALKUTH", id: "1jI7bl3hsVOuzYf6u35L4bhHq5JUiBDa1" },
            { name: "YESOD", id: "1tHgxNvDO5md4z24hS81eTa9uva25mtr5" },
            { name: "HOD", id: "1Mtp6cP6lwGbPRhLWjQKKDijrLX53K4UR" },
            { name: "NETZACH", id: "1y1i5lxL1jVp37bIz1mtJh4-Puce-E5k0" },
            { name: "TIPHARETH", id: "12png0vOPyJC1Ab4Vffcw2R_K-yRw1sqj" },
            { name: "GEBURAH", id: "1le2Hox1ORxhL28fv7WujO0410vM6jUEJ" },
            { name: "CHESED", id: "1Gsq1xSx9ivfVEq6W2nCMrO-dOIMrSYrW" },
            { name: "DA'ATH", id: "1o601hrLi5RpuGL_kiVEoPXxXk2SCbM2z" },
            { name: "BINAH", id: "1iSYJfPsaYjA1rmRTsujLcn1Do-lBydF7" },
            { name: "CHOKMAH", id: "1PvOC62nv5HdsE1cuCF8RENY9Z8HTabn7" },
            { name: "KETHER", id: "1Ym_eyrXJEQUBA7Lg_2oUc6dQ-gy9yfGs" }
        ];
        const newImageIDs = [
            "1pJ5CUGyKXgkSgEREkKos1Kch5FmfUyxE", "1spT4HpO_4q9joE4x6bLjZQRlFTS9j-ie", "1YGzyjcjiCoPCLbYjJEiqT8USUhe4S6hM", "1ELjoJU7KDC88nUk_Vs57OKUG9oLl5E8N",
            "1faa2c3QFWhZ8UgvyZ_ZrlnyFsnsKRclm", "10W5oYkoqB9LC3YjvB_aozR0kG3hWaHka", "1l9Jdm0EQh8sgWh1W0wsXQCzrQM19Bfm9", "1BrHTF2dvfbRkyYfXAbPUiujwE1AJskY4",
            "1KqV8IYF7KDbmgHS3ph6eRQKl4uAAFG_u", "1sZ02UH_vb1xLaOvyETqptc5FuvOtVKd4", "1hLKOGYXCBemcIKt8OLEX4dHTn6bd88cr", "1g_DQeG6qldMBxHzZ82MOVoxk9APwb4NO",
            "1-SIvE5EZyUd7FKXJ7eyB4JCrtOpQoF18", "1S4y4YSCjxSb-b_U1BfMw_0PhabJ-METm", "1OL-kWl-TJNcZFPcsCAtynW2NWp-YYjGd", "1ApPgou40N2Q6GlNKNuyoQ2Gk5DqAfmw_",
            "1OeH1GMu2rDcwzdtWFZSB1WWe0OjkmxV0", "12Z92v9Mu9yNOnDTtK-bjMRZ8_2BAW2eW", "1Erf3DKxZpfbG57oGcUCjuHIhajsweLZz", "1qK22CJhJ1XgElL156uOQxYrucaRG16p0",
            "1euwdAWg-xQw7isR-JAiZ-krXQXOS8pi0", "1A3hT3mJibINtsr8CVxTmp71QsYgPB2JZ", "1QUVr-RK2kP7IIAuy0wX3pOZRQuyr-o-e", "1eF02YMyYBcgx7Ga20pXgoltzWXPYznfD",
            "1zx1vrrbuSA4xCFKXAHgXbkG1rX8PUPel", "1ds1iqXf90gy9PUFs80t4QOxamkJj0u1I", "14-t6dPPv5MeXe7LWPIp7Tjc8x4w5Vj2d", "1pUtIizMzVhjzB46dhah5mgz6Tr-vaSLO",
            "1ZOEkUW8q2s5zerS7BubYJU69RHk7_Zlo", "15ZHj0fLYu-4rEQy43BMJKDgXnnQ5FeyP", "1ZzgVT0O6XQzW3DUP4i1aoKd_DD5wV5LZ", "1rZHZM0bR_j6uiYZLS82J0BkbIfEUoXvY",
            "1CNrQ_EeMXQgHJGXxe7EHysQi_A0A9UE7", "1ubCqIg7ETOIsHGfBjQfVsRzjlZIpBP6E", "1pojzjR-uiQ0oTHRJxXXCW_w0hlJUCqyb", "1SnclBlH6sflhaTWzFhbcNedzNeh25-BV",
            "1thfc-9DnM4GhCi0zTbcX4MH-yaQEpomX", "1BXrXXd9TKSqCFNwvS-cJpNORbyvP6fkR", "1D1bOksatIt6Jw6Zq8Sbmhbq_GC_2EQHh", "1eP_Xnk80YnL3w3Q69wQmVo9_F0OaA3Wo",
            "1ARDOipcr0lB1GYf3gmhqlHXlpC23Q2JE", "1io39jfggXQl-OyvSFGIpgOtoIzHbml3M", "1o0rJmx3vEKITMx1ixP5iruOX2ujOT6VO", "1Irw61utgSGdip21OgTcYqz56LpWWS9fb",
            "19V2ObVoQn9R9bt1ZgMNEBJokaAjYdX_9", "1WWvLnkkPBN7Q0ZsGi16FL1anhPlti3Qd", "1HoYqC0SLc3nrSDnoW9KJ2-z8AnRWIz5M", "1oS0J3F-zh5H48-Qs5Mrm10dPR993kF-b",
            "1bRwsBEuZiAIZW_5f3WOZVI6-KVnCEslk", "1GLza2_RmR4c_KD_KGxbXPOoCAw9SITKl", "1uWFSChozQmHEnuJwXqiPNApXuAwPAzKS", "1t2hNBEudzIo19kuP8ksPY_cNetDdTd8P",
            "1KhMBL7a3NSggVerbyy53fQ-dLq11adwj", "1wgxalTR68YM7oIku8JYZYKtG50atEnG_", "1BceMgnHgVn9U_7EYnXQu9HDwEQY1UBa_", "14_iwYDQjp34-R_iby8QadKnI9m3zVnOu",
            "1cZ_ci9J80jnqCAdag8SQofYZw1dfsX3C", "15z3bGrCqUy8SQjX1dO5C1vlN3y4-soai", "10xAFw98B39Ou0SSeB4eWyoY2D_OLLPgz", "1CexZQw11p33u1-YA7JhPAkGV6NBCgd6e",
            "16t1EdHfHRpb7GmqNAfo2iKKm57qLfbKn", "12wQOhUztVCVEFV21fPDq-JXGi5zxdkeQ", "1-0u9JUH0oUHD1--5iaySxRpO_PuyxkH6", "1wnITY3i6XxOr1b3l6P0cT10LkEHQauO5"
        ].filter((value, index, self) => self.indexOf(value) === index);
        const esotericNames = [
            "KUNDALINI", "HIEROS GAMOS", "SACRED UNION", "RED TINCTURE", "WHITE GLUTEN", 
            "CUP OF BABALON", "BLOOD OF SAINTS", "CITY OF PYRAMIDS", "NIGHT OF PAN", 
            "HADIT'S FLAME", "NUIT'S EMBRACE", "LAW OF THELEMA", "LOVE UNDER WILL", 
            "GREAT WORK", "STONE OF WISE", "ELIXIR OF LIFE", "RED LION", "WHITE EAGLE",
            "ABRAHADABRA", "LASHTAL", "KA", "BA", "KHU", "SCARLET WOMAN", "THE BEAST",
            "AEON OF HORUS", "93", "AGAPE", "THELEMA", "VIA OVUM", "SPERMATOZOON",
            "HOMUNCULUS", "DIVINE EROS", "TANTRA", "YONI", "LINGAM", "O.T.O.", "A.'.A.'.",
            "STAR SAPPHIRE", "MASS OF PHOENIX", "LIBER AL", "RESH", "SAMEKH", "TZADDI"
        ];
        let MASTER_POOL = [...originalLevels];
        
        const palette = ["#ff003c", "#ff00ff", "#9d00ff", "#00f0ff", "#00ff9d", "#d4ff00", "#ff8800"];
        newImageIDs.forEach((id, index) => {
            const nameIndex = index % esotericNames.length;
            MASTER_POOL.push({
                name: esotericNames[nameIndex],
                id: id,
                color: "#000",
                accent: palette[index % palette.length],
                img: null,
                loaded: false
            });
        });
        const GameState = {
            START: 'start',
            LOADING: 'loading',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAME_OVER: 'gameover',
            SETTINGS: 'settings'
        };
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        const optimizedShadow = {
            apply(ctx, blur, color) {
                if (isMobile) {
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = 'transparent';
                } else {
                    ctx.shadowBlur = blur;
                    ctx.shadowColor = color;
                }
            },
            clear(ctx) {
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }
        };

        const GlitchFX = {
            active: false,
            duration: 0,
            intensity: 1,
            type: 'rgb',
            
            rgbSplit(ctx, intensity) {
                const offset = Math.floor(Math.random() * 3 * intensity);
                const rOffset = Math.random() > 0.5 ? offset : -offset;
                const gOffset = Math.random() > 0.5 ? offset : -offset;
                const bOffset = Math.random() > 0.5 ? offset : -offset;
                if (Math.random() > 0.3) return null;
                return {
                    rOffset, gOffset, bOffset,
                    draw: function(ctx, width, height) {
                        const imageData = ctx.getImageData(0, 0, width, height);
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = width;
                        tempCanvas.height = height;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.putImageData(imageData, 0, 0);
                        
                        ctx.save();
                        ctx.globalCompositeOperation = 'screen';
                        ctx.globalAlpha = 0.8;
                        ctx.drawImage(tempCanvas, rOffset, 0);
                        ctx.globalAlpha = 0.8;
                        ctx.drawImage(tempCanvas, 0, gOffset);
                        ctx.globalAlpha = 0.8;
                        ctx.drawImage(tempCanvas, bOffset, bOffset);
                        ctx.restore();
                    }
                };
            },
            
            staticEffect(ctx, intensity) {
                ctx.save();
                ctx.globalAlpha = 0.1 * intensity;
                for (let i = 0; i < 5; i++) { 
                    const x = Math.random() * ctx.canvas.width;
                    const y = Math.random() * ctx.canvas.height;
                    const size = Math.random() * 10 * intensity + 2;
                    ctx.fillStyle = Math.random() > 0.5 ? '#ff003c' : '#00ffff';
                    ctx.fillRect(x, y, size, 1);
                    if (Math.random() > 0.7) {
                        ctx.fillStyle = Math.random() > 0.5 ? '#ff00ff' : '#00ff9d';
                        ctx.fillRect(x, y + 2, 1, size);
                    }
                }
                ctx.restore();
            },
            
            scanlineDistort(ctx, intensity) {
                if (Math.random() > 0.5) return;
                ctx.save();
                ctx.globalAlpha = 0.05 * intensity;
                ctx.fillStyle = '#fff';
                const lineCount = Math.floor(3 * intensity);
                for (let i = 0; i < lineCount; i++) {
                    const y = Math.floor(Math.random() * ctx.canvas.height);
                    const height = Math.random() * 2 + 1;
                    const wave = Math.sin(Date.now() * 0.01 + i) * 10 * intensity;
                    ctx.fillRect(0, y, ctx.canvas.width, height);
                    ctx.fillRect(wave, y + 5, ctx.canvas.width, 1);
                }
                ctx.restore();
            },
            
            blockDisplace(ctx, intensity) {
                if (Math.random() > 0.7) return;
                ctx.save();
                ctx.globalAlpha = 0.3 * intensity;
                for (let i = 0; i < 2; i++) {
                    const x = Math.random() * ctx.canvas.width;
                    const y = Math.random() * ctx.canvas.height;
                    const width = Math.random() * 50 * intensity + 20;
                    const height = Math.random() * 50 * intensity + 20;
                    const offsetX = (Math.random() - 0.5) * 10 * intensity;
                    const offsetY = (Math.random() - 0.5) * 10 * intensity;
                    ctx.fillStyle = Math.random() > 0.5 ? '#ff003c' : '#00ffff';
                    ctx.fillRect(x + offsetX, y + offsetY, width, height);
                }
                ctx.restore();
            },
            
            apply(ctx, currentTime) {
                if (!this.active || this.duration <= 0) return;
                const progress = this.duration / 100;
                this.intensity = Math.min(1, progress * 2);
                if (Math.random() > 0.5) this.staticEffect(ctx, this.intensity);
                if (Math.random() > 0.6) this.scanlineDistort(ctx, this.intensity);
                if (Math.random() > 0.7) this.blockDisplace(ctx, this.intensity);
                if (Math.random() > 0.8) {
                    const rgbEffect = this.rgbSplit(ctx, this.intensity);
                    if (rgbEffect) rgbEffect.draw(ctx, ctx.canvas.width, ctx.canvas.height);
                }
                this.duration -= 16;
                if (this.duration <= 0) {
                    this.active = false;
                    this.intensity = 1;
                }
            },
            
            trigger(duration = 100, type = 'all') {
                this.active = true;
                this.duration = duration;
                this.type = type;
                this.intensity = 1;
            }
        };

        const SFX = {
            audioContext: null,
            init() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
            },
            playTone(freq, type, duration, vol, detune = 0) {
                if (!game?.settings?.sfx) return;
                if (!this.audioContext) this.init();
                if (this.audioContext.state === 'suspended') this.audioContext.resume();
                
                try {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    
                    osc.type = type;
                    osc.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                    osc.detune.setValueAtTime(detune, this.audioContext.currentTime);
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    gain.gain.setValueAtTime(vol, this.audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                    
                    osc.start();
                    osc.stop(this.audioContext.currentTime + duration);
                } catch(e){}
            },
            jump() { 
                this.playTone(400, 'square', 0.08, 0.1);
                this.playTone(600, 'sine', 0.05, 0.05, 100);
            },
            collect() { 
                this.playTone(800, 'sine', 0.2, 0.1);
                this.playTone(1200, 'triangle', 0.1, 0.05, 50);
            },
            crash() { 
                this.playTone(100, 'sawtooth', 0.5, 0.3);
                this.playTone(80, 'square', 0.3, 0.2, -100);
            },
            levelUp() { 
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.5);
                osc.connect(gain);
                gain.connect(this.audioContext.destination);
                gain.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                osc.start();
                osc.stop(this.audioContext.currentTime + 0.5);
            }
        };

        const Haptics = {
            jump() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([15]);
                }
            },
            collect() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([30, 20, 30]);
                }
            },
            crash() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([150, 30, 80, 30, 40]);
                }
            },
            levelUp() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([80, 20, 80, 20, 80]);
                }
            }
        };

        const AudioSys = {
            bgm: null,
            localBlobUrl: null,
            currentMode: 'none', 
            retryCount: 0,
            
            setStatus(msg) {
                const el = document.getElementById('audioStatus');
                if (el) {
                    el.textContent = msg;
                    el.style.color = '#fff';
                    setTimeout(() => el.style.color = 'var(--primary)', 200);
                }
            },

            init() {
                this.setupAudioElement(CONFIG.MENU_MUSIC);
                this.currentMode = 'menu';
                this.setStatus("MENU AUDIO RDY");
            },

            setupAudioElement(src) {
                if (this.bgm) {
                    this.bgm.pause();
                    this.bgm.src = "";
                    this.bgm.load();
                }
                this.bgm = new Audio();
                this.bgm.src = src;
                this.bgm.loop = true;
                this.bgm.volume = 0.8;
                this.bgm.preload = "auto";
                
                this.bgm.onwaiting = () => this.setStatus("BUFFERING...");
                this.bgm.onplaying = () => {
                    this.setStatus("PLAYING");
                    this.retryCount = 0;
                };
                
                this.bgm.onerror = (e) => {
                    console.warn("Audio error:", e);
                    this.setStatus("LOAD ERROR");
                };
            },

            loadLocalFile(file) {
                if (this.localBlobUrl) URL.revokeObjectURL(this.localBlobUrl);
                this.localBlobUrl = URL.createObjectURL(file);
                this.setupAudioElement(this.localBlobUrl);
                this.setStatus("FILE LOADED");
            },
            
            switchToGameMusic() {
                if (this.localBlobUrl) return;
                const randomIndex = Math.floor(Math.random() * CONFIG.GAME_PLAYLIST.length);
                const track = CONFIG.GAME_PLAYLIST[randomIndex];
                this.currentMode = 'game';
                this.setStatus("LOADING TRK " + (randomIndex + 1));
                this.setupAudioElement(track);
                this.play();
            },

            switchToMenuMusic() {
                if (this.localBlobUrl) return;
                this.currentMode = 'menu';
                this.setStatus("LOADING MENU");
                this.setupAudioElement(CONFIG.MENU_MUSIC);
            },
            
            play() {
                if (!this.bgm) return;
                const playPromise = this.bgm.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => this.setStatus("PLAYING")).catch(error => {
                        console.warn("Play failed:", error);
                        this.setStatus("AUTOPLAY BLOCK");
                    });
                }
            },
            
            pause() { if (this.bgm) { this.bgm.pause(); this.setStatus("PAUSED"); } },
            resume() { if (this.bgm && this.bgm.paused) { this.bgm.play(); this.setStatus("RESUMED"); } },
            stop() { if (this.bgm) { this.bgm.pause(); this.bgm.currentTime = 0; this.setStatus("STOPPED"); } }
        };

        const ALCHEMICAL_SYMBOLS = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.root = document.documentElement;
                
                this.state = GameState.START;
                this.currentLevelIdx = 0;
                this.frames = 0;
                this.score = 0;
                this.highScore = localStorage.getItem('93protocol_highscore') || 0;
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED;
                this.shake = 0;
                this.lastFrameTime = 0;
                this.fps = 0;
                this.isMobile = isMobile;
                this.aspectRatio = 16/9;
                this.baseWidth = 800;
                this.baseHeight = 450;
                this.scaleFactor = 1;
                this.glitchEffect = false;
                this.glitchTimer = 0;
                this.glitchDuration = 300;
                this.tunnelOffset = 0;
                this.tunnelSpeed = 0.5;
                this.hitStop = 0;
                this.screenFlash = null;
                this.backgroundParticles = [];
                
                this.player = null;
                this.particles = [];
                this.stars = [];
                this.obstacles = [];
                this.collectibles = [];
                this.gameLevels = []; 
                
                this.settings = { music: true, sfx: true, vibration: true };
                
                this.loadSettings();
                this.initEventListeners();
                this.resizeCanvas();
                this.preloadAllImages();
                this.createBackgroundParticles();
                
                AudioSys.init();
                SFX.init();
                this.randomizeMenuBackground();
            }
            
            randomizeMenuBackground() {
                if(newImageIDs.length > 0) {
                    const randomId = newImageIDs[Math.floor(Math.random() * newImageIDs.length)];
                    const url = CONFIG.BASE_URL + randomId + CONFIG.IMG_SUFFIX;
                    document.getElementById('startScreen').style.backgroundImage = `url('${url}')`;
                }
            }
            
            createBackgroundParticles() {
                for (let i = 0; i < 25; i++) { 
                    this.backgroundParticles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        z: Math.random() * 2 + 0.5,
                        size: Math.random() * 3 + 2,
                        speed: Math.random() * 0.5 + 0.1,
                        color: palette[Math.floor(Math.random() * palette.length)],
                        opacity: Math.random() * 0.4 + 0.1,
                        shape: Math.floor(Math.random() * 3) 
                    });
                }
            }
            
            triggerOrbGlitch() {
                GlitchFX.trigger(80, 'orb');
                this.screenFlash = { active: true, duration: 10, color: '#ffd700', intensity: 0.3 };
            }
            
            triggerLevelUpGlitch() {
                GlitchFX.trigger(150, 'level');
                this.screenFlash = { active: true, duration: 20, color: this.gameLevels[this.currentLevelIdx]?.accent || '#ff003c', intensity: 0.4 };
            }
            
            triggerDeathGlitch() {
                GlitchFX.trigger(200, 'death');
                this.screenFlash = { active: true, duration: 30, color: '#ff003c', intensity: 0.6 };
            }
            
            applyScreenFlash() {
                if (!this.screenFlash || !this.screenFlash.active) return;
                this.ctx.save();
                this.ctx.fillStyle = this.screenFlash.color;
                this.ctx.globalAlpha = this.screenFlash.intensity * (this.screenFlash.duration / 30);
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.restore();
                this.screenFlash.duration--;
                if (this.screenFlash.duration <= 0) {
                    this.screenFlash.active = false;
                }
            }
            
            initEventListeners() {
                document.getElementById('fileUpload').addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) AudioSys.loadLocalFile(file);
                });
                window.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && this.state === GameState.PLAYING) this.playerJump();
                    else if (e.code === 'Escape') this.togglePause();
                });
                window.addEventListener('mousedown', (e) => {
                    if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'LABEL' && this.state === GameState.PLAYING) this.playerJump();
                });
                window.addEventListener('touchstart', (e) => {
                    if (this.state === GameState.PLAYING) {
                        e.preventDefault();
                        const touchY = e.touches[0].clientY;
                        if (touchY > window.innerHeight * 0.6) {
                            this.playerJump();
                        }
                    }
                }, { passive: false });
                document.getElementById('startBtn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (this.settings.music) AudioSys.switchToGameMusic();
                    this.startGame();
                });
                document.getElementById('restartBtn').addEventListener('click', (e) => {
                     e.stopPropagation();
                     if (this.settings.music) AudioSys.switchToGameMusic();
                     this.restartGame();
                });
                document.getElementById('goMenuBtn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.returnToMenu();
                });
                document.getElementById('pauseBtn').addEventListener('click', (e) => { e.stopPropagation(); this.togglePause(); });
                document.getElementById('resumeBtn').addEventListener('click', (e) => { e.stopPropagation(); this.togglePause(); });
                document.getElementById('menuBtn').addEventListener('click', (e) => { e.stopPropagation(); this.returnToMenu(); });
                document.getElementById('settingsBtn').addEventListener('click', (e) => { e.stopPropagation(); this.showSettings(); });
                document.getElementById('backBtn').addEventListener('click', (e) => { e.stopPropagation(); this.hideSettings(); });
                
                document.getElementById('musicToggle').addEventListener('change', (e) => {
                    this.settings.music = e.target.checked;
                    this.saveSettings();
                    if (!this.settings.music) AudioSys.stop();
                    else if (this.state === GameState.PLAYING) AudioSys.play();
                });
                document.getElementById('sfxToggle').addEventListener('change', (e) => {
                    this.settings.sfx = e.target.checked;
                    this.saveSettings();
                });
                document.getElementById('vibrationToggle').addEventListener('change', (e) => {
                    this.settings.vibration = e.target.checked;
                    this.saveSettings();
                });
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            loadSettings() {
                const saved = localStorage.getItem('93protocol_settings');
                if (saved) this.settings = { ...this.settings, ...JSON.parse(saved) };
                document.getElementById('musicToggle').checked = this.settings.music;
                document.getElementById('sfxToggle').checked = this.settings.sfx;
                document.getElementById('vibrationToggle').checked = this.settings.vibration;
            }
            
            saveSettings() { localStorage.setItem('93protocol_settings', JSON.stringify(this.settings));
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.calculateScaleFactor();
                this.adjustForScreenSize();
            }
            
            calculateScaleFactor() {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const targetRatio = 16/9;
                const currentRatio = width/height;
                if (currentRatio > targetRatio) {
                    this.scaleFactor = height / this.baseHeight;
                } else {
                    this.scaleFactor = width / this.baseWidth;
                }
                
                this.scaleFactor = Math.max(0.6, Math.min(this.scaleFactor, 1.5));
            }
            
            adjustForScreenSize() {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const isPortrait = height > width;
                
                let baseGap = CONFIG.PILLAR_GAP; // Default 250
                
                // ADAPTIVE DIFFICULTY FOR PORTRAIT/MOBILE
                if (isPortrait) {
                    baseGap = 290; // Wider gap for narrow screens
                    CONFIG.PLAYER_RADIUS = 13; // Smaller player
                } else {
                    baseGap = 250;
                    CONFIG.PLAYER_RADIUS = 16;
                }
                
                // Height based adjustments
                if (height < 600) {
                    baseGap = Math.min(baseGap, 220); 
                } 
                
                this.currentBaseGap = baseGap;
                
                // Update existing player if game is running
                if (this.player) {
                    this.player.r = CONFIG.PLAYER_RADIUS;
                }
            }
            
            preloadAllImages() {
                const progressFill = document.getElementById('progressFill');
                const loadingText = document.getElementById('loadingText');
                let loadedCount = 0;
                
                const failsafe = setTimeout(() => {
                    if (loadedCount < MASTER_POOL.length) {
                        console.warn("Loading timed out. Forcing start.");
                        this.finishLoading();
                    }
                }, 5000);
                MASTER_POOL.forEach(lvl => {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.onload = () => {
                        lvl.img = img;
                        lvl.loaded = true;
                        loadedCount++;
                        const percent = Math.floor((loadedCount / MASTER_POOL.length) * 100);
                        progressFill.style.width = `${percent}%`;
                        loadingText.innerText = `CHARGING SIGIL... ${loadedCount}/${MASTER_POOL.length}`;
                        if (loadedCount >= MASTER_POOL.length) {
                            clearTimeout(failsafe);
                            this.finishLoading();
                        }
                    };
                    img.onerror = () => {
                        console.warn(`Failed to load image: ${lvl.id}`);
                        loadedCount++;
                        if (loadedCount >= MASTER_POOL.length) {
                            clearTimeout(failsafe);
                            this.finishLoading();
                        }
                    };
                    img.src = CONFIG.BASE_URL + lvl.id + CONFIG.IMG_SUFFIX;
                });
            }
            
            finishLoading() {
                setTimeout(() => {
                    document.getElementById('loadingMsg').classList.add('hidden');
                    document.getElementById('menuButtons').classList.remove('hidden');
                }, 500);
            }
            
            prepareLevels() {
                let shuffled = [...MASTER_POOL];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                this.gameLevels = shuffled.map((lvl, index) => {
                    return { ...lvl, threshold: index * 5 };
                });
            }

            startGame() {
                this.prepareLevels();
                this.state = GameState.PLAYING;
                document.getElementById('startScreen').classList.add('hidden');
                document.getElementById('scoreUi').classList.remove('hidden');
                document.getElementById('pauseBtn').classList.remove('hidden');
                document.getElementById('instructions').classList.remove('hidden');
                
                if (this.isMobile) {
                    document.getElementById('mobileControls').classList.remove('hidden');
                    setTimeout(() => {
                        document.getElementById('mobileControls').classList.add('hidden');
                    }, 5000);
                }
                
                if (CONFIG.DEBUG) document.getElementById('statsPanel').classList.remove('hidden');
                this.initGame();
                this.gameLoop();
            }
            
            initGame() {
                this.player = new Player();
                this.obstacles = [];
                this.collectibles = [];
                this.particles = [];
                this.stars = [];
                for (let i = 0; i < 40; i++) this.stars.push(new Star());
                this.score = 0;
                this.currentLevelIdx = 0;
                this.frames = 0;
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED;
                this.shake = 0;
                this.tunnelOffset = 0;
                this.hitStop = 0;
                document.getElementById('scoreUi').innerText = "0";
                this.applyLevel();
            }
            
            applyLevel() {
                if (this.currentLevelIdx >= this.gameLevels.length) return;
                const l = this.gameLevels[this.currentLevelIdx];
                document.getElementById('levelUi').innerText = l.name;
                document.getElementById('levelUi').style.color = l.accent;
                document.getElementById('levelUi').style.textShadow = `0 0 15px ${l.accent}`;
                this.root.style.setProperty('--primary', l.accent);
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED + (this.currentLevelIdx * CONFIG.SPEED_INCREASE_PER_LEVEL);
                
                if (this.currentLevelIdx > 0) {
                    this.triggerGlitchEffect();
                    Haptics.levelUp();
                    if (this.settings.sfx) SFX.levelUp();
                }
            }
            
            triggerGlitchEffect() {
                this.glitchEffect = true;
                this.glitchTimer = this.glitchDuration;
            }
            
            applyGlitchEffect() {
                if (!this.glitchEffect) return;
                const ctx = this.ctx;
                const intensity = this.glitchTimer / this.glitchDuration;
                if (Math.random() > 0.7) {
                    const shiftX = Math.floor(Math.random() * 10 * intensity) - 5;
                    const shiftY = Math.floor(Math.random() * 10 * intensity) - 5;
                    ctx.save();
                    ctx.translate(shiftX, shiftY);
                    ctx.restore();
                }
                
                if (Math.random() > 0.8) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fillRect(0, Math.floor(Math.random() * this.canvas.height), this.canvas.width, 1);
                }
                
                this.glitchTimer -= 16;
                if (this.glitchTimer <= 0) {
                    this.glitchEffect = false;
                }
            }
            
            getCurrentGap() {
                const baseGap = this.currentBaseGap || CONFIG.PILLAR_GAP;
                const levelsCompleted = Math.floor(this.currentLevelIdx / 5);
                const gapReduction = levelsCompleted * CONFIG.PILLAR_GAP_DECREASE_PER_5_LEVELS;
                const calculatedGap = Math.max(CONFIG.MIN_PILLAR_GAP, baseGap - gapReduction);
                return calculatedGap;
            }
            
            checkLevel() {
                const nextIdx = this.currentLevelIdx + 1;
                if (nextIdx >= this.gameLevels.length) return;
                const next = this.gameLevels[nextIdx];
                if (this.score >= next.threshold) {
                    this.currentLevelIdx++;
                    this.applyLevel();
                    this.shake = 12;
                    this.hitStop = 3;
                    this.triggerLevelUpGlitch();
                    for (let i = 0; i < 30; i++) {
                        this.particles.push(new Particle(
                            this.canvas.width / 2, this.canvas.height / 2, 
                            this.gameLevels[this.currentLevelIdx].accent, 12,
                            Math.random() > 0.5 ? 'hexagram' : 'triangle'
                        ));
                    }
                    if (this.settings.sfx) SFX.levelUp();
                    Haptics.levelUp();
                }
            }
            
            playerJump() {
                if (this.state === GameState.PLAYING) {
                    this.player.jump();
                    Haptics.jump();
                    GlitchFX.trigger(50, 'rgb');
                }
            }
            
            togglePause() {
                if (this.state === GameState.PLAYING) {
                    this.state = GameState.PAUSED;
                    document.getElementById('pauseScreen').classList.remove('hidden');
                    AudioSys.pause();
                } else if (this.state === GameState.PAUSED) {
                    this.state = GameState.PLAYING;
                    document.getElementById('pauseScreen').classList.add('hidden');
                    AudioSys.resume();
                    this.gameLoop();
                }
            }
            
            showSettings() {
                document.getElementById('startScreen').classList.add('hidden');
                document.getElementById('settingsScreen').classList.remove('hidden');
                this.state = GameState.SETTINGS;
            }
            
            hideSettings() {
                document.getElementById('settingsScreen').classList.add('hidden');
                document.getElementById('startScreen').classList.remove('hidden');
                this.state = GameState.START;
            }
            
            returnToMenu() {
                this.state = GameState.START;
                document.getElementById('gameOverScreen').classList.add('hidden');
                document.getElementById('pauseScreen').classList.add('hidden');
                document.getElementById('startScreen').classList.remove('hidden');
                document.getElementById('scoreUi').classList.add('hidden');
                document.getElementById('pauseBtn').classList.add('hidden');
                document.getElementById('instructions').classList.add('hidden');
                document.getElementById('statsPanel').classList.add('hidden');
                document.getElementById('mobileControls').classList.add('hidden');
                this.randomizeMenuBackground();
                if (this.settings.music) AudioSys.switchToMenuMusic();
            }
            
            gameOver() {
                if (this.state === GameState.GAME_OVER) return;
                this.state = GameState.GAME_OVER;
                this.shake = 15;
                this.triggerDeathGlitch();
                if (this.settings.sfx) SFX.crash();
                Haptics.crash();
                
                for (let i = 0; i < 25; i++) {
                    this.particles.push(new Particle(
                        this.player.x, this.player.y,
                        '#ff003c', 10,
                        Math.random() > 0.3 ? 'hexagram' : 'triangle'
                    ));
                }
                
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('93protocol_highscore', this.highScore);
                    document.getElementById('highScoreMsg').textContent = "NEW GNOSIS ATTAINED";
                } else {
                    document.getElementById('highScoreMsg').textContent = `BEST: ${this.highScore}`;
                }
                AudioSys.stop();
                document.getElementById('finalScore').innerText = this.score;
                document.getElementById('scoreUi').classList.add('hidden');
                document.getElementById('pauseBtn').classList.add('hidden');
                document.getElementById('instructions').classList.add('hidden');
                document.getElementById('statsPanel').classList.add('hidden');
                document.getElementById('mobileControls').classList.add('hidden');
                document.getElementById('gameOverScreen').classList.remove('hidden');
            }
            
            restartGame() {
                this.state = GameState.PLAYING;
                this.prepareLevels();
                document.getElementById('gameOverScreen').classList.add('hidden');
                document.getElementById('scoreUi').classList.remove('hidden');
                document.getElementById('pauseBtn').classList.remove('hidden');
                document.getElementById('instructions').classList.remove('hidden');
                if (this.isMobile) {
                    document.getElementById('mobileControls').classList.remove('hidden');
                    setTimeout(() => {
                        document.getElementById('mobileControls').classList.add('hidden');
                    }, 5000);
                }
                if (CONFIG.DEBUG) document.getElementById('statsPanel').classList.remove('hidden');
                this.initGame();
                this.gameLoop();
            }
            
            gameLoop(currentTime = 0) {
                if (this.state !== GameState.PLAYING) return;
                if (this.lastFrameTime) {
                    this.fps = Math.round(1000 / (currentTime - this.lastFrameTime));
                    if (CONFIG.DEBUG) document.getElementById('fpsCounter').textContent = this.fps;
                }
                this.lastFrameTime = currentTime;
                
                if (this.hitStop > 0) {
                    this.hitStop--;
                    this.drawScene(currentTime);
                    requestAnimationFrame((time) => this.gameLoop(time));
                    return;
                }

                this.frames++;
                
                if (Math.random() > 0.995 && this.frames % 60 === 0) {
                    GlitchFX.trigger(30, 'random');
                }
                
                this.tunnelOffset += this.tunnelSpeed * (1 + this.gameSpeed * 0.1);
                
                this.updateGameObjects();
                this.drawScene(currentTime);
                
                requestAnimationFrame((time) => this.gameLoop(time));
            }

            drawScene(currentTime) {
                const lvl = this.gameLevels[this.currentLevelIdx];
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawHyperspaceTunnel(lvl);
                GlitchFX.apply(this.ctx, currentTime);
                this.applyScreenFlash();
                if (this.glitchEffect) {
                    this.applyGlitchEffect();
                }
                this.ctx.save();
                if (this.shake > 0) {
                    this.ctx.translate((Math.random() - 0.5) * this.shake, (Math.random() - 0.5) * this.shake);
                    this.shake *= 0.9;
                }
                this.drawGameObjects();
                this.ctx.restore();
            }
            
            drawHyperspaceTunnel(lvl) {
                const ctx = this.ctx;
                const cx = this.canvas.width / 2;
                const cy = this.canvas.height / 2;
                const maxRadius = Math.max(this.canvas.width, this.canvas.height) * 0.8;
                
                const breath = (Math.sin(Date.now() * 0.002 * (1 + this.gameSpeed * 0.1)) + 1) * 0.5;
                
                ctx.strokeStyle = lvl.accent;
                ctx.lineWidth = 1.5;
                optimizedShadow.apply(ctx, 15, lvl.accent);
                
                const baseRotation = this.frames * 0.005;

                for (let i = 0; i < 8; i++) {
                    const progress = ((this.tunnelOffset + i * 60) % 300) / 300;
                    const radius = progress * maxRadius;
                    if (radius < 50) continue;
                    ctx.globalAlpha = (1 - progress * 0.8) * (0.8 + breath * 0.2);
                    ctx.save();
                    ctx.translate(cx, cy);
                    ctx.rotate(baseRotation + (i * 0.1)); 
                    ctx.beginPath();
                    for(let k = 0; k < 5; k++) {
                        const angle = (k * 4 * Math.PI / 5) - (Math.PI / 2); 
                        const px = Math.cos(angle) * radius;
                        const py = Math.sin(angle) * radius;
                        if(k===0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                }
                
                optimizedShadow.clear(ctx);
                ctx.globalAlpha = 1;
                
                if (Math.random() > 0.95 && this.frames % 30 === 0) {
                    ctx.save();
                    ctx.globalAlpha = 0.05;
                    ctx.fillStyle = lvl.accent;
                    const y = Math.random() * this.canvas.height;
                    ctx.fillRect(0, y, this.canvas.width, 1);
                    ctx.restore();
                }
                
                this.backgroundParticles.forEach(p => {
                    p.y += p.speed * (1 + this.gameSpeed * 0.1);
                    if (p.y > this.canvas.height) { 
                        p.y = 0; 
                        p.x = Math.random() * this.canvas.width;
                        p.shape = Math.floor(Math.random() * 3);
                    }
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.opacity;
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(this.frames * 0.02);
                    if (p.shape === 0) { 
                        ctx.beginPath();
                        ctx.moveTo(0, -p.size);
                        ctx.lineTo(p.size, p.size);
                        ctx.lineTo(-p.size, p.size);
                        ctx.fill();
                    } else if (p.shape === 1) { 
                        ctx.beginPath();
                        ctx.moveTo(0, -p.size);
                        ctx.lineTo(p.size, 0);
                        ctx.lineTo(0, p.size);
                        ctx.lineTo(-p.size, 0);
                        ctx.fill();
                    } else { 
                        ctx.fillRect(-p.size/2, -p.size*1.5, p.size, p.size*3);
                        ctx.fillRect(-p.size*1.5, -p.size/2, p.size*3, p.size);
                    }
                    ctx.restore();
                });
                ctx.globalAlpha = 1;
                
                ctx.globalAlpha = 0.6;
                if (lvl.loaded && lvl.img && lvl.img.complete) {
                    try {
                        const img = lvl.img;
                        const canvasRatio = this.canvas.width / this.canvas.height;
                        const imgRatio = img.width / img.height;
                        let drawWidth, drawHeight, drawX, drawY;
                        if (canvasRatio > imgRatio) {
                            drawHeight = this.canvas.height;
                            drawWidth = img.width * (drawHeight / img.height);
                            drawX = (this.canvas.width - drawWidth) / 2;
                            drawY = 0;
                        } else {
                            drawWidth = this.canvas.width;
                            drawHeight = img.height * (drawWidth / img.width);
                            drawX = 0;
                            drawY = (this.canvas.height - drawHeight) / 2;
                        }
                        ctx.filter = 'blur(1px)';
                        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                        ctx.filter = 'none';
                    } catch (e) {}
                }
                ctx.globalAlpha = 1.0;
                
                // Draw falling stars (Symbols)
                this.stars.forEach(s => {
                    s.update();
                    s.draw(this.ctx);
                });
            }
            
            updateGameObjects() {
                const currentGap = this.getCurrentGap();
                if (this.frames % Math.floor(CONFIG.PILLAR_SPAWN_RATE / (1 + this.gameSpeed * 0.05)) === 0) {
                    const p = new Pillar(this.currentLevelIdx, currentGap);
                    this.obstacles.push(p);
                    if (Math.random() > (1 - CONFIG.ORB_SPAWN_CHANCE)) {
                        this.collectibles.push(new Orb(p.x + p.w / 2, p.top + p.gap / 2));
                    }
                }
                
                this.obstacles.forEach((o, i) => {
                    o.update(this.gameSpeed);
                    const hitboxReduction = CONFIG.HITBOX_OFFSET;
                    const pLeft = this.player.x - this.player.r + hitboxReduction;
                    const pRight = this.player.x + this.player.r - hitboxReduction;
                    const pTop = this.player.y - this.player.r + hitboxReduction;
                    const pBottom = this.player.y + this.player.r - hitboxReduction;
                    const pillarLeft = o.x;
                    const pillarRight = o.x + o.w;
                    const topPillarBottom = o.top;
                    const topPillarTop = 0;
                    const bottomPillarTop = o.top + o.gap;
                    const bottomPillarBottom = this.canvas.height;
                    const horizontalOverlap = pRight > pillarLeft && pLeft < pillarRight;
                    const hittingTopPillar = horizontalOverlap && pBottom > topPillarTop && pTop < topPillarBottom;
                    const hittingBottomPillar = horizontalOverlap && pTop < bottomPillarBottom && pBottom > bottomPillarTop;
                    if (hittingTopPillar || hittingBottomPillar) {
                        this.gameOver();
                    }
                    if (!o.marked && o.x + o.w < this.player.x) {
                        this.score++;
                        o.marked = true;
                        document.getElementById('scoreUi').innerText = this.score;
                        this.checkLevel();
                    }
                    if (o.x < -100) this.obstacles.splice(i, 1);
                });
                
                this.collectibles.forEach((c, i) => {
                    c.update(this.gameSpeed);
                    const dist = Math.hypot(this.player.x - c.x, this.player.y - c.y);
                    if (dist < this.player.r + c.r && !c.collected) {
                        this.score += 5;
                        document.getElementById('scoreUi').innerText = this.score;
                        c.collected = true;
                        this.triggerOrbGlitch();
                        this.hitStop = 3;
                        for (let k = 0; k < 20; k++) {
                            this.particles.push(new Particle(
                                c.x, c.y, 
                                '#ffd700', 8,
                                Math.random() > 0.6 ? 'hexagram' : 
                                Math.random() > 0.3 ? 'triangle' : 'diamond'
                            ));
                        }
                        if (this.settings.sfx) SFX.collect();
                        Haptics.collect();
                        this.collectibles.splice(i, 1);
                        this.checkLevel();
                    }
                    if (c.x < -50) this.collectibles.splice(i, 1);
                });
                
                this.player.update();
                
                this.particles.forEach((p, i) => {
                    p.update();
                    if (p.life <= 0) this.particles.splice(i, 1);
                });
            }
            
            drawGameObjects() {
                const currentLvlConfig = this.gameLevels[this.currentLevelIdx];
                this.obstacles.forEach(o => o.draw(this.ctx, currentLvlConfig));
                this.collectibles.forEach(c => c.draw(this.ctx));
                this.player.draw(this.ctx, currentLvlConfig);
                this.particles.forEach(p => p.draw(this.ctx));
            }
        }

        class Player {
            constructor() {
                this.x = window.innerWidth * 0.25;
                this.y = window.innerHeight / 2;
                this.vy = 0;
                this.r = CONFIG.PLAYER_RADIUS;
                this.rot = 0;
                this.trail = [];
                this.trailLength = game.isMobile ? 8 : 12;
                this.jumpCooldown = 0;
                this.scaleX = 1;
                this.scaleY = 1;
            }
            
            update() {
                this.vy += CONFIG.GRAVITY;
                this.y += this.vy;
                this.rot += 0.03;
                
                const stretch = Math.min(Math.abs(this.vy) * 0.04, 0.3);
                if (this.vy < 0) { 
                    this.scaleY = 1 + stretch;
                    this.scaleX = 1 - stretch * 0.5;
                } else { 
                    this.scaleY = 1 - stretch * 0.5;
                    this.scaleX = 1 + stretch;
                }

                if (this.y > window.innerHeight - this.r * 1.5) {
                    game.gameOver();
                }
                if (this.y < this.r * 1.5) { 
                    this.y = this.r * 1.5;
                    this.vy = 0; 
                }
                
                if (this.jumpCooldown > 0) {
                    this.jumpCooldown--;
                }
                
                if (game.frames % 2 === 0) {
                    this.trail.unshift({
                        x: this.x, 
                        y: this.y, 
                        r: this.r, 
                        life: 1.0,
                        rot: this.rot,
                        scaleX: this.scaleX,
                        scaleY: this.scaleY
                    });
                    if (this.trail.length > this.trailLength) this.trail.pop();
                }
                
                this.trail.forEach(t => t.life -= 0.05);
            }
            
            draw(ctx, conf) {
                const hue = (game.frames * 2) % 360;
                const strokeColor = `hsl(${hue}, 100%, 60%)`;
                const shadowColor = `hsl(${hue}, 100%, 50%)`;
                this.trail.forEach((t, i) => {
                    if (t.life > 0) {
                        ctx.save();
                        ctx.globalAlpha = t.life * 0.6;
                        ctx.translate(t.x, t.y);
                        ctx.scale(t.scaleX, t.scaleY);
                        ctx.rotate(t.rot + (this.vy * 0.05));
                        
                        const trailR = t.r * 0.7 * t.life;
                        const points = [];
                        for (let j = 0; j < 6; j++) {
                            const angle = (j * 60 - 90) * Math.PI / 180;
                            points.push({ 
                                x: Math.cos(angle) * trailR, 
                                y: Math.sin(angle) * trailR 
                            });
                        }
                        
                        optimizedShadow.apply(ctx, 20 * t.life, shadowColor);
                        ctx.strokeStyle = strokeColor;
                        ctx.lineWidth = 2 * t.life;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';

                        ctx.beginPath();
                        ctx.moveTo(points[0].x, points[0].y);
                        ctx.lineTo(points[2].x, points[2].y);
                        ctx.lineTo(points[5].x, points[5].y);
                        ctx.lineTo(points[3].x, points[3].y);
                        ctx.lineTo(points[1].x, points[1].y);
                        ctx.lineTo(points[4].x, points[4].y);
                        ctx.lineTo(points[0].x, points[0].y);
                        ctx.stroke();
                        
                        if (game.isMobile) {
                            ctx.lineWidth = 6 * t.life;
                            ctx.globalAlpha = t.life * 0.2;
                            ctx.stroke();
                        }
                        
                        ctx.restore();
                    }
                });
                ctx.globalAlpha = 1.0;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.scaleX, this.scaleY);
                ctx.rotate(this.rot + (this.vy * 0.05));
                
                const r = this.r * 1.2;
                const points = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (i * 60 - 90) * Math.PI / 180;
                    points.push({ x: Math.cos(angle) * r, y: Math.sin(angle) * r });
                }
                
                optimizedShadow.apply(ctx, 25, shadowColor);
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                ctx.lineTo(points[2].x, points[2].y);
                ctx.lineTo(points[5].x, points[5].y);
                ctx.lineTo(points[3].x, points[3].y);
                ctx.lineTo(points[1].x, points[1].y);
                ctx.lineTo(points[4].x, points[4].y);
                ctx.lineTo(points[0].x, points[0].y);
                ctx.stroke();
                
                if (game.isMobile) {
                    ctx.save();
                    ctx.strokeStyle = shadowColor;
                    ctx.lineWidth = 8;
                    ctx.globalAlpha = 0.3;
                    ctx.stroke();
                    ctx.restore();
                }

                const pulse = Math.sin(game.frames * 0.1) * 0.5 + 1;
                ctx.fillStyle = "#fff";
                optimizedShadow.apply(ctx, 40 * pulse, "#fff");
                ctx.beginPath();
                ctx.arc(0, 0, 3 * pulse, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
            
            jump() {
                if (this.jumpCooldown > 0) return;
                this.vy = CONFIG.PLAYER_JUMP_FORCE;
                this.jumpCooldown = game.isMobile ? 8 : 5;
                if (Math.random() > 0.7) {
                    GlitchFX.trigger(40, 'jump');
                }
                
                for (let i = 0; i < (game.isMobile ? 10 : 12); i++) {
                    const type = Math.random() > 0.7 ? 'hexagram' : Math.random() > 0.4 ? 'triangle' : 'circle';
                    game.particles.push(new Particle(
                        this.x, this.y, '#fff', 3, type
                    ));
                }
                
                if (game.settings.sfx) SFX.jump();
                Haptics.jump();
                GlitchFX.trigger(50, 'rgb');
            }
        }

        class Pillar {
            constructor(lvlIndex, currentGap) {
                this.x = window.innerWidth;
                this.w = CONFIG.PILLAR_WIDTH;
                this.gap = currentGap;
                const maxTop = window.innerHeight - this.gap - 50;
                const minTop = 30;
                this.top = Math.random() * (maxTop - minTop) + minTop;
                this.marked = false;
                this.lvl = lvlIndex;
                this.rotation = Math.random() * Math.PI * 2;
                this.innerPattern = Math.floor(Math.random() * 3);
                this.pulse = 0;
                this.hasWarning = game.isMobile && Math.random() > 0.5;
                this.warningAlpha = 1;
            }
            
            update(speed) { 
                this.x -= speed;
                this.pulse += 0.05;
                this.rotation += 0.005;
                if (this.hasWarning) {
                    this.warningAlpha -= 0.01;
                }
            }
            
            draw(ctx, conf) {
                const hue = (game.frames * 0.5 + this.x * 0.1) % 360;
                const mainColor = `hsl(${hue}, 100%, 60%)`;
                const innerColor = `hsl(${(hue + 60) % 360}, 100%, 70%)`;
                const glowColor = `hsl(${hue}, 100%, 50%)`;
                
                if (this.hasWarning && this.x < window.innerWidth * 0.7 && this.warningAlpha > 0) {
                    ctx.save();
                    ctx.globalAlpha = this.warningAlpha * 0.3;
                    ctx.fillStyle = '#ff003c';
                    ctx.fillRect(this.x - 10, 0, this.w + 20, window.innerHeight);
                    ctx.restore();
                }
                
                ctx.save();
                ctx.translate(this.x + this.w/2, 0);
                
                optimizedShadow.apply(ctx, 30, glowColor);
                ctx.strokeStyle = mainColor;
                ctx.lineWidth = 4;
                ctx.fillStyle = "rgba(0,0,0,0.7)";
                const topHeight = this.top + 10;
                ctx.beginPath();
                ctx.moveTo(-this.w/2, -10);
                ctx.lineTo(this.w/2, -10);
                
                const jagCount = 5;
                for (let i = 0; i <= jagCount; i++) {
                    const x = this.w/2 - (i * this.w/jagCount);
                    const y = -10 + (i % 2 === 0 ? 8 : -4);
                    ctx.lineTo(x, y);
                }
                
                ctx.lineTo(-this.w/2, topHeight);
                ctx.lineTo(-this.w/2, -10);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                if (game.isMobile) {
                    ctx.save();
                    ctx.lineWidth = 10;
                    ctx.globalAlpha = 0.2;
                    ctx.stroke();
                    ctx.restore();
                }
                
                ctx.save();
                ctx.translate(0, topHeight/2);
                ctx.rotate(this.rotation);
                ctx.globalAlpha = 0.4;
                ctx.strokeStyle = innerColor;
                ctx.lineWidth = 1.5;
                optimizedShadow.apply(ctx, 15, innerColor);
                
                if (this.innerPattern === 0) {
                    const size = Math.min(this.w, topHeight) * 0.3;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = Math.cos(angle) * size;
                        const y = Math.sin(angle) * size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                } else if (this.innerPattern === 1) {
                    const size = Math.min(this.w, topHeight) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size * 0.866, size * 0.5);
                    ctx.lineTo(-size * 0.866, size * 0.5);
                    ctx.closePath();
                    ctx.stroke();
                } else {
                    const size = Math.min(this.w, topHeight) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(-size, 0);
                    ctx.lineTo(size, 0);
                    ctx.moveTo(0, -size);
                    ctx.lineTo(0, size);
                    ctx.stroke();
                }
                ctx.restore();
                const botY = this.top + this.gap;
                const botHeight = window.innerHeight - botY + 10;
                
                ctx.beginPath();
                ctx.moveTo(-this.w/2, botY);
                ctx.lineTo(this.w/2, botY);
                for (let i = 0; i <= jagCount; i++) {
                    const x = this.w/2 - (i * this.w/jagCount);
                    const y = botY + (i % 2 === 0 ? -4 : 8);
                    ctx.lineTo(x, y);
                }
                
                ctx.lineTo(this.w/2, botY + botHeight);
                ctx.lineTo(-this.w/2, botY + botHeight);
                ctx.lineTo(-this.w/2, botY);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                if (game.isMobile) {
                    ctx.save();
                    ctx.lineWidth = 10;
                    ctx.globalAlpha = 0.2;
                    ctx.stroke();
                    ctx.restore();
                }
                
                ctx.save();
                ctx.translate(0, botY + botHeight/2);
                ctx.rotate(-this.rotation);
                ctx.globalAlpha = 0.4;
                ctx.strokeStyle = innerColor;
                ctx.lineWidth = 1.5;
                
                if (this.innerPattern === 0) {
                    const size = Math.min(this.w, botHeight) * 0.3;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = Math.cos(angle) * size;
                        const y = Math.sin(angle) * size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                } else if (this.innerPattern === 1) {
                    const size = Math.min(this.w, botHeight) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size * 0.866, size * 0.5);
                    ctx.lineTo(-size * 0.866, size * 0.5);
                    ctx.closePath();
                    ctx.stroke();
                } else {
                    const size = Math.min(this.w, botHeight) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(-size, 0);
                    ctx.lineTo(size, 0);
                    ctx.moveTo(0, -size);
                    ctx.lineTo(0, size);
                    ctx.stroke();
                }
                ctx.restore();
                
                ctx.restore();
                optimizedShadow.clear(ctx);
                ctx.globalAlpha = 1.0;
            }
        }

        class Orb {
            constructor(x, y) {
                this.x = x;
                this.y = y; 
                this.r = 9;
                this.collected = false;
                this.float = Math.random() * Math.PI * 2;
                this.pulse = 0;
                this.rotation = 0;
            }
            
            update(speed) {
                this.x -= speed;
                this.float += 0.1;
                this.pulse += 0.15;
                this.rotation += 0.02;
                this.y += Math.sin(this.float) * 0.8;
            }
            
            draw(ctx) {
                if (this.collected) return;
                if (Math.random() > 0.97) {
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = '#ff00ff';
                    ctx.fillRect(this.x - this.r, this.y - this.r, this.r * 2, this.r * 2);
                    ctx.restore();
                }
                
                const pulseSize = this.r + Math.sin(this.pulse) * 3;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                optimizedShadow.apply(ctx, 25, '#ffd700');
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
                ctx.stroke();
                
                optimizedShadow.apply(ctx, 30, '#fff');
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.9;
                const r = pulseSize * 0.7;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i * 60) * Math.PI / 180;
                    const x = Math.cos(angle) * r;
                    const y = Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
                
                ctx.fillStyle = '#fff';
                optimizedShadow.apply(ctx, 40, '#fff');
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize * 0.2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
        }

        class Particle {
            constructor(x, y, c, speed, type = 'circle') {
                this.x = x;
                this.y = y; 
                this.c = c;
                this.vx = (Math.random() - 0.5) * speed;
                this.vy = (Math.random() - 0.5) * speed;
                this.life = 1; 
                this.size = Math.random() * 3 + 2;
                this.type = type;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.2;
                this.glow = Math.random() > 0.5;
            }
            
            update() { 
                this.x += this.vx;
                this.y += this.vy; 
                this.vx *= 0.97;
                this.vy *= 0.97;
                this.life -= 0.03; 
                this.rotation += this.rotationSpeed;
                this.size *= 0.98;
                if (game.isMobile) {
                    this.life -= 0.01;
                }
            }
            
            draw(ctx) {
                if (this.life <= 0) return;
                if (game.isMobile && this.type !== 'hexagram') {
                    ctx.globalAlpha = this.life * 0.5;
                    ctx.fillStyle = this.c;
                    ctx.fillRect(this.x - this.size, this.y - this.size, 
                                this.size * 2, this.size * 2);
                    ctx.globalAlpha = 1;
                    return;
                }
                
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.c;
                
                if (this.glow && this.life > 0.3) {
                    optimizedShadow.apply(ctx, 20 * this.life, this.c);
                }
                
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                if (this.type === 'hexagram') {
                    const r = this.size * 0.8;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 'triangle') {
                    const r = this.size;
                    ctx.beginPath();
                    ctx.moveTo(0, -r);
                    ctx.lineTo(r * 0.866, r * 0.5);
                    ctx.lineTo(-r * 0.866, r * 0.5);
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 'diamond') {
                    const r = this.size;
                    ctx.beginPath();
                    ctx.moveTo(0, -r);
                    ctx.lineTo(r, 0);
                    ctx.lineTo(0, r);
                    ctx.lineTo(-r, 0);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
        }
        
        class Star {
            constructor() {
                this.x = Math.random() * window.innerWidth;
                this.y = Math.random() * window.innerHeight;
                this.size = Math.random() * 10 + 8; // Size for text
                this.speed = Math.random() * 0.5 + 0.2;
                this.alpha = Math.random() * 0.5 + 0.2;
                this.symbol = ALCHEMICAL_SYMBOLS[Math.floor(Math.random() * ALCHEMICAL_SYMBOLS.length)];
                this.rotation = Math.random() * Math.PI * 2;
            }
            update() {
                this.y += this.speed;
                this.rotation += 0.01;
                if (this.y > window.innerHeight) {
                    this.y = -20;
                    this.x = Math.random() * window.innerWidth;
                    this.symbol = ALCHEMICAL_SYMBOLS[Math.floor(Math.random() * ALCHEMICAL_SYMBOLS.length)];
                }
                this.alpha = 0.3 + Math.sin(game.frames * 0.05 + this.x) * 0.2;
            }
            draw(ctx) {
                const conf = game.gameLevels[game.currentLevelIdx];
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.fillStyle = conf ? conf.accent : '#fff';
                ctx.globalAlpha = this.alpha;
                ctx.font = `${this.size}px "Cinzel Decorative"`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(this.symbol, 0, 0);
                ctx.restore();
                ctx.globalAlpha = 1.0;
            }
        }

        let game;
        document.addEventListener('DOMContentLoaded', () => {
            game = new Game();
        });
    </script>
</body>
</html>


            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* CRT Scanline Effect */
        .scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
            opacity: 0.4;
        }
        
        /* Vignette for ominous feel */
        .vignette {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, black 130%);
            pointer-events: none;
            z-index: 11;
        }

        /* UI Overlay */
        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 20;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            transition: opacity 0.3s ease;
            padding: 20px;
            box-sizing: border-box;
        }

        /* Start Screen Specifics */
        #startScreen {
            background-size: cover;
            background-position: center;
            transition: background-image 1s ease-in-out;
            /* Psychedelic Background Animation */
            animation: bgBreath 10s infinite alternate;
        }
        
        /* Dark overlay to make text pop on top of image */
        #startScreen::before {
            content: '';
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: -1;
        }

        @keyframes bgBreath {
            0% { transform: scale(1); filter: hue-rotate(0deg); }
            100% { transform: scale(1.05); filter: hue-rotate(45deg); }
        }

        .hidden {
            opacity: 0 !important;
            pointer-events: none !important;
            display: none !important;
        }

        /* Neon Buttons */
        .mystic-btn {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--primary);
            color: #fff;
            padding: 15px 50px;
            font-size: 1.2rem;
            font-family: 'Cinzel Decorative', cursive;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 4px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 15px var(--primary), inset 0 0 10px var(--primary);
            margin: 10px;
            min-width: 260px;
            position: relative;
            overflow: hidden;
            text-shadow: 0 0 5px #fff;
            animation: psychedelicBorder 4s infinite linear;
        }

        @keyframes psychedelicBorder {
            0% { border-color: #ff003c; box-shadow: 0 0 15px #ff003c; }
            25% { border-color: #ff00ff; box-shadow: 0 0 15px #ff00ff; }
            50% { border-color: #00ffff; box-shadow: 0 0 15px #00ffff; }
            75% { border-color: #ffd700; box-shadow: 0 0 15px #ffd700; }
            100% { border-color: #ff003c; box-shadow: 0 0 15px #ff003c; }
        }

        .mystic-btn:hover {
            background: #fff;
            color: #000;
            transform: scale(1.05);
            text-shadow: none;
        }

        .mystic-btn:active {
            transform: scale(0.95);
        }

        .title-text {
            font-family: 'Cinzel Decorative', cursive;
            font-size: 5rem;
            color: #fff;
            text-shadow: 0 0 10px var(--primary);
            margin-bottom: 10px;
            letter-spacing: -2px;
            animation: pulseNeon 3s infinite alternate;
        }

        @keyframes pulseNeon {
            0% { text-shadow: 0 0 10px var(--primary), 0 0 20px var(--primary); opacity: 1; }
            100% { text-shadow: 0 0 20px var(--primary), 0 0 40px var(--primary), 0 0 80px var(--primary); opacity: 0.9; }
        }

        /* NEW: Floating Animation for UI */
        @keyframes gentleFloat {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }

        .level-indicator {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            font-size: 1.5rem;
            font-family: 'Cinzel Decorative', serif;
            font-weight: 700;
            letter-spacing: 6px;
            color: #fff;
            z-index: 15;
            text-shadow: 0 0 10px #000;
            text-transform: uppercase;
            animation: gentleFloat 4s ease-in-out infinite; 
        }

        .score-display {
            position: absolute;
            top: 10%;
            width: 100%;
            text-align: center;
            font-size: 9rem;
            font-family: 'Cinzel Decorative', serif;
            color: rgba(255, 255, 255, 0.1);
            z-index: 5;
            pointer-events: none;
            mix-blend-mode: screen;
            font-weight: 900;
            animation: gentleFloat 6s ease-in-out infinite reverse;
        }

        .progress-bar {
            width: 300px;
            height: 4px;
            background: #222;
            margin: 20px 0;
            position: relative;
            box-shadow: 0 0 10px #000;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width 0.2s ease;
            box-shadow: 0 0 15px var(--primary);
        }

        .instructions {
            position: absolute;
            bottom: 100px;
            width: 100%;
            text-align: center;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 3px;
            z-index: 15;
            font-family: 'Orbitron', sans-serif;
            animation: fadeOut 5s ease-in-out forwards;
            animation-delay: 2s; 
            pointer-events: none;
        }

        @keyframes fadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; visibility: hidden; }
        }

        .pause-btn {
            position: absolute;
            top: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--primary);
            color: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            z-index: 25;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            pointer-events: auto;
            box-shadow: 0 0 10px var(--primary);
            transition: 0.3s;
        }
        
        .pause-btn:hover {
            background: var(--primary);
            color: #000;
            box-shadow: 0 0 20px var(--primary);
        }

        .stats-panel {
            position: absolute;
            top: 30px;
            left: 30px;
            background: rgba(0, 0, 0, 0.7);
            border-left: 3px solid var(--primary);
            padding: 10px 15px;
            font-size: 0.8rem;
            color: #ccc;
            z-index: 25;
            pointer-events: auto;
            font-family: 'Orbitron', monospace;
            text-align: left;
            backdrop-filter: blur(4px);
        }
        
        /* Custom File Upload Styling */
        .file-upload-label {
            display: inline-block;
            margin-top: 20px;
            padding: 10px 20px;
            border: 1px dashed #666;
            color: #888;
            cursor: pointer;
            font-size: 0.8rem;
            transition: 0.3s;
            font-family: 'Orbitron', sans-serif;
        }
        .file-upload-label:hover {
            border-color: var(--primary);
            color: var(--primary);
            box-shadow: 0 0 10px rgba(255, 0, 60, 0.2);
        }

        /* Mobile Controls */
        .mobile-controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 30;
        }

        .mobile-jump-area {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40%;
            pointer-events: auto;
            background: transparent;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .mobile-jump-indicator {
            background: rgba(255, 0, 60, 0.3);
            border: 2px solid rgba(255, 0, 60, 0.7);
            border-radius: 50%;
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 0.8rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            backdrop-filter: blur(5px);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.1); opacity: 0.9; }
            100% { transform: scale(1); opacity: 0.7; }
        }

        /* Responsive Styles */
        @media (max-width: 768px) {
            .title-text { font-size: 3.5rem !important; margin-bottom: 20px; }
            .score-display { font-size: 6rem !important; top: 8% !important; }
            .level-indicator { font-size: 1.2rem !important; bottom: 70px !important; letter-spacing: 4px !important; }
            .mystic-btn { padding: 12px 30px !important; font-size: 1rem !important; min-width: 220px !important; margin: 8px !important; }
            .instructions { bottom: 130px !important; font-size: 0.7rem !important; letter-spacing: 2px !important; }
            .stats-panel { top: 15px !important; left: 15px !important; font-size: 0.7rem !important; padding: 8px 12px !important; }
            .pause-btn { top: 15px !important; right: 15px !important; width: 45px !important; height: 45px !important; font-size: 1.2rem !important; }
            .progress-bar { width: 250px !important; }
            #gameOverScreen .title-text { font-size: 3rem !important; }
            #pauseScreen .title-text { font-size: 2.5rem !important; }
            #settingsScreen .title-text { font-size: 2rem !important; }
        }

        @media (max-width: 480px) {
            .title-text { font-size: 2.8rem !important; }
            .score-display { font-size: 5rem !important; top: 6% !important; }
            .level-indicator { font-size: 1rem !important; bottom: 60px !important; }
            .mystic-btn { min-width: 200px !important; padding: 10px 25px !important; font-size: 0.9rem !important; letter-spacing: 2px !important; }
            .instructions { font-size: 0.65rem !important; letter-spacing: 1.5px !important; bottom: 140px !important; }
            .progress-bar { width: 200px !important; }
        }

        @media (orientation: portrait) and (max-height: 700px) {
            .title-text { font-size: 2.5rem !important; }
            .score-display { font-size: 4.5rem !important; }
            .level-indicator { bottom: 50px !important; }
            .instructions { bottom: 100px !important; }
        }

        @media (orientation: landscape) {
            .title-text { font-size: 3rem !important; }
            .score-display { font-size: 4rem !important; top: 5% !important; }
            .level-indicator { bottom: 20px !important; font-size: 1rem !important; }
            .mystic-btn { padding: 8px 20px !important; margin: 5px !important; min-width: 180px !important; }
            .instructions { bottom: 70px !important; font-size: 0.6rem !important; }
            .mobile-jump-area { height: 50%; }
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .title-text { font-size: 2.2rem !important; }
            .score-display { font-size: 3rem !important; }
            .mystic-btn { padding: 6px 15px !important; font-size: 0.8rem !important; min-width: 150px !important; }
        }

        /* Safe area padding */
        @supports (padding: max(0px)) {
            .ui-layer {
                padding-left: max(20px, env(safe-area-inset-left));
                padding-right: max(20px, env(safe-area-inset-right));
                padding-top: max(20px, env(safe-area-inset-top));
                padding-bottom: max(20px, env(safe-area-inset-bottom));
            }
        }

        .loader {
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid var(--primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="scanlines"></div>
        <div class="vignette"></div>
        
        <div id="scoreUi" class="score-display">0</div>
        <div id="levelUi" class="level-indicator">INITIATION</div>
        
        <div id="mobileControls" class="mobile-controls hidden">
            <div class="mobile-jump-area">
                <div class="mobile-jump-indicator">TAP</div>
            </div>
        </div>
        
        <div id="startScreen" class="ui-layer" style="background-image: url('https://lh3.googleusercontent.com/d/1BXrXXd9TKSqCFNwvS-cJpNORbyvP6fkR=s0');">
            <h1 class="title-text">Sex Magick</h1>
            <p style="letter-spacing: 8px; color: #ff003c; margin-bottom: 40px; font-size: 1.1rem; text-shadow: 0 0 10px #ff003c; font-family: 'Cinzel Decorative', cursive;">Do Your Will Foo</p>
            
            <div id="loadingMsg">
                <div class="loader"></div>
                <p id="loadingText" style="letter-spacing: 4px; font-size: 0.9rem; margin-top: 15px; font-family: 'Cinzel Decorative';">CHARGING SIGIL...</p>
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill"></div>
                </div>
            </div>

            <div id="menuButtons" class="hidden">
                <button id="startBtn" class="mystic-btn">INVOKE</button>
                <button id="settingsBtn" class="mystic-btn">RITES</button>
                
                <label for="fileUpload" class="file-upload-label">
                    [ OPTIONAL: LOAD LOCAL MP3 ]
                </label>
                <input type="file" id="fileUpload" accept="audio/*" style="display:none;">
                <p id="trackName" style="margin-top: 5px; font-size: 0.6rem; color: #555;">SOURCE: GITHUB CDN</p>
            </div>
        </div>

        <div id="gameOverScreen" class="ui-layer hidden" style="background: rgba(0,0,0,0.85);">
            <h1 class="title-text" style="color: #ff003c; font-size: 4rem;">Good job foo</h1>
            <p style="font-size: 1.2rem; letter-spacing: 4px; margin-bottom: 20px; font-family: 'Cinzel Decorative';">RITUAL FAILED</p>
            <p class="text-xl mb-6 text-gray-300">WILL: <span id="finalScore" style="color: #fff; font-weight:bold; text-shadow: 0 0 10px #fff;">0</span></p>
            <p id="highScoreMsg" style="color: #ffd700; margin-bottom: 30px; font-size: 1rem; letter-spacing: 2px;"></p>
            <button id="restartBtn" class="mystic-btn">REINCARNATE</button>
            <button id="goMenuBtn" class="mystic-btn" style="margin-top: 10px; font-size: 1rem; border-color: #ffd700;">RETURN TO VOID</button>
        </div>

        <div id="pauseScreen" class="ui-layer hidden">
            <h1 class="title-text" style="font-size: 3.5rem; color: #ffd700;">MEDITATION</h1>
            <button id="resumeBtn" class="mystic-btn">RESUME</button>
            <button id="menuBtn" class="mystic-btn">ABORT</button>
        </div>

        <div id="settingsScreen" class="ui-layer hidden" style="background: rgba(0,0,0,0.9);">
            <h1 class="title-text" style="font-size: 2.5rem;">SACRED RITES</h1>
            <div style="width: 320px; margin: 20px 0; background: rgba(20,20,20,0.8); padding: 20px; border: 1px solid var(--primary);">
                <div style="display: flex; justify-content: space-between; margin: 15px 0; border-bottom: 1px solid #444; padding-bottom: 10px;">
                    <span>CHANT (MUSIC)</span>
                    <input type="checkbox" id="musicToggle" checked style="accent-color: var(--primary);">
                </div>
                <div style="display: flex; justify-content: space-between; margin: 15px 0; border-bottom: 1px solid #444; padding-bottom: 10px;">
                    <span>RESONANCE (SFX)</span>
                    <input type="checkbox" id="sfxToggle" checked style="accent-color: var(--primary);">
                </div>
                <div style="display: flex; justify-content: space-between; margin: 15px 0;">
                    <span>KUNDALINI (VIBE)</span>
                    <input type="checkbox" id="vibrationToggle" checked style="accent-color: var(--primary);">
                </div>
            </div>
            <button id="backBtn" class="mystic-btn">RETURN</button>
        </div>

        <button id="pauseBtn" class="pause-btn hidden">||</button>
        
        <div id="statsPanel" class="stats-panel">
            <div style="color: var(--primary); font-weight: bold; margin-bottom: 5px;">:: GNOSIS ::</div>
            FPS: <span id="fpsCounter" style="color: #fff;">0</span><br>
            AUDIO: <span id="audioStatus" style="color: #fff;">STANDBY</span>
        </div>

        <div id="instructions" class="instructions hidden">
            [ TAP / SPACE TO ASCEND ]
        </div>
    </div>

    <script>
        const CDN_PREFIX = "https://cdn.jsdelivr.net/gh/bookthief666/93-protocol-game-assets-@662f3d608769e9e945295ac00d668447d974dc5c/";

        const CONFIG = {
            DEBUG: true, // Ensured DEBUG is true so FPS counter shows
            MENU_MUSIC: CDN_PREFIX + "iamerror%20-%20The%20Zelda%20Song%20(Hyr00l).mp3",
            GAME_PLAYLIST: [
                CDN_PREFIX + "iamerror%20-%20Hyr00l%20Rough.mp4",
                CDN_PREFIX + "bookthief%F0%9F%A5%80%20-%20booothief-%20All%20gay%F0%9F%98%87%202024-07-10%2001_11%20(1).m4a",
                CDN_PREFIX + "Vae!%20Puto%20Deus%20Fio!%20(3).mp3",
                CDN_PREFIX + "IAMERROR%20-%20The%20Iceclops%20Cometh.mp3",
                CDN_PREFIX + "Forest%20of%20Fellatio%20%5BTTn3kjGwXi0%5D.mp3",
                CDN_PREFIX + "LEX_LFL_80_wurli_loop_ate_bit_Cm.wav",
                CDN_PREFIX + "iamerror%20-%20The%20Zelda%20Song%20(Hyr00l).mp3"
            ],
            BASE_URL: "https://lh3.googleusercontent.com/d/",
            IMG_SUFFIX: "=s0",
            
            // SLOWER START SETTINGS:
            INITIAL_GAME_SPEED: 2.0, // Reduced from 2.5/3.5
            SPEED_INCREASE_PER_LEVEL: 0.1, // Reduced from 0.15/0.25
            PILLAR_SPAWN_RATE: 120,
            PILLAR_WIDTH: 45,
            PILLAR_GAP: 250, 
            PILLAR_GAP_DECREASE_PER_5_LEVELS: 8, 
            MIN_PILLAR_GAP: 180, 
            ORB_SPAWN_CHANCE: 0.5,
            PLAYER_JUMP_FORCE: -6.5,
            GRAVITY: 0.20,
            
            PLAYER_RADIUS: 16, 
            HITBOX_OFFSET: 4, 
            MOBILE_CONTROL_DEADZONE: 50,
        };
        const originalLevels = [
            { name: "MALKUTH", id: "1jI7bl3hsVOuzYf6u35L4bhHq5JUiBDa1" },
            { name: "YESOD", id: "1tHgxNvDO5md4z24hS81eTa9uva25mtr5" },
            { name: "HOD", id: "1Mtp6cP6lwGbPRhLWjQKKDijrLX53K4UR" },
            { name: "NETZACH", id: "1y1i5lxL1jVp37bIz1mtJh4-Puce-E5k0" },
            { name: "TIPHARETH", id: "12png0vOPyJC1Ab4Vffcw2R_K-yRw1sqj" },
            { name: "GEBURAH", id: "1le2Hox1ORxhL28fv7WujO0410vM6jUEJ" },
            { name: "CHESED", id: "1Gsq1xSx9ivfVEq6W2nCMrO-dOIMrSYrW" },
            { name: "DA'ATH", id: "1o601hrLi5RpuGL_kiVEoPXxXk2SCbM2z" },
            { name: "BINAH", id: "1iSYJfPsaYjA1rmRTsujLcn1Do-lBydF7" },
            { name: "CHOKMAH", id: "1PvOC62nv5HdsE1cuCF8RENY9Z8HTabn7" },
            { name: "KETHER", id: "1Ym_eyrXJEQUBA7Lg_2oUc6dQ-gy9yfGs" }
        ];
        const newImageIDs = [
            "1pJ5CUGyKXgkSgEREkKos1Kch5FmfUyxE", "1spT4HpO_4q9joE4x6bLjZQRlFTS9j-ie", "1YGzyjcjiCoPCLbYjJEiqT8USUhe4S6hM", "1ELjoJU7KDC88nUk_Vs57OKUG9oLl5E8N",
            "1faa2c3QFWhZ8UgvyZ_ZrlnyFsnsKRclm", "10W5oYkoqB9LC3YjvB_aozR0kG3hWaHka", "1l9Jdm0EQh8sgWh1W0wsXQCzrQM19Bfm9", "1BrHTF2dvfbRkyYfXAbPUiujwE1AJskY4",
            "1KqV8IYF7KDbmgHS3ph6eRQKl4uAAFG_u", "1sZ02UH_vb1xLaOvyETqptc5FuvOtVKd4", "1hLKOGYXCBemcIKt8OLEX4dHTn6bd88cr", "1g_DQeG6qldMBxHzZ82MOVoxk9APwb4NO",
            "1-SIvE5EZyUd7FKXJ7eyB4JCrtOpQoF18", "1S4y4YSCjxSb-b_U1BfMw_0PhabJ-METm", "1OL-kWl-TJNcZFPcsCAtynW2NWp-YYjGd", "1ApPgou40N2Q6GlNKNuyoQ2Gk5DqAfmw_",
            "1OeH1GMu2rDcwzdtWFZSB1WWe0OjkmxV0", "12Z92v9Mu9yNOnDTtK-bjMRZ8_2BAW2eW", "1Erf3DKxZpfbG57oGcUCjuHIhajsweLZz", "1qK22CJhJ1XgElL156uOQxYrucaRG16p0",
            "1euwdAWg-xQw7isR-JAiZ-krXQXOS8pi0", "1A3hT3mJibINtsr8CVxTmp71QsYgPB2JZ", "1QUVr-RK2kP7IIAuy0wX3pOZRQuyr-o-e", "1eF02YMyYBcgx7Ga20pXgoltzWXPYznfD",
            "1zx1vrrbuSA4xCFKXAHgXbkG1rX8PUPel", "1ds1iqXf90gy9PUFs80t4QOxamkJj0u1I", "14-t6dPPv5MeXe7LWPIp7Tjc8x4w5Vj2d", "1pUtIizMzVhjzB46dhah5mgz6Tr-vaSLO",
            "1ZOEkUW8q2s5zerS7BubYJU69RHk7_Zlo", "15ZHj0fLYu-4rEQy43BMJKDgXnnQ5FeyP", "1ZzgVT0O6XQzW3DUP4i1aoKd_DD5wV5LZ", "1rZHZM0bR_j6uiYZLS82J0BkbIfEUoXvY",
            "1CNrQ_EeMXQgHJGXxe7EHysQi_A0A9UE7", "1ubCqIg7ETOIsHGfBjQfVsRzjlZIpBP6E", "1pojzjR-uiQ0oTHRJxXXCW_w0hlJUCqyb", "1SnclBlH6sflhaTWzFhbcNedzNeh25-BV",
            "1thfc-9DnM4GhCi0zTbcX4MH-yaQEpomX", "1BXrXXd9TKSqCFNwvS-cJpNORbyvP6fkR", "1D1bOksatIt6Jw6Zq8Sbmhbq_GC_2EQHh", "1eP_Xnk80YnL3w3Q69wQmVo9_F0OaA3Wo",
            "1ARDOipcr0lB1GYf3gmhqlHXlpC23Q2JE", "1io39jfggXQl-OyvSFGIpgOtoIzHbml3M", "1o0rJmx3vEKITMx1ixP5iruOX2ujOT6VO", "1Irw61utgSGdip21OgTcYqz56LpWWS9fb",
            "19V2ObVoQn9R9bt1ZgMNEBJokaAjYdX_9", "1WWvLnkkPBN7Q0ZsGi16FL1anhPlti3Qd", "1HoYqC0SLc3nrSDnoW9KJ2-z8AnRWIz5M", "1oS0J3F-zh5H48-Qs5Mrm10dPR993kF-b",
            "1bRwsBEuZiAIZW_5f3WOZVI6-KVnCEslk", "1GLza2_RmR4c_KD_KGxbXPOoCAw9SITKl", "1uWFSChozQmHEnuJwXqiPNApXuAwPAzKS", "1t2hNBEudzIo19kuP8ksPY_cNetDdTd8P",
            "1KhMBL7a3NSggVerbyy53fQ-dLq11adwj", "1wgxalTR68YM7oIku8JYZYKtG50atEnG_", "1BceMgnHgVn9U_7EYnXQu9HDwEQY1UBa_", "14_iwYDQjp34-R_iby8QadKnI9m3zVnOu",
            "1cZ_ci9J80jnqCAdag8SQofYZw1dfsX3C", "15z3bGrCqUy8SQjX1dO5C1vlN3y4-soai", "10xAFw98B39Ou0SSeB4eWyoY2D_OLLPgz", "1CexZQw11p33u1-YA7JhPAkGV6NBCgd6e",
            "16t1EdHfHRpb7GmqNAfo2iKKm57qLfbKn", "12wQOhUztVCVEFV21fPDq-JXGi5zxdkeQ", "1-0u9JUH0oUHD1--5iaySxRpO_PuyxkH6", "1wnITY3i6XxOr1b3l6P0cT10LkEHQauO5"
        ].filter((value, index, self) => self.indexOf(value) === index);
        const esotericNames = [
            "KUNDALINI", "HIEROS GAMOS", "SACRED UNION", "RED TINCTURE", "WHITE GLUTEN", 
            "CUP OF BABALON", "BLOOD OF SAINTS", "CITY OF PYRAMIDS", "NIGHT OF PAN", 
            "HADIT'S FLAME", "NUIT'S EMBRACE", "LAW OF THELEMA", "LOVE UNDER WILL", 
            "GREAT WORK", "STONE OF WISE", "ELIXIR OF LIFE", "RED LION", "WHITE EAGLE",
            "ABRAHADABRA", "LASHTAL", "KA", "BA", "KHU", "SCARLET WOMAN", "THE BEAST",
            "AEON OF HORUS", "93", "AGAPE", "THELEMA", "VIA OVUM", "SPERMATOZOON",
            "HOMUNCULUS", "DIVINE EROS", "TANTRA", "YONI", "LINGAM", "O.T.O.", "A.'.A.'.",
            "STAR SAPPHIRE", "MASS OF PHOENIX", "LIBER AL", "RESH", "SAMEKH", "TZADDI"
        ];
        let MASTER_POOL = [...originalLevels];
        
        const palette = ["#ff003c", "#ff00ff", "#9d00ff", "#00f0ff", "#00ff9d", "#d4ff00", "#ff8800"];
        newImageIDs.forEach((id, index) => {
            const nameIndex = index % esotericNames.length;
            MASTER_POOL.push({
                name: esotericNames[nameIndex],
                id: id,
                color: "#000",
                accent: palette[index % palette.length],
                img: null,
                loaded: false
            });
        });
        const GameState = {
            START: 'start',
            LOADING: 'loading',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAME_OVER: 'gameover',
            SETTINGS: 'settings'
        };
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        const optimizedShadow = {
            apply(ctx, blur, color) {
                if (isMobile) {
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = 'transparent';
                } else {
                    ctx.shadowBlur = blur;
                    ctx.shadowColor = color;
                }
            },
            clear(ctx) {
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }
        };

        const GlitchFX = {
            active: false,
            duration: 0,
            intensity: 1,
            type: 'rgb',
            
            rgbSplit(ctx, intensity) {
                const offset = Math.floor(Math.random() * 3 * intensity);
                const rOffset = Math.random() > 0.5 ? offset : -offset;
                const gOffset = Math.random() > 0.5 ? offset : -offset;
                const bOffset = Math.random() > 0.5 ? offset : -offset;
                if (Math.random() > 0.3) return null;
                return {
                    rOffset, gOffset, bOffset,
                    draw: function(ctx, width, height) {
                        const imageData = ctx.getImageData(0, 0, width, height);
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = width;
                        tempCanvas.height = height;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.putImageData(imageData, 0, 0);
                        
                        ctx.save();
                        ctx.globalCompositeOperation = 'screen';
                        ctx.globalAlpha = 0.8;
                        ctx.drawImage(tempCanvas, rOffset, 0);
                        ctx.globalAlpha = 0.8;
                        ctx.drawImage(tempCanvas, 0, gOffset);
                        ctx.globalAlpha = 0.8;
                        ctx.drawImage(tempCanvas, bOffset, bOffset);
                        ctx.restore();
                    }
                };
            },
            
            staticEffect(ctx, intensity) {
                ctx.save();
                ctx.globalAlpha = 0.1 * intensity;
                for (let i = 0; i < 5; i++) { 
                    const x = Math.random() * ctx.canvas.width;
                    const y = Math.random() * ctx.canvas.height;
                    const size = Math.random() * 10 * intensity + 2;
                    ctx.fillStyle = Math.random() > 0.5 ? '#ff003c' : '#00ffff';
                    ctx.fillRect(x, y, size, 1);
                    if (Math.random() > 0.7) {
                        ctx.fillStyle = Math.random() > 0.5 ? '#ff00ff' : '#00ff9d';
                        ctx.fillRect(x, y + 2, 1, size);
                    }
                }
                ctx.restore();
            },
            
            scanlineDistort(ctx, intensity) {
                if (Math.random() > 0.5) return;
                ctx.save();
                ctx.globalAlpha = 0.05 * intensity;
                ctx.fillStyle = '#fff';
                const lineCount = Math.floor(3 * intensity);
                for (let i = 0; i < lineCount; i++) {
                    const y = Math.floor(Math.random() * ctx.canvas.height);
                    const height = Math.random() * 2 + 1;
                    const wave = Math.sin(Date.now() * 0.01 + i) * 10 * intensity;
                    ctx.fillRect(0, y, ctx.canvas.width, height);
                    ctx.fillRect(wave, y + 5, ctx.canvas.width, 1);
                }
                ctx.restore();
            },
            
            blockDisplace(ctx, intensity) {
                if (Math.random() > 0.7) return;
                ctx.save();
                ctx.globalAlpha = 0.3 * intensity;
                for (let i = 0; i < 2; i++) {
                    const x = Math.random() * ctx.canvas.width;
                    const y = Math.random() * ctx.canvas.height;
                    const width = Math.random() * 50 * intensity + 20;
                    const height = Math.random() * 50 * intensity + 20;
                    const offsetX = (Math.random() - 0.5) * 10 * intensity;
                    const offsetY = (Math.random() - 0.5) * 10 * intensity;
                    ctx.fillStyle = Math.random() > 0.5 ? '#ff003c' : '#00ffff';
                    ctx.fillRect(x + offsetX, y + offsetY, width, height);
                }
                ctx.restore();
            },
            
            apply(ctx, currentTime) {
                if (!this.active || this.duration <= 0) return;
                const progress = this.duration / 100;
                this.intensity = Math.min(1, progress * 2);
                if (Math.random() > 0.5) this.staticEffect(ctx, this.intensity);
                if (Math.random() > 0.6) this.scanlineDistort(ctx, this.intensity);
                if (Math.random() > 0.7) this.blockDisplace(ctx, this.intensity);
                if (Math.random() > 0.8) {
                    const rgbEffect = this.rgbSplit(ctx, this.intensity);
                    if (rgbEffect) rgbEffect.draw(ctx, ctx.canvas.width, ctx.canvas.height);
                }
                this.duration -= 16;
                if (this.duration <= 0) {
                    this.active = false;
                    this.intensity = 1;
                }
            },
            
            trigger(duration = 100, type = 'all') {
                this.active = true;
                this.duration = duration;
                this.type = type;
                this.intensity = 1;
            }
        };

        const SFX = {
            audioContext: null,
            init() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
            },
            playTone(freq, type, duration, vol, detune = 0) {
                if (!game?.settings?.sfx) return;
                if (!this.audioContext) this.init();
                if (this.audioContext.state === 'suspended') this.audioContext.resume();
                
                try {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    
                    osc.type = type;
                    osc.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                    osc.detune.setValueAtTime(detune, this.audioContext.currentTime);
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    gain.gain.setValueAtTime(vol, this.audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                    
                    osc.start();
                    osc.stop(this.audioContext.currentTime + duration);
                } catch(e){}
            },
            jump() { 
                this.playTone(400, 'square', 0.08, 0.1);
                this.playTone(600, 'sine', 0.05, 0.05, 100);
            },
            collect() { 
                this.playTone(800, 'sine', 0.2, 0.1);
                this.playTone(1200, 'triangle', 0.1, 0.05, 50);
            },
            crash() { 
                this.playTone(100, 'sawtooth', 0.5, 0.3);
                this.playTone(80, 'square', 0.3, 0.2, -100);
            },
            levelUp() { 
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.5);
                osc.connect(gain);
                gain.connect(this.audioContext.destination);
                gain.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                osc.start();
                osc.stop(this.audioContext.currentTime + 0.5);
            }
        };

        const Haptics = {
            jump() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([15]);
                }
            },
            collect() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([30, 20, 30]);
                }
            },
            crash() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([150, 30, 80, 30, 40]);
                }
            },
            levelUp() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([80, 20, 80, 20, 80]);
                }
            }
        };

        const AudioSys = {
            bgm: null,
            localBlobUrl: null,
            currentMode: 'none', 
            retryCount: 0,
            
            setStatus(msg) {
                const el = document.getElementById('audioStatus');
                if (el) {
                    el.textContent = msg;
                    el.style.color = '#fff';
                    setTimeout(() => el.style.color = 'var(--primary)', 200);
                }
            },

            init() {
                this.setupAudioElement(CONFIG.MENU_MUSIC);
                this.currentMode = 'menu';
                this.setStatus("MENU AUDIO RDY");
            },

            setupAudioElement(src) {
                if (this.bgm) {
                    this.bgm.pause();
                    this.bgm.src = "";
                    this.bgm.load();
                }
                this.bgm = new Audio();
                this.bgm.src = src;
                this.bgm.loop = true;
                this.bgm.volume = 0.8;
                this.bgm.preload = "auto";
                
                this.bgm.onwaiting = () => this.setStatus("BUFFERING...");
                this.bgm.onplaying = () => {
                    this.setStatus("PLAYING");
                    this.retryCount = 0;
                };
                
                this.bgm.onerror = (e) => {
                    console.warn("Audio error:", e);
                    this.setStatus("LOAD ERROR");
                };
            },

            loadLocalFile(file) {
                if (this.localBlobUrl) URL.revokeObjectURL(this.localBlobUrl);
                this.localBlobUrl = URL.createObjectURL(file);
                this.setupAudioElement(this.localBlobUrl);
                this.setStatus("FILE LOADED");
            },
            
            switchToGameMusic() {
                if (this.localBlobUrl) return;
                const randomIndex = Math.floor(Math.random() * CONFIG.GAME_PLAYLIST.length);
                const track = CONFIG.GAME_PLAYLIST[randomIndex];
                this.currentMode = 'game';
                this.setStatus("LOADING TRK " + (randomIndex + 1));
                this.setupAudioElement(track);
                this.play();
            },

            switchToMenuMusic() {
                if (this.localBlobUrl) return;
                this.currentMode = 'menu';
                this.setStatus("LOADING MENU");
                this.setupAudioElement(CONFIG.MENU_MUSIC);
            },
            
            play() {
                if (!this.bgm) return;
                const playPromise = this.bgm.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => this.setStatus("PLAYING")).catch(error => {
                        console.warn("Play failed:", error);
                        this.setStatus("AUTOPLAY BLOCK");
                    });
                }
            },
            
            pause() { if (this.bgm) { this.bgm.pause(); this.setStatus("PAUSED"); } },
            resume() { if (this.bgm && this.bgm.paused) { this.bgm.play(); this.setStatus("RESUMED"); } },
            stop() { if (this.bgm) { this.bgm.pause(); this.bgm.currentTime = 0; this.setStatus("STOPPED"); } }
        };

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.root = document.documentElement;
                
                this.state = GameState.START;
                this.currentLevelIdx = 0;
                this.frames = 0;
                this.score = 0;
                this.highScore = localStorage.getItem('93protocol_highscore') || 0;
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED;
                this.shake = 0;
                this.lastFrameTime = 0;
                this.fps = 0;
                this.isMobile = isMobile;
                this.aspectRatio = 16/9;
                this.baseWidth = 800;
                this.baseHeight = 450;
                this.scaleFactor = 1;
                this.glitchEffect = false;
                this.glitchTimer = 0;
                this.glitchDuration = 300;
                this.tunnelOffset = 0;
                this.tunnelSpeed = 0.5;
                this.hitStop = 0;
                this.screenFlash = null;
                this.backgroundParticles = [];
                
                this.player = null;
                this.particles = [];
                this.stars = [];
                this.obstacles = [];
                this.collectibles = [];
                this.gameLevels = []; 
                
                this.settings = { music: true, sfx: true, vibration: true };
                
                this.loadSettings();
                this.initEventListeners();
                this.resizeCanvas();
                this.preloadAllImages();
                this.createBackgroundParticles();
                
                AudioSys.init();
                SFX.init();
                this.randomizeMenuBackground();
            }
            
            randomizeMenuBackground() {
                if(newImageIDs.length > 0) {
                    const randomId = newImageIDs[Math.floor(Math.random() * newImageIDs.length)];
                    const url = CONFIG.BASE_URL + randomId + CONFIG.IMG_SUFFIX;
                    document.getElementById('startScreen').style.backgroundImage = `url('${url}')`;
                }
            }
            
            createBackgroundParticles() {
                for (let i = 0; i < 25; i++) { 
                    this.backgroundParticles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        z: Math.random() * 2 + 0.5,
                        size: Math.random() * 3 + 2,
                        speed: Math.random() * 0.5 + 0.1,
                        color: palette[Math.floor(Math.random() * palette.length)],
                        opacity: Math.random() * 0.4 + 0.1,
                        shape: Math.floor(Math.random() * 3) 
                    });
                }
            }
            
            triggerOrbGlitch() {
                GlitchFX.trigger(80, 'orb');
                this.screenFlash = { active: true, duration: 10, color: '#ffd700', intensity: 0.3 };
            }
            
            triggerLevelUpGlitch() {
                GlitchFX.trigger(150, 'level');
                this.screenFlash = { active: true, duration: 20, color: this.gameLevels[this.currentLevelIdx]?.accent || '#ff003c', intensity: 0.4 };
            }
            
            triggerDeathGlitch() {
                GlitchFX.trigger(200, 'death');
                this.screenFlash = { active: true, duration: 30, color: '#ff003c', intensity: 0.6 };
            }
            
            applyScreenFlash() {
                if (!this.screenFlash || !this.screenFlash.active) return;
                this.ctx.save();
                this.ctx.fillStyle = this.screenFlash.color;
                this.ctx.globalAlpha = this.screenFlash.intensity * (this.screenFlash.duration / 30);
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.restore();
                this.screenFlash.duration--;
                if (this.screenFlash.duration <= 0) {
                    this.screenFlash.active = false;
                }
            }
            
            initEventListeners() {
                document.getElementById('fileUpload').addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) AudioSys.loadLocalFile(file);
                });
                window.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && this.state === GameState.PLAYING) this.playerJump();
                    else if (e.code === 'Escape') this.togglePause();
                });
                window.addEventListener('mousedown', (e) => {
                    if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'LABEL' && this.state === GameState.PLAYING) this.playerJump();
                });
                window.addEventListener('touchstart', (e) => {
                    if (this.state === GameState.PLAYING) {
                        e.preventDefault();
                        const touchY = e.touches[0].clientY;
                        if (touchY > window.innerHeight * 0.6) {
                            this.playerJump();
                        }
                    }
                }, { passive: false });
                document.getElementById('startBtn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (this.settings.music) AudioSys.switchToGameMusic();
                    this.startGame();
                });
                document.getElementById('restartBtn').addEventListener('click', (e) => {
                     e.stopPropagation();
                     if (this.settings.music) AudioSys.switchToGameMusic();
                     this.restartGame();
                });
                document.getElementById('goMenuBtn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.returnToMenu();
                });
                document.getElementById('pauseBtn').addEventListener('click', (e) => { e.stopPropagation(); this.togglePause(); });
                document.getElementById('resumeBtn').addEventListener('click', (e) => { e.stopPropagation(); this.togglePause(); });
                document.getElementById('menuBtn').addEventListener('click', (e) => { e.stopPropagation(); this.returnToMenu(); });
                document.getElementById('settingsBtn').addEventListener('click', (e) => { e.stopPropagation(); this.showSettings(); });
                document.getElementById('backBtn').addEventListener('click', (e) => { e.stopPropagation(); this.hideSettings(); });
                
                document.getElementById('musicToggle').addEventListener('change', (e) => {
                    this.settings.music = e.target.checked;
                    this.saveSettings();
                    if (!this.settings.music) AudioSys.stop();
                    else if (this.state === GameState.PLAYING) AudioSys.play();
                });
                document.getElementById('sfxToggle').addEventListener('change', (e) => {
                    this.settings.sfx = e.target.checked;
                    this.saveSettings();
                });
                document.getElementById('vibrationToggle').addEventListener('change', (e) => {
                    this.settings.vibration = e.target.checked;
                    this.saveSettings();
                });
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            loadSettings() {
                const saved = localStorage.getItem('93protocol_settings');
                if (saved) this.settings = { ...this.settings, ...JSON.parse(saved) };
                document.getElementById('musicToggle').checked = this.settings.music;
                document.getElementById('sfxToggle').checked = this.settings.sfx;
                document.getElementById('vibrationToggle').checked = this.settings.vibration;
            }
            
            saveSettings() { localStorage.setItem('93protocol_settings', JSON.stringify(this.settings));
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.calculateScaleFactor();
                this.adjustForScreenSize();
            }
            
            calculateScaleFactor() {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const targetRatio = 16/9;
                const currentRatio = width/height;
                if (currentRatio > targetRatio) {
                    this.scaleFactor = height / this.baseHeight;
                } else {
                    this.scaleFactor = width / this.baseWidth;
                }
                
                this.scaleFactor = Math.max(0.6, Math.min(this.scaleFactor, 1.5));
            }
            
            adjustForScreenSize() {
                const screenHeight = this.canvas.height;
                let baseGap = CONFIG.PILLAR_GAP;
                if (screenHeight < 600) {
                    baseGap = Math.min(270, baseGap * 1.08);
                } else if (screenHeight > 800) {
                    baseGap = Math.max(240, baseGap * 0.95);
                }
                this.currentBaseGap = baseGap;
            }
            
            preloadAllImages() {
                const progressFill = document.getElementById('progressFill');
                const loadingText = document.getElementById('loadingText');
                let loadedCount = 0;
                
                const failsafe = setTimeout(() => {
                    if (loadedCount < MASTER_POOL.length) {
                        console.warn("Loading timed out. Forcing start.");
                        this.finishLoading();
                    }
                }, 5000);
                MASTER_POOL.forEach(lvl => {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.onload = () => {
                        lvl.img = img;
                        lvl.loaded = true;
                        loadedCount++;
                        const percent = Math.floor((loadedCount / MASTER_POOL.length) * 100);
                        progressFill.style.width = `${percent}%`;
                        loadingText.innerText = `CHARGING SIGIL... ${loadedCount}/${MASTER_POOL.length}`;
                        if (loadedCount >= MASTER_POOL.length) {
                            clearTimeout(failsafe);
                            this.finishLoading();
                        }
                    };
                    img.onerror = () => {
                        console.warn(`Failed to load image: ${lvl.id}`);
                        loadedCount++;
                        if (loadedCount >= MASTER_POOL.length) {
                            clearTimeout(failsafe);
                            this.finishLoading();
                        }
                    };
                    img.src = CONFIG.BASE_URL + lvl.id + CONFIG.IMG_SUFFIX;
                });
            }
            
            finishLoading() {
                setTimeout(() => {
                    document.getElementById('loadingMsg').classList.add('hidden');
                    document.getElementById('menuButtons').classList.remove('hidden');
                }, 500);
            }
            
            prepareLevels() {
                let shuffled = [...MASTER_POOL];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                this.gameLevels = shuffled.map((lvl, index) => {
                    return { ...lvl, threshold: index * 5 };
                });
            }

            startGame() {
                this.prepareLevels();
                this.state = GameState.PLAYING;
                document.getElementById('startScreen').classList.add('hidden');
                document.getElementById('scoreUi').classList.remove('hidden');
                document.getElementById('pauseBtn').classList.remove('hidden');
                document.getElementById('instructions').classList.remove('hidden');
                
                if (this.isMobile) {
                    document.getElementById('mobileControls').classList.remove('hidden');
                    setTimeout(() => {
                        document.getElementById('mobileControls').classList.add('hidden');
                    }, 5000);
                }
                
                if (CONFIG.DEBUG) document.getElementById('statsPanel').classList.remove('hidden');
                this.initGame();
                this.gameLoop();
            }
            
            initGame() {
                this.player = new Player();
                this.obstacles = [];
                this.collectibles = [];
                this.particles = [];
                this.stars = [];
                for (let i = 0; i < 40; i++) this.stars.push(new Star());
                this.score = 0;
                this.currentLevelIdx = 0;
                this.frames = 0;
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED;
                this.shake = 0;
                this.tunnelOffset = 0;
                this.hitStop = 0;
                document.getElementById('scoreUi').innerText = "0";
                this.applyLevel();
            }
            
            applyLevel() {
                if (this.currentLevelIdx >= this.gameLevels.length) return;
                const l = this.gameLevels[this.currentLevelIdx];
                document.getElementById('levelUi').innerText = l.name;
                document.getElementById('levelUi').style.color = l.accent;
                document.getElementById('levelUi').style.textShadow = `0 0 15px ${l.accent}`;
                this.root.style.setProperty('--primary', l.accent);
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED + (this.currentLevelIdx * CONFIG.SPEED_INCREASE_PER_LEVEL);
                
                if (this.currentLevelIdx > 0) {
                    this.triggerGlitchEffect();
                    Haptics.levelUp();
                    if (this.settings.sfx) SFX.levelUp();
                }
            }
            
            triggerGlitchEffect() {
                this.glitchEffect = true;
                this.glitchTimer = this.glitchDuration;
            }
            
            applyGlitchEffect() {
                if (!this.glitchEffect) return;
                const ctx = this.ctx;
                const intensity = this.glitchTimer / this.glitchDuration;
                if (Math.random() > 0.7) {
                    const shiftX = Math.floor(Math.random() * 10 * intensity) - 5;
                    const shiftY = Math.floor(Math.random() * 10 * intensity) - 5;
                    ctx.save();
                    ctx.translate(shiftX, shiftY);
                    ctx.restore();
                }
                
                if (Math.random() > 0.8) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fillRect(0, Math.floor(Math.random() * this.canvas.height), this.canvas.width, 1);
                }
                
                this.glitchTimer -= 16;
                if (this.glitchTimer <= 0) {
                    this.glitchEffect = false;
                }
            }
            
            getCurrentGap() {
                const baseGap = this.currentBaseGap || CONFIG.PILLAR_GAP;
                const levelsCompleted = Math.floor(this.currentLevelIdx / 5);
                const gapReduction = levelsCompleted * CONFIG.PILLAR_GAP_DECREASE_PER_5_LEVELS;
                const calculatedGap = Math.max(CONFIG.MIN_PILLAR_GAP, baseGap - gapReduction);
                return calculatedGap;
            }
            
            checkLevel() {
                const nextIdx = this.currentLevelIdx + 1;
                if (nextIdx >= this.gameLevels.length) return;
                const next = this.gameLevels[nextIdx];
                if (this.score >= next.threshold) {
                    this.currentLevelIdx++;
                    this.applyLevel();
                    this.shake = 12;
                    this.hitStop = 3;
                    this.triggerLevelUpGlitch();
                    for (let i = 0; i < 30; i++) {
                        this.particles.push(new Particle(
                            this.canvas.width / 2, this.canvas.height / 2, 
                            this.gameLevels[this.currentLevelIdx].accent, 12,
                            Math.random() > 0.5 ? 'hexagram' : 'triangle'
                        ));
                    }
                    if (this.settings.sfx) SFX.levelUp();
                    Haptics.levelUp();
                }
            }
            
            playerJump() {
                if (this.state === GameState.PLAYING) {
                    this.player.jump();
                    Haptics.jump();
                    GlitchFX.trigger(50, 'rgb');
                }
            }
            
            togglePause() {
                if (this.state === GameState.PLAYING) {
                    this.state = GameState.PAUSED;
                    document.getElementById('pauseScreen').classList.remove('hidden');
                    AudioSys.pause();
                } else if (this.state === GameState.PAUSED) {
                    this.state = GameState.PLAYING;
                    document.getElementById('pauseScreen').classList.add('hidden');
                    AudioSys.resume();
                    this.gameLoop();
                }
            }
            
            showSettings() {
                document.getElementById('startScreen').classList.add('hidden');
                document.getElementById('settingsScreen').classList.remove('hidden');
                this.state = GameState.SETTINGS;
            }
            
            hideSettings() {
                document.getElementById('settingsScreen').classList.add('hidden');
                document.getElementById('startScreen').classList.remove('hidden');
                this.state = GameState.START;
            }
            
            returnToMenu() {
                this.state = GameState.START;
                document.getElementById('gameOverScreen').classList.add('hidden');
                document.getElementById('pauseScreen').classList.add('hidden');
                document.getElementById('startScreen').classList.remove('hidden');
                document.getElementById('scoreUi').classList.add('hidden');
                document.getElementById('pauseBtn').classList.add('hidden');
                document.getElementById('instructions').classList.add('hidden');
                document.getElementById('statsPanel').classList.add('hidden');
                document.getElementById('mobileControls').classList.add('hidden');
                this.randomizeMenuBackground();
                if (this.settings.music) AudioSys.switchToMenuMusic();
            }
            
            gameOver() {
                if (this.state === GameState.GAME_OVER) return;
                this.state = GameState.GAME_OVER;
                this.shake = 15;
                this.triggerDeathGlitch();
                if (this.settings.sfx) SFX.crash();
                Haptics.crash();
                
                for (let i = 0; i < 25; i++) {
                    this.particles.push(new Particle(
                        this.player.x, this.player.y,
                        '#ff003c', 10,
                        Math.random() > 0.3 ? 'hexagram' : 'triangle'
                    ));
                }
                
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('93protocol_highscore', this.highScore);
                    document.getElementById('highScoreMsg').textContent = "NEW GNOSIS ATTAINED";
                } else {
                    document.getElementById('highScoreMsg').textContent = `BEST: ${this.highScore}`;
                }
                AudioSys.stop();
                document.getElementById('finalScore').innerText = this.score;
                document.getElementById('scoreUi').classList.add('hidden');
                document.getElementById('pauseBtn').classList.add('hidden');
                document.getElementById('instructions').classList.add('hidden');
                document.getElementById('statsPanel').classList.add('hidden');
                document.getElementById('mobileControls').classList.add('hidden');
                document.getElementById('gameOverScreen').classList.remove('hidden');
            }
            
            restartGame() {
                this.state = GameState.PLAYING;
                this.prepareLevels();
                document.getElementById('gameOverScreen').classList.add('hidden');
                document.getElementById('scoreUi').classList.remove('hidden');
                document.getElementById('pauseBtn').classList.remove('hidden');
                document.getElementById('instructions').classList.remove('hidden');
                if (this.isMobile) {
                    document.getElementById('mobileControls').classList.remove('hidden');
                    setTimeout(() => {
                        document.getElementById('mobileControls').classList.add('hidden');
                    }, 5000);
                }
                if (CONFIG.DEBUG) document.getElementById('statsPanel').classList.remove('hidden');
                this.initGame();
                this.gameLoop();
            }
            
            gameLoop(currentTime = 0) {
                if (this.state !== GameState.PLAYING) return;
                if (this.lastFrameTime) {
                    this.fps = Math.round(1000 / (currentTime - this.lastFrameTime));
                    if (CONFIG.DEBUG) document.getElementById('fpsCounter').textContent = this.fps;
                }
                this.lastFrameTime = currentTime;
                
                if (this.hitStop > 0) {
                    this.hitStop--;
                    this.drawScene(currentTime);
                    requestAnimationFrame((time) => this.gameLoop(time));
                    return;
                }

                this.frames++;
                
                if (Math.random() > 0.995 && this.frames % 60 === 0) {
                    GlitchFX.trigger(30, 'random');
                }
                
                this.tunnelOffset += this.tunnelSpeed * (1 + this.gameSpeed * 0.1);
                
                this.updateGameObjects();
                this.drawScene(currentTime);
                
                requestAnimationFrame((time) => this.gameLoop(time));
            }

            drawScene(currentTime) {
                const lvl = this.gameLevels[this.currentLevelIdx];
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawHyperspaceTunnel(lvl);
                GlitchFX.apply(this.ctx, currentTime);
                this.applyScreenFlash();
                if (this.glitchEffect) {
                    this.applyGlitchEffect();
                }
                this.ctx.save();
                if (this.shake > 0) {
                    this.ctx.translate((Math.random() - 0.5) * this.shake, (Math.random() - 0.5) * this.shake);
                    this.shake *= 0.9;
                }
                this.drawGameObjects();
                this.ctx.restore();
            }
            
            drawHyperspaceTunnel(lvl) {
                const ctx = this.ctx;
                const cx = this.canvas.width / 2;
                const cy = this.canvas.height / 2;
                const maxRadius = Math.max(this.canvas.width, this.canvas.height) * 0.8;
                
                const breath = (Math.sin(Date.now() * 0.002 * (1 + this.gameSpeed * 0.1)) + 1) * 0.5;
                
                ctx.strokeStyle = lvl.accent;
                ctx.lineWidth = 1.5;
                optimizedShadow.apply(ctx, 15, lvl.accent);
                
                const baseRotation = this.frames * 0.005;

                for (let i = 0; i < 8; i++) {
                    const progress = ((this.tunnelOffset + i * 60) % 300) / 300;
                    const radius = progress * maxRadius;
                    if (radius < 50) continue;
                    ctx.globalAlpha = (1 - progress * 0.8) * (0.8 + breath * 0.2);
                    ctx.save();
                    ctx.translate(cx, cy);
                    ctx.rotate(baseRotation + (i * 0.1)); 
                    ctx.beginPath();
                    for(let k = 0; k < 5; k++) {
                        const angle = (k * 4 * Math.PI / 5) - (Math.PI / 2); 
                        const px = Math.cos(angle) * radius;
                        const py = Math.sin(angle) * radius;
                        if(k===0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                }
                
                optimizedShadow.clear(ctx);
                ctx.globalAlpha = 1;
                
                if (Math.random() > 0.95 && this.frames % 30 === 0) {
                    ctx.save();
                    ctx.globalAlpha = 0.05;
                    ctx.fillStyle = lvl.accent;
                    const y = Math.random() * this.canvas.height;
                    ctx.fillRect(0, y, this.canvas.width, 1);
                    ctx.restore();
                }
                
                this.backgroundParticles.forEach(p => {
                    p.y += p.speed * (1 + this.gameSpeed * 0.1);
                    if (p.y > this.canvas.height) { 
                        p.y = 0; 
                        p.x = Math.random() * this.canvas.width;
                        p.shape = Math.floor(Math.random() * 3);
                    }
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.opacity;
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(this.frames * 0.02);
                    if (p.shape === 0) { 
                        ctx.beginPath();
                        ctx.moveTo(0, -p.size);
                        ctx.lineTo(p.size, p.size);
                        ctx.lineTo(-p.size, p.size);
                        ctx.fill();
                    } else if (p.shape === 1) { 
                        ctx.beginPath();
                        ctx.moveTo(0, -p.size);
                        ctx.lineTo(p.size, 0);
                        ctx.lineTo(0, p.size);
                        ctx.lineTo(-p.size, 0);
                        ctx.fill();
                    } else { 
                        ctx.fillRect(-p.size/2, -p.size*1.5, p.size, p.size*3);
                        ctx.fillRect(-p.size*1.5, -p.size/2, p.size*3, p.size);
                    }
                    ctx.restore();
                });
                ctx.globalAlpha = 1;
                
                ctx.globalAlpha = 0.6;
                if (lvl.loaded && lvl.img && lvl.img.complete) {
                    try {
                        const img = lvl.img;
                        const canvasRatio = this.canvas.width / this.canvas.height;
                        const imgRatio = img.width / img.height;
                        let drawWidth, drawHeight, drawX, drawY;
                        if (canvasRatio > imgRatio) {
                            drawHeight = this.canvas.height;
                            drawWidth = img.width * (drawHeight / img.height);
                            drawX = (this.canvas.width - drawWidth) / 2;
                            drawY = 0;
                        } else {
                            drawWidth = this.canvas.width;
                            drawHeight = img.height * (drawWidth / img.width);
                            drawX = 0;
                            drawY = (this.canvas.height - drawHeight) / 2;
                        }
                        ctx.filter = 'blur(1px)';
                        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                        ctx.filter = 'none';
                    } catch (e) {}
                }
                ctx.globalAlpha = 1.0;
            }
            
            updateGameObjects() {
                const currentGap = this.getCurrentGap();
                if (this.frames % Math.floor(CONFIG.PILLAR_SPAWN_RATE / (1 + this.gameSpeed * 0.05)) === 0) {
                    const p = new Pillar(this.currentLevelIdx, currentGap);
                    this.obstacles.push(p);
                    if (Math.random() > (1 - CONFIG.ORB_SPAWN_CHANCE)) {
                        this.collectibles.push(new Orb(p.x + p.w / 2, p.top + p.gap / 2));
                    }
                }
                
                this.obstacles.forEach((o, i) => {
                    o.update(this.gameSpeed);
                    const hitboxReduction = CONFIG.HITBOX_OFFSET;
                    const pLeft = this.player.x - this.player.r + hitboxReduction;
                    const pRight = this.player.x + this.player.r - hitboxReduction;
                    const pTop = this.player.y - this.player.r + hitboxReduction;
                    const pBottom = this.player.y + this.player.r - hitboxReduction;
                    const pillarLeft = o.x;
                    const pillarRight = o.x + o.w;
                    const topPillarBottom = o.top;
                    const topPillarTop = 0;
                    const bottomPillarTop = o.top + o.gap;
                    const bottomPillarBottom = this.canvas.height;
                    const horizontalOverlap = pRight > pillarLeft && pLeft < pillarRight;
                    const hittingTopPillar = horizontalOverlap && pBottom > topPillarTop && pTop < topPillarBottom;
                    const hittingBottomPillar = horizontalOverlap && pTop < bottomPillarBottom && pBottom > bottomPillarTop;
                    if (hittingTopPillar || hittingBottomPillar) {
                        this.gameOver();
                    }
                    if (!o.marked && o.x + o.w < this.player.x) {
                        this.score++;
                        o.marked = true;
                        document.getElementById('scoreUi').innerText = this.score;
                        this.checkLevel();
                    }
                    if (o.x < -100) this.obstacles.splice(i, 1);
                });
                
                this.collectibles.forEach((c, i) => {
                    c.update(this.gameSpeed);
                    const dist = Math.hypot(this.player.x - c.x, this.player.y - c.y);
                    if (dist < this.player.r + c.r && !c.collected) {
                        this.score += 5;
                        document.getElementById('scoreUi').innerText = this.score;
                        c.collected = true;
                        this.triggerOrbGlitch();
                        this.hitStop = 3;
                        for (let k = 0; k < 20; k++) {
                            this.particles.push(new Particle(
                                c.x, c.y, 
                                '#ffd700', 8,
                                Math.random() > 0.6 ? 'hexagram' : 
                                Math.random() > 0.3 ? 'triangle' : 'diamond'
                            ));
                        }
                        if (this.settings.sfx) SFX.collect();
                        Haptics.collect();
                        this.collectibles.splice(i, 1);
                        this.checkLevel();
                    }
                    if (c.x < -50) this.collectibles.splice(i, 1);
                });
                
                this.player.update();
                
                this.particles.forEach((p, i) => {
                    p.update();
                    if (p.life <= 0) this.particles.splice(i, 1);
                });
            }
            
            drawGameObjects() {
                const currentLvlConfig = this.gameLevels[this.currentLevelIdx];
                this.obstacles.forEach(o => o.draw(this.ctx, currentLvlConfig));
                this.collectibles.forEach(c => c.draw(this.ctx));
                this.player.draw(this.ctx, currentLvlConfig);
                this.particles.forEach(p => p.draw(this.ctx));
            }
        }

        class Player {
            constructor() {
                this.x = window.innerWidth * 0.25;
                this.y = window.innerHeight / 2;
                this.vy = 0;
                this.r = CONFIG.PLAYER_RADIUS;
                this.rot = 0;
                this.trail = [];
                this.trailLength = game.isMobile ? 8 : 12;
                this.jumpCooldown = 0;
                this.scaleX = 1;
                this.scaleY = 1;
            }
            
            update() {
                this.vy += CONFIG.GRAVITY;
                this.y += this.vy;
                this.rot += 0.03;
                
                const stretch = Math.min(Math.abs(this.vy) * 0.04, 0.3);
                if (this.vy < 0) { 
                    this.scaleY = 1 + stretch;
                    this.scaleX = 1 - stretch * 0.5;
                } else { 
                    this.scaleY = 1 - stretch * 0.5;
                    this.scaleX = 1 + stretch;
                }

                if (this.y > window.innerHeight - this.r * 1.5) {
                    game.gameOver();
                }
                if (this.y < this.r * 1.5) { 
                    this.y = this.r * 1.5;
                    this.vy = 0; 
                }
                
                if (this.jumpCooldown > 0) {
                    this.jumpCooldown--;
                }
                
                if (game.frames % 2 === 0) {
                    this.trail.unshift({
                        x: this.x, 
                        y: this.y, 
                        r: this.r, 
                        life: 1.0,
                        rot: this.rot,
                        scaleX: this.scaleX,
                        scaleY: this.scaleY
                    });
                    if (this.trail.length > this.trailLength) this.trail.pop();
                }
                
                this.trail.forEach(t => t.life -= 0.05);
            }
            
            draw(ctx, conf) {
                const hue = (game.frames * 2) % 360;
                const strokeColor = `hsl(${hue}, 100%, 60%)`;
                const shadowColor = `hsl(${hue}, 100%, 50%)`;
                this.trail.forEach((t, i) => {
                    if (t.life > 0) {
                        ctx.save();
                        ctx.globalAlpha = t.life * 0.6;
                        ctx.translate(t.x, t.y);
                        ctx.scale(t.scaleX, t.scaleY);
                        ctx.rotate(t.rot + (this.vy * 0.05));
                        
                        const trailR = t.r * 0.7 * t.life;
                        const points = [];
                        for (let j = 0; j < 6; j++) {
                            const angle = (j * 60 - 90) * Math.PI / 180;
                            points.push({ 
                                x: Math.cos(angle) * trailR, 
                                y: Math.sin(angle) * trailR 
                            });
                        }
                        
                        optimizedShadow.apply(ctx, 20 * t.life, shadowColor);
                        ctx.strokeStyle = strokeColor;
                        ctx.lineWidth = 2 * t.life;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';

                        ctx.beginPath();
                        ctx.moveTo(points[0].x, points[0].y);
                        ctx.lineTo(points[2].x, points[2].y);
                        ctx.lineTo(points[5].x, points[5].y);
                        ctx.lineTo(points[3].x, points[3].y);
                        ctx.lineTo(points[1].x, points[1].y);
                        ctx.lineTo(points[4].x, points[4].y);
                        ctx.lineTo(points[0].x, points[0].y);
                        ctx.stroke();
                        
                        if (game.isMobile) {
                            ctx.lineWidth = 6 * t.life;
                            ctx.globalAlpha = t.life * 0.2;
                            ctx.stroke();
                        }
                        
                        ctx.restore();
                    }
                });
                ctx.globalAlpha = 1.0;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.scaleX, this.scaleY);
                ctx.rotate(this.rot + (this.vy * 0.05));
                
                const r = this.r * 1.2;
                const points = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (i * 60 - 90) * Math.PI / 180;
                    points.push({ x: Math.cos(angle) * r, y: Math.sin(angle) * r });
                }
                
                optimizedShadow.apply(ctx, 25, shadowColor);
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                ctx.lineTo(points[2].x, points[2].y);
                ctx.lineTo(points[5].x, points[5].y);
                ctx.lineTo(points[3].x, points[3].y);
                ctx.lineTo(points[1].x, points[1].y);
                ctx.lineTo(points[4].x, points[4].y);
                ctx.lineTo(points[0].x, points[0].y);
                ctx.stroke();
                
                if (game.isMobile) {
                    ctx.save();
                    ctx.strokeStyle = shadowColor;
                    ctx.lineWidth = 8;
                    ctx.globalAlpha = 0.3;
                    ctx.stroke();
                    ctx.restore();
                }

                const pulse = Math.sin(game.frames * 0.1) * 0.5 + 1;
                ctx.fillStyle = "#fff";
                optimizedShadow.apply(ctx, 40 * pulse, "#fff");
                ctx.beginPath();
                ctx.arc(0, 0, 3 * pulse, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
            
            jump() {
                if (this.jumpCooldown > 0) return;
                this.vy = CONFIG.PLAYER_JUMP_FORCE;
                this.jumpCooldown = game.isMobile ? 8 : 5;
                if (Math.random() > 0.7) {
                    GlitchFX.trigger(40, 'jump');
                }
                
                for (let i = 0; i < (game.isMobile ? 10 : 12); i++) {
                    const type = Math.random() > 0.7 ? 'hexagram' : Math.random() > 0.4 ? 'triangle' : 'circle';
                    game.particles.push(new Particle(
                        this.x, this.y, '#fff', 3, type
                    ));
                }
                
                if (game.settings.sfx) SFX.jump();
                Haptics.jump();
                GlitchFX.trigger(50, 'rgb');
            }
        }

        class Pillar {
            constructor(lvlIndex, currentGap) {
                this.x = window.innerWidth;
                this.w = CONFIG.PILLAR_WIDTH;
                this.gap = currentGap;
                const maxTop = window.innerHeight - this.gap - 50;
                const minTop = 30;
                this.top = Math.random() * (maxTop - minTop) + minTop;
                this.marked = false;
                this.lvl = lvlIndex;
                this.rotation = Math.random() * Math.PI * 2;
                this.innerPattern = Math.floor(Math.random() * 3);
                this.pulse = 0;
                this.hasWarning = game.isMobile && Math.random() > 0.5;
                this.warningAlpha = 1;
            }
            
            update(speed) { 
                this.x -= speed;
                this.pulse += 0.05;
                this.rotation += 0.005;
                if (this.hasWarning) {
                    this.warningAlpha -= 0.01;
                }
            }
            
            draw(ctx, conf) {
                const hue = (game.frames * 0.5 + this.x * 0.1) % 360;
                const mainColor = `hsl(${hue}, 100%, 60%)`;
                const innerColor = `hsl(${(hue + 60) % 360}, 100%, 70%)`;
                const glowColor = `hsl(${hue}, 100%, 50%)`;
                
                if (this.hasWarning && this.x < window.innerWidth * 0.7 && this.warningAlpha > 0) {
                    ctx.save();
                    ctx.globalAlpha = this.warningAlpha * 0.3;
                    ctx.fillStyle = '#ff003c';
                    ctx.fillRect(this.x - 10, 0, this.w + 20, window.innerHeight);
                    ctx.restore();
                }
                
                ctx.save();
                ctx.translate(this.x + this.w/2, 0);
                
                optimizedShadow.apply(ctx, 30, glowColor);
                ctx.strokeStyle = mainColor;
                ctx.lineWidth = 4;
                ctx.fillStyle = "rgba(0,0,0,0.7)";
                const topHeight = this.top + 10;
                ctx.beginPath();
                ctx.moveTo(-this.w/2, -10);
                ctx.lineTo(this.w/2, -10);
                
                const jagCount = 5;
                for (let i = 0; i <= jagCount; i++) {
                    const x = this.w/2 - (i * this.w/jagCount);
                    const y = -10 + (i % 2 === 0 ? 8 : -4);
                    ctx.lineTo(x, y);
                }
                
                ctx.lineTo(-this.w/2, topHeight);
                ctx.lineTo(-this.w/2, -10);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                if (game.isMobile) {
                    ctx.save();
                    ctx.lineWidth = 10;
                    ctx.globalAlpha = 0.2;
                    ctx.stroke();
                    ctx.restore();
                }
                
                ctx.save();
                ctx.translate(0, topHeight/2);
                ctx.rotate(this.rotation);
                ctx.globalAlpha = 0.4;
                ctx.strokeStyle = innerColor;
                ctx.lineWidth = 1.5;
                optimizedShadow.apply(ctx, 15, innerColor);
                
                if (this.innerPattern === 0) {
                    const size = Math.min(this.w, topHeight) * 0.3;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = Math.cos(angle) * size;
                        const y = Math.sin(angle) * size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                } else if (this.innerPattern === 1) {
                    const size = Math.min(this.w, topHeight) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size * 0.866, size * 0.5);
                    ctx.lineTo(-size * 0.866, size * 0.5);
                    ctx.closePath();
                    ctx.stroke();
                } else {
                    const size = Math.min(this.w, topHeight) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(-size, 0);
                    ctx.lineTo(size, 0);
                    ctx.moveTo(0, -size);
                    ctx.lineTo(0, size);
                    ctx.stroke();
                }
                ctx.restore();
                const botY = this.top + this.gap;
                const botHeight = window.innerHeight - botY + 10;
                
                ctx.beginPath();
                ctx.moveTo(-this.w/2, botY);
                ctx.lineTo(this.w/2, botY);
                for (let i = 0; i <= jagCount; i++) {
                    const x = this.w/2 - (i * this.w/jagCount);
                    const y = botY + (i % 2 === 0 ? -4 : 8);
                    ctx.lineTo(x, y);
                }
                
                ctx.lineTo(this.w/2, botY + botHeight);
                ctx.lineTo(-this.w/2, botY + botHeight);
                ctx.lineTo(-this.w/2, botY);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                if (game.isMobile) {
                    ctx.save();
                    ctx.lineWidth = 10;
                    ctx.globalAlpha = 0.2;
                    ctx.stroke();
                    ctx.restore();
                }
                
                ctx.save();
                ctx.translate(0, botY + botHeight/2);
                ctx.rotate(-this.rotation);
                ctx.globalAlpha = 0.4;
                ctx.strokeStyle = innerColor;
                ctx.lineWidth = 1.5;
                
                if (this.innerPattern === 0) {
                    const size = Math.min(this.w, botHeight) * 0.3;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = Math.cos(angle) * size;
                        const y = Math.sin(angle) * size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                } else if (this.innerPattern === 1) {
                    const size = Math.min(this.w, botHeight) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size * 0.866, size * 0.5);
                    ctx.lineTo(-size * 0.866, size * 0.5);
                    ctx.closePath();
                    ctx.stroke();
                } else {
                    const size = Math.min(this.w, botHeight) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(-size, 0);
                    ctx.lineTo(size, 0);
                    ctx.moveTo(0, -size);
                    ctx.lineTo(0, size);
                    ctx.stroke();
                }
                ctx.restore();
                
                ctx.restore();
                optimizedShadow.clear(ctx);
                ctx.globalAlpha = 1.0;
            }
        }

        class Orb {
            constructor(x, y) {
                this.x = x;
                this.y = y; 
                this.r = 9;
                this.collected = false;
                this.float = Math.random() * Math.PI * 2;
                this.pulse = 0;
                this.rotation = 0;
            }
            
            update(speed) {
                this.x -= speed;
                this.float += 0.1;
                this.pulse += 0.15;
                this.rotation += 0.02;
                this.y += Math.sin(this.float) * 0.8;
            }
            
            draw(ctx) {
                if (this.collected) return;
                if (Math.random() > 0.97) {
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = '#ff00ff';
                    ctx.fillRect(this.x - this.r, this.y - this.r, this.r * 2, this.r * 2);
                    ctx.restore();
                }
                
                const pulseSize = this.r + Math.sin(this.pulse) * 3;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                optimizedShadow.apply(ctx, 25, '#ffd700');
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
                ctx.stroke();
                
                optimizedShadow.apply(ctx, 30, '#fff');
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.9;
                const r = pulseSize * 0.7;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i * 60) * Math.PI / 180;
                    const x = Math.cos(angle) * r;
                    const y = Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
                
                ctx.fillStyle = '#fff';
                optimizedShadow.apply(ctx, 40, '#fff');
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize * 0.2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
        }

        class Particle {
            constructor(x, y, c, speed, type = 'circle') {
                this.x = x;
                this.y = y; 
                this.c = c;
                this.vx = (Math.random() - 0.5) * speed;
                this.vy = (Math.random() - 0.5) * speed;
                this.life = 1; 
                this.size = Math.random() * 3 + 2;
                this.type = type;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.2;
                this.glow = Math.random() > 0.5;
            }
            
            update() { 
                this.x += this.vx;
                this.y += this.vy; 
                this.vx *= 0.97;
                this.vy *= 0.97;
                this.life -= 0.03; 
                this.rotation += this.rotationSpeed;
                this.size *= 0.98;
                if (game.isMobile) {
                    this.life -= 0.01;
                }
            }
            
            draw(ctx) {
                if (this.life <= 0) return;
                if (game.isMobile && this.type !== 'hexagram') {
                    ctx.globalAlpha = this.life * 0.5;
                    ctx.fillStyle = this.c;
                    ctx.fillRect(this.x - this.size, this.y - this.size, 
                                this.size * 2, this.size * 2);
                    ctx.globalAlpha = 1;
                    return;
                }
                
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.c;
                
                if (this.glow && this.life > 0.3) {
                    optimizedShadow.apply(ctx, 20 * this.life, this.c);
                }
                
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                if (this.type === 'hexagram') {
                    const r = this.size * 0.8;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 'triangle') {
                    const r = this.size;
                    ctx.beginPath();
                    ctx.moveTo(0, -r);
                    ctx.lineTo(r * 0.866, r * 0.5);
                    ctx.lineTo(-r * 0.866, r * 0.5);
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 'diamond') {
                    const r = this.size;
                    ctx.beginPath();
                    ctx.moveTo(0, -r);
                    ctx.lineTo(r, 0);
                    ctx.lineTo(0, r);
                    ctx.lineTo(-r, 0);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
        }
        
        class Star {
            constructor() {
                this.x = Math.random() * window.innerWidth;
                this.y = Math.random() * window.innerHeight;
                this.size = Math.random() * 2;
                this.speed = Math.random() * 0.5 + 0.1;
                this.alpha = Math.random() * 0.5 + 0.2;
                this.twinkle = Math.random() * Math.PI * 2;
            }
            update() {
                this.y += this.speed;
                if (this.y > window.innerHeight) {
                    this.y = 0;
                    this.x = Math.random() * window.innerWidth;
                }
                this.twinkle += 0.05;
                this.alpha = 0.3 + Math.sin(this.twinkle) * 0.2;
            }
            draw(ctx) {
                const conf = game.gameLevels[game.currentLevelIdx];
                ctx.fillStyle = conf ? conf.accent : '#fff';
                ctx.globalAlpha = this.alpha;
                if (Math.random() > 0.7) {
                    ctx.fillRect(this.x - this.size/2, this.y, this.size, 1);
                    ctx.fillRect(this.x, this.y - this.size/2, 1, this.size);
                } else {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size/2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1.0;
            }
        }

        let game;
        document.addEventListener('DOMContentLoaded', () => {
            game = new Game();
        });
    </script>
</body>
</html>


            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* CRT Scanline Effect */
        .scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
            opacity: 0.4;
        }
        
        /* Vignette for ominous feel */
        .vignette {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, black 130%);
            pointer-events: none;
            z-index: 11;
        }

        /* UI Overlay */
        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 20;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            transition: opacity 0.3s ease;
            padding: 20px;
            box-sizing: border-box;
        }

        /* Start Screen Specifics */
        #startScreen {
            background-size: cover;
            background-position: center;
            /* Psychedelic Background Animation */
            animation: bgBreath 10s infinite alternate;
        }
        
        /* Dark overlay to make text pop on top of image */
        #startScreen::before {
            content: '';
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: -1;
        }

        @keyframes bgBreath {
            0% { transform: scale(1); filter: hue-rotate(0deg); }
            100% { transform: scale(1.05); filter: hue-rotate(45deg); }
        }

        .hidden {
            opacity: 0 !important;
            pointer-events: none !important;
            display: none !important;
        }

        /* Neon Buttons */
        .mystic-btn {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--primary);
            color: #fff;
            padding: 15px 50px;
            font-size: 1.2rem;
            font-family: 'Cinzel Decorative', cursive;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 4px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 15px var(--primary), inset 0 0 10px var(--primary);
            margin: 10px;
            min-width: 260px;
            position: relative;
            overflow: hidden;
            text-shadow: 0 0 5px #fff;
            animation: psychedelicBorder 4s infinite linear;
        }

        @keyframes psychedelicBorder {
            0% { border-color: #ff003c; box-shadow: 0 0 15px #ff003c; }
            25% { border-color: #ff00ff; box-shadow: 0 0 15px #ff00ff; }
            50% { border-color: #00ffff; box-shadow: 0 0 15px #00ffff; }
            75% { border-color: #ffd700; box-shadow: 0 0 15px #ffd700; }
            100% { border-color: #ff003c; box-shadow: 0 0 15px #ff003c; }
        }

        .mystic-btn:hover {
            background: #fff;
            color: #000;
            transform: scale(1.05);
            text-shadow: none;
        }

        .mystic-btn:active {
            transform: scale(0.95);
        }

        .title-text {
            font-family: 'Cinzel Decorative', cursive;
            font-size: 5rem;
            color: #fff;
            text-shadow: 0 0 10px var(--primary);
            margin-bottom: 10px;
            letter-spacing: -2px;
            animation: pulseNeon 3s infinite alternate;
        }

        @keyframes pulseNeon {
            0% { text-shadow: 0 0 10px var(--primary), 0 0 20px var(--primary); opacity: 1; }
            100% { text-shadow: 0 0 20px var(--primary), 0 0 40px var(--primary), 0 0 80px var(--primary); opacity: 0.9; }
        }

        /* NEW: Floating Animation for UI */
        @keyframes gentleFloat {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }

        .level-indicator {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            font-size: 1.5rem;
            font-family: 'Cinzel Decorative', serif;
            font-weight: 700;
            letter-spacing: 6px;
            color: #fff;
            z-index: 15;
            text-shadow: 0 0 10px #000;
            text-transform: uppercase;
            animation: gentleFloat 4s ease-in-out infinite; 
        }

        .score-display {
            position: absolute;
            top: 10%;
            width: 100%;
            text-align: center;
            font-size: 9rem;
            font-family: 'Cinzel Decorative', serif;
            color: rgba(255, 255, 255, 0.1);
            z-index: 5;
            pointer-events: none;
            mix-blend-mode: screen;
            font-weight: 900;
            animation: gentleFloat 6s ease-in-out infinite reverse;
        }

        .progress-bar {
            width: 300px;
            height: 4px;
            background: #222;
            margin: 20px 0;
            position: relative;
            box-shadow: 0 0 10px #000;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width 0.2s ease;
            box-shadow: 0 0 15px var(--primary);
        }

        .instructions {
            position: absolute;
            bottom: 100px;
            width: 100%;
            text-align: center;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 3px;
            z-index: 15;
            font-family: 'Orbitron', sans-serif;
            animation: fadeOut 5s ease-in-out forwards;
            animation-delay: 2s; 
            pointer-events: none;
        }

        @keyframes fadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; visibility: hidden; }
        }

        .pause-btn {
            position: absolute;
            top: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--primary);
            color: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            z-index: 25;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            pointer-events: auto;
            box-shadow: 0 0 10px var(--primary);
            transition: 0.3s;
        }
        
        .pause-btn:hover {
            background: var(--primary);
            color: #000;
            box-shadow: 0 0 20px var(--primary);
        }

        .stats-panel {
            position: absolute;
            top: 30px;
            left: 30px;
            background: rgba(0, 0, 0, 0.7);
            border-left: 3px solid var(--primary);
            padding: 10px 15px;
            font-size: 0.8rem;
            color: #ccc;
            z-index: 25;
            pointer-events: auto;
            font-family: 'Orbitron', monospace;
            text-align: left;
            backdrop-filter: blur(4px);
        }
        
        /* Custom File Upload Styling */
        .file-upload-label {
            display: inline-block;
            margin-top: 20px;
            padding: 10px 20px;
            border: 1px dashed #666;
            color: #888;
            cursor: pointer;
            font-size: 0.8rem;
            transition: 0.3s;
            font-family: 'Orbitron', sans-serif;
        }
        .file-upload-label:hover {
            border-color: var(--primary);
            color: var(--primary);
            box-shadow: 0 0 10px rgba(255, 0, 60, 0.2);
        }

        /* Mobile Controls */
        .mobile-controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 30;
        }

        .mobile-jump-area {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40%;
            pointer-events: auto;
            background: transparent;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .mobile-jump-indicator {
            background: rgba(255, 0, 60, 0.3);
            border: 2px solid rgba(255, 0, 60, 0.7);
            border-radius: 50%;
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 0.8rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            backdrop-filter: blur(5px);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.1); opacity: 0.9; }
            100% { transform: scale(1); opacity: 0.7; }
        }

        /* Responsive Styles */
        @media (max-width: 768px) {
            .title-text { font-size: 3.5rem !important; margin-bottom: 20px; }
            .score-display { font-size: 6rem !important; top: 8% !important; }
            .level-indicator { font-size: 1.2rem !important; bottom: 70px !important; letter-spacing: 4px !important; }
            .mystic-btn { padding: 12px 30px !important; font-size: 1rem !important; min-width: 220px !important; margin: 8px !important; }
            .instructions { bottom: 130px !important; font-size: 0.7rem !important; letter-spacing: 2px !important; }
            .stats-panel { top: 15px !important; left: 15px !important; font-size: 0.7rem !important; padding: 8px 12px !important; }
            .pause-btn { top: 15px !important; right: 15px !important; width: 45px !important; height: 45px !important; font-size: 1.2rem !important; }
            .progress-bar { width: 250px !important; }
            #gameOverScreen .title-text { font-size: 3rem !important; }
            #pauseScreen .title-text { font-size: 2.5rem !important; }
            #settingsScreen .title-text { font-size: 2rem !important; }
        }

        @media (max-width: 480px) {
            .title-text { font-size: 2.8rem !important; }
            .score-display { font-size: 5rem !important; top: 6% !important; }
            .level-indicator { font-size: 1rem !important; bottom: 60px !important; }
            .mystic-btn { min-width: 200px !important; padding: 10px 25px !important; font-size: 0.9rem !important; letter-spacing: 2px !important; }
            .instructions { font-size: 0.65rem !important; letter-spacing: 1.5px !important; bottom: 140px !important; }
            .progress-bar { width: 200px !important; }
        }

        @media (orientation: portrait) and (max-height: 700px) {
            .title-text { font-size: 2.5rem !important; }
            .score-display { font-size: 4.5rem !important; }
            .level-indicator { bottom: 50px !important; }
            .instructions { bottom: 100px !important; }
        }

        @media (orientation: landscape) {
            .title-text { font-size: 3rem !important; }
            .score-display { font-size: 4rem !important; top: 5% !important; }
            .level-indicator { bottom: 20px !important; font-size: 1rem !important; }
            .mystic-btn { padding: 8px 20px !important; margin: 5px !important; min-width: 180px !important; }
            .instructions { bottom: 70px !important; font-size: 0.6rem !important; }
            .mobile-jump-area { height: 50%; }
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .title-text { font-size: 2.2rem !important; }
            .score-display { font-size: 3rem !important; }
            .mystic-btn { padding: 6px 15px !important; font-size: 0.8rem !important; min-width: 150px !important; }
        }

        /* Safe area padding */
        @supports (padding: max(0px)) {
            .ui-layer {
                padding-left: max(20px, env(safe-area-inset-left));
                padding-right: max(20px, env(safe-area-inset-right));
                padding-top: max(20px, env(safe-area-inset-top));
                padding-bottom: max(20px, env(safe-area-inset-bottom));
            }
        }

        .loader {
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid var(--primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="scanlines"></div>
        <div class="vignette"></div>
        
        <div id="scoreUi" class="score-display">0</div>
        <div id="levelUi" class="level-indicator">INITIATION</div>
        
        <div id="mobileControls" class="mobile-controls hidden">
            <div class="mobile-jump-area">
                <div class="mobile-jump-indicator">TAP</div>
            </div>
        </div>
        
        <div id="startScreen" class="ui-layer" style="background-image: url('https://lh3.googleusercontent.com/d/1BXrXXd9TKSqCFNwvS-cJpNORbyvP6fkR=s0');">
            <h1 class="title-text">Sex Magick</h1>
            <p style="letter-spacing: 8px; color: #ff003c; margin-bottom: 40px; font-size: 1.1rem; text-shadow: 0 0 10px #ff003c; font-family: 'Cinzel Decorative', cursive;">Do Your Will Foo</p>
            
            <div id="loadingMsg">
                <div class="loader"></div>
                <p id="loadingText" style="letter-spacing: 4px; font-size: 0.9rem; margin-top: 15px; font-family: 'Cinzel Decorative';">CHARGING SIGIL...</p>
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill"></div>
                </div>
            </div>

            <div id="menuButtons" class="hidden">
                <button id="startBtn" class="mystic-btn">INVOKE</button>
                <button id="settingsBtn" class="mystic-btn">RITES</button>
                
                <label for="fileUpload" class="file-upload-label">
                    [ OPTIONAL: LOAD LOCAL MP3 ]
                </label>
                <input type="file" id="fileUpload" accept="audio/*" style="display:none;">
                <p id="trackName" style="margin-top: 5px; font-size: 0.6rem; color: #555;">SOURCE: GITHUB CDN</p>
            </div>
        </div>

        <div id="gameOverScreen" class="ui-layer hidden" style="background: rgba(0,0,0,0.85);">
            <h1 class="title-text" style="color: #ff003c; font-size: 4rem;">Good job foo</h1>
            <p style="font-size: 1.2rem; letter-spacing: 4px; margin-bottom: 20px; font-family: 'Cinzel Decorative';">RITUAL FAILED</p>
            <p class="text-xl mb-6 text-gray-300">WILL: <span id="finalScore" style="color: #fff; font-weight:bold; text-shadow: 0 0 10px #fff;">0</span></p>
            <p id="highScoreMsg" style="color: #ffd700; margin-bottom: 30px; font-size: 1rem; letter-spacing: 2px;"></p>
            <button id="restartBtn" class="mystic-btn">REINCARNATE</button>
        </div>

        <div id="pauseScreen" class="ui-layer hidden">
            <h1 class="title-text" style="font-size: 3.5rem; color: #ffd700;">MEDITATION</h1>
            <button id="resumeBtn" class="mystic-btn">RESUME</button>
            <button id="menuBtn" class="mystic-btn">ABORT</button>
        </div>

        <div id="settingsScreen" class="ui-layer hidden" style="background: rgba(0,0,0,0.9);">
            <h1 class="title-text" style="font-size: 2.5rem;">SACRED RITES</h1>
            <div style="width: 320px; margin: 20px 0; background: rgba(20,20,20,0.8); padding: 20px; border: 1px solid var(--primary);">
                <div style="display: flex; justify-content: space-between; margin: 15px 0; border-bottom: 1px solid #444; padding-bottom: 10px;">
                    <span>CHANT (MUSIC)</span>
                    <input type="checkbox" id="musicToggle" checked style="accent-color: var(--primary);">
                </div>
                <div style="display: flex; justify-content: space-between; margin: 15px 0; border-bottom: 1px solid #444; padding-bottom: 10px;">
                    <span>RESONANCE (SFX)</span>
                    <input type="checkbox" id="sfxToggle" checked style="accent-color: var(--primary);">
                </div>
                <div style="display: flex; justify-content: space-between; margin: 15px 0;">
                    <span>KUNDALINI (VIBE)</span>
                    <input type="checkbox" id="vibrationToggle" checked style="accent-color: var(--primary);">
                </div>
            </div>
            <button id="backBtn" class="mystic-btn">RETURN</button>
        </div>

        <button id="pauseBtn" class="pause-btn hidden">||</button>
        
        <div id="statsPanel" class="stats-panel">
            <div style="color: var(--primary); font-weight: bold; margin-bottom: 5px;">:: GNOSIS ::</div>
            FPS: <span id="fpsCounter" style="color: #fff;">0</span><br>
            AUDIO: <span id="audioStatus" style="color: #fff;">STANDBY</span>
        </div>

        <div id="instructions" class="instructions hidden">
            [ TAP / SPACE TO ASCEND ]
        </div>
    </div>

    <script>
        const CDN_PREFIX = "https://cdn.jsdelivr.net/gh/bookthief666/93-protocol-game-assets-@662f3d608769e9e945295ac00d668447d974dc5c/";

        const CONFIG = {
            DEBUG: false,
            MENU_MUSIC: CDN_PREFIX + "iamerror%20-%20The%20Zelda%20Song%20(Hyr00l).mp3",
            GAME_PLAYLIST: [
                CDN_PREFIX + "iamerror%20-%20Hyr00l%20Rough.mp4",
                CDN_PREFIX + "bookthief%F0%9F%A5%80%20-%20booothief-%20All%20gay%F0%9F%98%87%202024-07-10%2001_11%20(1).m4a",
                CDN_PREFIX + "Vae!%20Puto%20Deus%20Fio!%20(3).mp3",
                CDN_PREFIX + "IAMERROR%20-%20The%20Iceclops%20Cometh.mp3",
                CDN_PREFIX + "Forest%20of%20Fellatio%20%5BTTn3kjGwXi0%5D.mp3",
                CDN_PREFIX + "LEX_LFL_80_wurli_loop_ate_bit_Cm.wav",
                CDN_PREFIX + "iamerror%20-%20The%20Zelda%20Song%20(Hyr00l).mp3"
            ],
            BASE_URL: "https://lh3.googleusercontent.com/d/",
            IMG_SUFFIX: "=s0",
            
            // EASIER SETTINGS:
            INITIAL_GAME_SPEED: 2.5,
            SPEED_INCREASE_PER_LEVEL: 0.15,
            PILLAR_SPAWN_RATE: 120,
            PILLAR_WIDTH: 45,
            PILLAR_GAP: 250, 
            PILLAR_GAP_DECREASE_PER_5_LEVELS: 8, 
            MIN_PILLAR_GAP: 180, 
            ORB_SPAWN_CHANCE: 0.5,
            PLAYER_JUMP_FORCE: -6.5,
            GRAVITY: 0.20,
            
            // Responsive settings
            PLAYER_RADIUS: 16, 
            HITBOX_OFFSET: 4, 
            MOBILE_CONTROL_DEADZONE: 50,
        };
        const originalLevels = [
            { name: "MALKUTH", id: "1jI7bl3hsVOuzYf6u35L4bhHq5JUiBDa1" },
            { name: "YESOD", id: "1tHgxNvDO5md4z24hS81eTa9uva25mtr5" },
            { name: "HOD", id: "1Mtp6cP6lwGbPRhLWjQKKDijrLX53K4UR" },
            { name: "NETZACH", id: "1y1i5lxL1jVp37bIz1mtJh4-Puce-E5k0" },
            { name: "TIPHARETH", id: "12png0vOPyJC1Ab4Vffcw2R_K-yRw1sqj" },
            { name: "GEBURAH", id: "1le2Hox1ORxhL28fv7WujO0410vM6jUEJ" },
            { name: "CHESED", id: "1Gsq1xSx9ivfVEq6W2nCMrO-dOIMrSYrW" },
            { name: "DA'ATH", id: "1o601hrLi5RpuGL_kiVEoPXxXk2SCbM2z" },
            { name: "BINAH", id: "1iSYJfPsaYjA1rmRTsujLcn1Do-lBydF7" },
            { name: "CHOKMAH", id: "1PvOC62nv5HdsE1cuCF8RENY9Z8HTabn7" },
            { name: "KETHER", id: "1Ym_eyrXJEQUBA7Lg_2oUc6dQ-gy9yfGs" }
        ];
        const newImageIDs = [
            "1pJ5CUGyKXgkSgEREkKos1Kch5FmfUyxE", "1spT4HpO_4q9joE4x6bLjZQRlFTS9j-ie", "1YGzyjcjiCoPCLbYjJEiqT8USUhe4S6hM", "1ELjoJU7KDC88nUk_Vs57OKUG9oLl5E8N",
            "1faa2c3QFWhZ8UgvyZ_ZrlnyFsnsKRclm", "10W5oYkoqB9LC3YjvB_aozR0kG3hWaHka", "1l9Jdm0EQh8sgWh1W0wsXQCzrQM19Bfm9", "1BrHTF2dvfbRkyYfXAbPUiujwE1AJskY4",
            "1KqV8IYF7KDbmgHS3ph6eRQKl4uAAFG_u", "1sZ02UH_vb1xLaOvyETqptc5FuvOtVKd4", "1hLKOGYXCBemcIKt8OLEX4dHTn6bd88cr", "1g_DQeG6qldMBxHzZ82MOVoxk9APwb4NO",
            "1-SIvE5EZyUd7FKXJ7eyB4JCrtOpQoF18", "1S4y4YSCjxSb-b_U1BfMw_0PhabJ-METm", "1OL-kWl-TJNcZFPcsCAtynW2NWp-YYjGd", "1ApPgou40N2Q6GlNKNuyoQ2Gk5DqAfmw_",
            "1OeH1GMu2rDcwzdtWFZSB1WWe0OjkmxV0", "12Z92v9Mu9yNOnDTtK-bjMRZ8_2BAW2eW", "1Erf3DKxZpfbG57oGcUCjuHIhajsweLZz", "1qK22CJhJ1XgElL156uOQxYrucaRG16p0",
            "1euwdAWg-xQw7isR-JAiZ-krXQXOS8pi0", "1A3hT3mJibINtsr8CVxTmp71QsYgPB2JZ", "1QUVr-RK2kP7IIAuy0wX3pOZRQuyr-o-e", "1eF02YMyYBcgx7Ga20pXgoltzWXPYznfD",
            "1zx1vrrbuSA4xCFKXAHgXbkG1rX8PUPel", "1ds1iqXf90gy9PUFs80t4QOxamkJj0u1I", "14-t6dPPv5MeXe7LWPIp7Tjc8x4w5Vj2d", "1pUtIizMzVhjzB46dhah5mgz6Tr-vaSLO",
            "1ZOEkUW8q2s5zerS7BubYJU69RHk7_Zlo", "15ZHj0fLYu-4rEQy43BMJKDgXnnQ5FeyP", "1ZzgVT0O6XQzW3DUP4i1aoKd_DD5wV5LZ", "1rZHZM0bR_j6uiYZLS82J0BkbIfEUoXvY",
            "1CNrQ_EeMXQgHJGXxe7EHysQi_A0A9UE7", "1ubCqIg7ETOIsHGfBjQfVsRzjlZIpBP6E", "1pojzjR-uiQ0oTHRJxXXCW_w0hlJUCqyb", "1SnclBlH6sflhaTWzFhbcNedzNeh25-BV",
            "1thfc-9DnM4GhCi0zTbcX4MH-yaQEpomX", "1BXrXXd9TKSqCFNwvS-cJpNORbyvP6fkR", "1D1bOksatIt6Jw6Zq8Sbmhbq_GC_2EQHh", "1eP_Xnk80YnL3w3Q69wQmVo9_F0OaA3Wo",
            "1ARDOipcr0lB1GYf3gmhqlHXlpC23Q2JE", "1io39jfggXQl-OyvSFGIpgOtoIzHbml3M", "1o0rJmx3vEKITMx1ixP5iruOX2ujOT6VO", "1Irw61utgSGdip21OgTcYqz56LpWWS9fb",
            "19V2ObVoQn9R9bt1ZgMNEBJokaAjYdX_9", "1WWvLnkkPBN7Q0ZsGi16FL1anhPlti3Qd", "1HoYqC0SLc3nrSDnoW9KJ2-z8AnRWIz5M", "1oS0J3F-zh5H48-Qs5Mrm10dPR993kF-b",
            "1bRwsBEuZiAIZW_5f3WOZVI6-KVnCEslk", "1GLza2_RmR4c_KD_KGxbXPOoCAw9SITKl", "1uWFSChozQmHEnuJwXqiPNApXuAwPAzKS", "1t2hNBEudzIo19kuP8ksPY_cNetDdTd8P",
            "1KhMBL7a3NSggVerbyy53fQ-dLq11adwj", "1wgxalTR68YM7oIku8JYZYKtG50atEnG_", "1BceMgnHgVn9U_7EYnXQu9HDwEQY1UBa_", "14_iwYDQjp34-R_iby8QadKnI9m3zVnOu",
            "1cZ_ci9J80jnqCAdag8SQofYZw1dfsX3C", "15z3bGrCqUy8SQjX1dO5C1vlN3y4-soai", "10xAFw98B39Ou0SSeB4eWyoY2D_OLLPgz", "1CexZQw11p33u1-YA7JhPAkGV6NBCgd6e",
            "16t1EdHfHRpb7GmqNAfo2iKKm57qLfbKn", "12wQOhUztVCVEFV21fPDq-JXGi5zxdkeQ", "1-0u9JUH0oUHD1--5iaySxRpO_PuyxkH6", "1wnITY3i6XxOr1b3l6P0cT10LkEHQauO5"
        ].filter((value, index, self) => self.indexOf(value) === index);
        const esotericNames = [
            "KUNDALINI", "HIEROS GAMOS", "SACRED UNION", "RED TINCTURE", "WHITE GLUTEN", 
            "CUP OF BABALON", "BLOOD OF SAINTS", "CITY OF PYRAMIDS", "NIGHT OF PAN", 
            "HADIT'S FLAME", "NUIT'S EMBRACE", "LAW OF THELEMA", "LOVE UNDER WILL", 
            "GREAT WORK", "STONE OF WISE", "ELIXIR OF LIFE", "RED LION", "WHITE EAGLE",
            "ABRAHADABRA", "LASHTAL", "KA", "BA", "KHU", "SCARLET WOMAN", "THE BEAST",
            "AEON OF HORUS", "93", "AGAPE", "THELEMA", "VIA OVUM", "SPERMATOZOON",
            "HOMUNCULUS", "DIVINE EROS", "TANTRA", "YONI", "LINGAM", "O.T.O.", "A.'.A.'.",
            "STAR SAPPHIRE", "MASS OF PHOENIX", "LIBER AL", "RESH", "SAMEKH", "TZADDI"
        ];
        let MASTER_POOL = [...originalLevels];
        
        const palette = ["#ff003c", "#ff00ff", "#9d00ff", "#00f0ff", "#00ff9d", "#d4ff00", "#ff8800"];
        newImageIDs.forEach((id, index) => {
            const nameIndex = index % esotericNames.length;
            MASTER_POOL.push({
                name: esotericNames[nameIndex],
                id: id,
                color: "#000",
                accent: palette[index % palette.length],
                img: null,
                loaded: false
            });
        });
        const GameState = {
            START: 'start',
            LOADING: 'loading',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAME_OVER: 'gameover',
            SETTINGS: 'settings'
        };
        // Detect mobile device
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Mobile-optimized shadow rendering
        const optimizedShadow = {
            apply(ctx, blur, color) {
                if (isMobile) {
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = 'transparent';
                } else {
                    ctx.shadowBlur = blur;
                    ctx.shadowColor = color;
                }
            },
            clear(ctx) {
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }
        };

        // Glitch Effect System (Lightweight)
        const GlitchFX = {
            active: false,
            duration: 0,
            intensity: 1,
            type: 'rgb',
            
            rgbSplit(ctx, intensity) {
                const offset = Math.floor(Math.random() * 3 * intensity);
                const rOffset = Math.random() > 0.5 ? offset : -offset;
                const gOffset = Math.random() > 0.5 ? offset : -offset;
                const bOffset = Math.random() > 0.5 ? offset : -offset;
                if (Math.random() > 0.3) return null;
                return {
                    rOffset, gOffset, bOffset,
                    draw: function(ctx, width, height) {
                        const imageData = ctx.getImageData(0, 0, width, height);
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = width;
                        tempCanvas.height = height;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.putImageData(imageData, 0, 0);
                        
                        ctx.save();
                        ctx.globalCompositeOperation = 'screen';
                        ctx.globalAlpha = 0.8;
                        ctx.drawImage(tempCanvas, rOffset, 0);
                        ctx.globalAlpha = 0.8;
                        ctx.drawImage(tempCanvas, 0, gOffset);
                        ctx.globalAlpha = 0.8;
                        ctx.drawImage(tempCanvas, bOffset, bOffset);
                        ctx.restore();
                    }
                };
            },
            
            staticEffect(ctx, intensity) {
                ctx.save();
                ctx.globalAlpha = 0.1 * intensity;
                for (let i = 0; i < 5; i++) { 
                    const x = Math.random() * ctx.canvas.width;
                    const y = Math.random() * ctx.canvas.height;
                    const size = Math.random() * 10 * intensity + 2;
                    ctx.fillStyle = Math.random() > 0.5 ? '#ff003c' : '#00ffff';
                    ctx.fillRect(x, y, size, 1);
                    if (Math.random() > 0.7) {
                        ctx.fillStyle = Math.random() > 0.5 ? '#ff00ff' : '#00ff9d';
                        ctx.fillRect(x, y + 2, 1, size);
                    }
                }
                ctx.restore();
            },
            
            scanlineDistort(ctx, intensity) {
                if (Math.random() > 0.5) return;
                ctx.save();
                ctx.globalAlpha = 0.05 * intensity;
                ctx.fillStyle = '#fff';
                const lineCount = Math.floor(3 * intensity);
                for (let i = 0; i < lineCount; i++) {
                    const y = Math.floor(Math.random() * ctx.canvas.height);
                    const height = Math.random() * 2 + 1;
                    const wave = Math.sin(Date.now() * 0.01 + i) * 10 * intensity;
                    ctx.fillRect(0, y, ctx.canvas.width, height);
                    ctx.fillRect(wave, y + 5, ctx.canvas.width, 1);
                }
                ctx.restore();
            },
            
            blockDisplace(ctx, intensity) {
                if (Math.random() > 0.7) return;
                ctx.save();
                ctx.globalAlpha = 0.3 * intensity;
                for (let i = 0; i < 2; i++) {
                    const x = Math.random() * ctx.canvas.width;
                    const y = Math.random() * ctx.canvas.height;
                    const width = Math.random() * 50 * intensity + 20;
                    const height = Math.random() * 50 * intensity + 20;
                    const offsetX = (Math.random() - 0.5) * 10 * intensity;
                    const offsetY = (Math.random() - 0.5) * 10 * intensity;
                    ctx.fillStyle = Math.random() > 0.5 ? '#ff003c' : '#00ffff';
                    ctx.fillRect(x + offsetX, y + offsetY, width, height);
                }
                ctx.restore();
            },
            
            apply(ctx, currentTime) {
                if (!this.active || this.duration <= 0) return;
                const progress = this.duration / 100;
                this.intensity = Math.min(1, progress * 2);
                if (Math.random() > 0.5) this.staticEffect(ctx, this.intensity);
                if (Math.random() > 0.6) this.scanlineDistort(ctx, this.intensity);
                if (Math.random() > 0.7) this.blockDisplace(ctx, this.intensity);
                if (Math.random() > 0.8) {
                    const rgbEffect = this.rgbSplit(ctx, this.intensity);
                    if (rgbEffect) rgbEffect.draw(ctx, ctx.canvas.width, ctx.canvas.height);
                }
                this.duration -= 16;
                if (this.duration <= 0) {
                    this.active = false;
                    this.intensity = 1;
                }
            },
            
            trigger(duration = 100, type = 'all') {
                this.active = true;
                this.duration = duration;
                this.type = type;
                this.intensity = 1;
            }
        };

        const SFX = {
            audioContext: null,
            init() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
            },
            playTone(freq, type, duration, vol, detune = 0) {
                if (!game?.settings?.sfx) return;
                if (!this.audioContext) this.init();
                if (this.audioContext.state === 'suspended') this.audioContext.resume();
                
                try {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    
                    osc.type = type;
                    osc.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                    osc.detune.setValueAtTime(detune, this.audioContext.currentTime);
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    gain.gain.setValueAtTime(vol, this.audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                    
                    osc.start();
                    osc.stop(this.audioContext.currentTime + duration);
                } catch(e){}
            },
            jump() { 
                this.playTone(400, 'square', 0.08, 0.1);
                this.playTone(600, 'sine', 0.05, 0.05, 100);
            },
            collect() { 
                this.playTone(800, 'sine', 0.2, 0.1);
                this.playTone(1200, 'triangle', 0.1, 0.05, 50);
            },
            crash() { 
                this.playTone(100, 'sawtooth', 0.5, 0.3);
                this.playTone(80, 'square', 0.3, 0.2, -100);
            },
            levelUp() { 
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.5);
                osc.connect(gain);
                gain.connect(this.audioContext.destination);
                gain.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                osc.start();
                osc.stop(this.audioContext.currentTime + 0.5);
            }
        };

        const Haptics = {
            jump() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([15]);
                }
            },
            collect() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([30, 20, 30]);
                }
            },
            crash() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([150, 30, 80, 30, 40]);
                }
            },
            levelUp() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([80, 20, 80, 20, 80]);
                }
            }
        };

        const AudioSys = {
            bgm: null,
            localBlobUrl: null,
            currentMode: 'none', 
            retryCount: 0,
            
            setStatus(msg) {
                const el = document.getElementById('audioStatus');
                if (el) {
                    el.textContent = msg;
                    el.style.color = '#fff';
                    setTimeout(() => el.style.color = 'var(--primary)', 200);
                }
            },

            init() {
                this.setupAudioElement(CONFIG.MENU_MUSIC);
                this.currentMode = 'menu';
                this.setStatus("MENU AUDIO RDY");
            },

            setupAudioElement(src) {
                if (this.bgm) {
                    this.bgm.pause();
                    this.bgm.src = "";
                    this.bgm.load();
                }
                this.bgm = new Audio();
                this.bgm.src = src;
                this.bgm.loop = true;
                this.bgm.volume = 0.8;
                this.bgm.preload = "auto";
                
                this.bgm.onwaiting = () => this.setStatus("BUFFERING...");
                this.bgm.onplaying = () => {
                    this.setStatus("PLAYING");
                    this.retryCount = 0;
                };
                
                this.bgm.onerror = (e) => {
                    console.warn("Audio error:", e);
                    this.setStatus("LOAD ERROR");
                };
            },

            loadLocalFile(file) {
                if (this.localBlobUrl) URL.revokeObjectURL(this.localBlobUrl);
                this.localBlobUrl = URL.createObjectURL(file);
                this.setupAudioElement(this.localBlobUrl);
                this.setStatus("FILE LOADED");
            },
            
            switchToGameMusic() {
                if (this.localBlobUrl) return;
                const randomIndex = Math.floor(Math.random() * CONFIG.GAME_PLAYLIST.length);
                const track = CONFIG.GAME_PLAYLIST[randomIndex];
                this.currentMode = 'game';
                this.setStatus("LOADING TRK " + (randomIndex + 1));
                this.setupAudioElement(track);
                this.play();
            },

            switchToMenuMusic() {
                if (this.localBlobUrl) return;
                this.currentMode = 'menu';
                this.setStatus("LOADING MENU");
                this.setupAudioElement(CONFIG.MENU_MUSIC);
            },
            
            play() {
                if (!this.bgm) return;
                const playPromise = this.bgm.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => this.setStatus("PLAYING")).catch(error => {
                        console.warn("Play failed:", error);
                        this.setStatus("AUTOPLAY BLOCK");
                    });
                }
            },
            
            pause() { if (this.bgm) { this.bgm.pause(); this.setStatus("PAUSED"); } },
            resume() { if (this.bgm && this.bgm.paused) { this.bgm.play(); this.setStatus("RESUMED"); } },
            stop() { if (this.bgm) { this.bgm.pause(); this.bgm.currentTime = 0; this.setStatus("STOPPED"); } }
        };

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.root = document.documentElement;
                
                this.state = GameState.START;
                this.currentLevelIdx = 0;
                this.frames = 0;
                this.score = 0;
                this.highScore = localStorage.getItem('93protocol_highscore') || 0;
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED;
                this.shake = 0;
                this.lastFrameTime = 0;
                this.fps = 0;
                // Responsive properties
                this.isMobile = isMobile;
                this.aspectRatio = 16/9;
                this.baseWidth = 800;
                this.baseHeight = 450;
                this.scaleFactor = 1;
                // Glitch effect properties
                this.glitchEffect = false;
                this.glitchTimer = 0;
                this.glitchDuration = 300;
                
                // Hyperspace tunnel properties
                this.tunnelOffset = 0;
                this.tunnelSpeed = 0.5;
                
                // Hitstop property
                this.hitStop = 0;

                // Screen flash effect
                this.screenFlash = null;
                this.backgroundParticles = [];
                
                this.player = null;
                this.particles = [];
                this.stars = [];
                this.obstacles = [];
                this.collectibles = [];
                this.gameLevels = []; 
                
                this.settings = { music: true, sfx: true, vibration: true };
                
                this.loadSettings();
                this.initEventListeners();
                this.resizeCanvas();
                this.preloadAllImages();
                this.createBackgroundParticles();
                
                AudioSys.init();
                SFX.init();
            }
            
            createBackgroundParticles() {
                for (let i = 0; i < 25; i++) { // Fewer but more distinct runes
                    this.backgroundParticles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        z: Math.random() * 2 + 0.5,
                        size: Math.random() * 3 + 2,
                        speed: Math.random() * 0.5 + 0.1,
                        color: palette[Math.floor(Math.random() * palette.length)],
                        opacity: Math.random() * 0.4 + 0.1,
                        shape: Math.floor(Math.random() * 3) // 0=Tri, 1=Diamond, 2=Rune
                    });
                }
            }
            
            triggerOrbGlitch() {
                GlitchFX.trigger(80, 'orb');
                this.screenFlash = {
                    active: true,
                    duration: 10,
                    color: '#ffd700',
                    intensity: 0.3
                };
            }
            
            triggerLevelUpGlitch() {
                GlitchFX.trigger(150, 'level');
                this.screenFlash = {
                    active: true,
                    duration: 20,
                    color: this.gameLevels[this.currentLevelIdx]?.accent || '#ff003c',
                    intensity: 0.4
                };
            }
            
            triggerDeathGlitch() {
                GlitchFX.trigger(200, 'death');
                this.screenFlash = {
                    active: true,
                    duration: 30,
                    color: '#ff003c',
                    intensity: 0.6
                };
            }
            
            applyScreenFlash() {
                if (!this.screenFlash || !this.screenFlash.active) return;
                this.ctx.save();
                this.ctx.fillStyle = this.screenFlash.color;
                this.ctx.globalAlpha = this.screenFlash.intensity * (this.screenFlash.duration / 30);
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.restore();
                
                this.screenFlash.duration--;
                if (this.screenFlash.duration <= 0) {
                    this.screenFlash.active = false;
                }
            }
            
            initEventListeners() {
                document.getElementById('fileUpload').addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) AudioSys.loadLocalFile(file);
                });
                window.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && this.state === GameState.PLAYING) this.playerJump();
                    else if (e.code === 'Escape') this.togglePause();
                });
                window.addEventListener('mousedown', (e) => {
                    if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'LABEL' && this.state === GameState.PLAYING) this.playerJump();
                });
                window.addEventListener('touchstart', (e) => {
                    if (this.state === GameState.PLAYING) {
                        e.preventDefault();
                        const touchY = e.touches[0].clientY;
                        if (touchY > window.innerHeight * 0.6) {
                            this.playerJump();
                        }
                    }
                }, { passive: false });
                document.getElementById('startBtn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (this.settings.music) AudioSys.switchToGameMusic();
                    this.startGame();
                });
                document.getElementById('restartBtn').addEventListener('click', (e) => {
                     e.stopPropagation();
                     if (this.settings.music) AudioSys.switchToGameMusic();
                     this.restartGame();
                });
                document.getElementById('pauseBtn').addEventListener('click', (e) => { e.stopPropagation(); this.togglePause(); });
                document.getElementById('resumeBtn').addEventListener('click', (e) => { e.stopPropagation(); this.togglePause(); });
                document.getElementById('menuBtn').addEventListener('click', (e) => { e.stopPropagation(); this.returnToMenu(); });
                document.getElementById('settingsBtn').addEventListener('click', (e) => { e.stopPropagation(); this.showSettings(); });
                document.getElementById('backBtn').addEventListener('click', (e) => { e.stopPropagation(); this.hideSettings(); });
                
                document.getElementById('musicToggle').addEventListener('change', (e) => {
                    this.settings.music = e.target.checked;
                    this.saveSettings();
                    if (!this.settings.music) AudioSys.stop();
                    else if (this.state === GameState.PLAYING) AudioSys.play();
                });
                document.getElementById('sfxToggle').addEventListener('change', (e) => {
                    this.settings.sfx = e.target.checked;
                    this.saveSettings();
                });
                document.getElementById('vibrationToggle').addEventListener('change', (e) => {
                    this.settings.vibration = e.target.checked;
                    this.saveSettings();
                });
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            loadSettings() {
                const saved = localStorage.getItem('93protocol_settings');
                if (saved) this.settings = { ...this.settings, ...JSON.parse(saved) };
                document.getElementById('musicToggle').checked = this.settings.music;
                document.getElementById('sfxToggle').checked = this.settings.sfx;
                document.getElementById('vibrationToggle').checked = this.settings.vibration;
            }
            
            saveSettings() { localStorage.setItem('93protocol_settings', JSON.stringify(this.settings));
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.calculateScaleFactor();
                this.adjustForScreenSize();
            }
            
            calculateScaleFactor() {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const targetRatio = 16/9;
                const currentRatio = width/height;
                if (currentRatio > targetRatio) {
                    this.scaleFactor = height / this.baseHeight;
                } else {
                    this.scaleFactor = width / this.baseWidth;
                }
                
                this.scaleFactor = Math.max(0.6, Math.min(this.scaleFactor, 1.5));
            }
            
            adjustForScreenSize() {
                const screenHeight = this.canvas.height;
                let baseGap = CONFIG.PILLAR_GAP;
                if (screenHeight < 600) {
                    baseGap = Math.min(270, baseGap * 1.08);
                } else if (screenHeight > 800) {
                    baseGap = Math.max(240, baseGap * 0.95);
                }
                this.currentBaseGap = baseGap;
            }
            
            preloadAllImages() {
                const progressFill = document.getElementById('progressFill');
                const loadingText = document.getElementById('loadingText');
                let loadedCount = 0;
                
                const failsafe = setTimeout(() => {
                    if (loadedCount < MASTER_POOL.length) {
                        console.warn("Loading timed out. Forcing start.");
                        this.finishLoading();
                    }
                }, 5000);
                MASTER_POOL.forEach(lvl => {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.onload = () => {
                        lvl.img = img;
                        lvl.loaded = true;
                        loadedCount++;
                        const percent = Math.floor((loadedCount / MASTER_POOL.length) * 100);
                        progressFill.style.width = `${percent}%`;
                        loadingText.innerText = `CHARGING SIGIL... ${loadedCount}/${MASTER_POOL.length}`;
                        if (loadedCount >= MASTER_POOL.length) {
                            clearTimeout(failsafe);
                            this.finishLoading();
                        }
                    };
                    img.onerror = () => {
                        console.warn(`Failed to load image: ${lvl.id}`);
                        loadedCount++;
                        if (loadedCount >= MASTER_POOL.length) {
                            clearTimeout(failsafe);
                            this.finishLoading();
                        }
                    };
                    img.src = CONFIG.BASE_URL + lvl.id + CONFIG.IMG_SUFFIX;
                });
            }
            
            finishLoading() {
                setTimeout(() => {
                    document.getElementById('loadingMsg').classList.add('hidden');
                    document.getElementById('menuButtons').classList.remove('hidden');
                }, 500);
            }
            
            prepareLevels() {
                let shuffled = [...MASTER_POOL];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                this.gameLevels = shuffled.map((lvl, index) => {
                    return { ...lvl, threshold: index * 5 };
                });
            }

            startGame() {
                this.prepareLevels();
                this.state = GameState.PLAYING;
                document.getElementById('startScreen').classList.add('hidden');
                document.getElementById('scoreUi').classList.remove('hidden');
                document.getElementById('pauseBtn').classList.remove('hidden');
                document.getElementById('instructions').classList.remove('hidden');
                
                if (this.isMobile) {
                    document.getElementById('mobileControls').classList.remove('hidden');
                    setTimeout(() => {
                        document.getElementById('mobileControls').classList.add('hidden');
                    }, 5000);
                }
                
                if (CONFIG.DEBUG) document.getElementById('statsPanel').classList.remove('hidden');
                this.initGame();
                this.gameLoop();
            }
            
            initGame() {
                this.player = new Player();
                this.obstacles = [];
                this.collectibles = [];
                this.particles = [];
                this.stars = [];
                // Cool Feature: Runic Background
                for (let i = 0; i < 40; i++) this.stars.push(new Star());
                this.score = 0;
                this.currentLevelIdx = 0;
                this.frames = 0;
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED;
                this.shake = 0;
                this.tunnelOffset = 0;
                this.hitStop = 0;
                document.getElementById('scoreUi').innerText = "0";
                this.applyLevel();
            }
            
            applyLevel() {
                if (this.currentLevelIdx >= this.gameLevels.length) return;
                const l = this.gameLevels[this.currentLevelIdx];
                document.getElementById('levelUi').innerText = l.name;
                document.getElementById('levelUi').style.color = l.accent;
                document.getElementById('levelUi').style.textShadow = `0 0 15px ${l.accent}`;
                this.root.style.setProperty('--primary', l.accent);
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED + (this.currentLevelIdx * CONFIG.SPEED_INCREASE_PER_LEVEL);
                
                if (this.currentLevelIdx > 0) {
                    this.triggerGlitchEffect();
                    Haptics.levelUp();
                    if (this.settings.sfx) SFX.levelUp();
                }
            }
            
            triggerGlitchEffect() {
                this.glitchEffect = true;
                this.glitchTimer = this.glitchDuration;
            }
            
            applyGlitchEffect() {
                if (!this.glitchEffect) return;
                const ctx = this.ctx;
                const intensity = this.glitchTimer / this.glitchDuration;
                if (Math.random() > 0.7) {
                    const shiftX = Math.floor(Math.random() * 10 * intensity) - 5;
                    const shiftY = Math.floor(Math.random() * 10 * intensity) - 5;
                    ctx.save();
                    ctx.translate(shiftX, shiftY);
                    ctx.restore();
                }
                
                if (Math.random() > 0.8) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fillRect(0, Math.floor(Math.random() * this.canvas.height), this.canvas.width, 1);
                }
                
                this.glitchTimer -= 16;
                if (this.glitchTimer <= 0) {
                    this.glitchEffect = false;
                }
            }
            
            getCurrentGap() {
                const baseGap = this.currentBaseGap || CONFIG.PILLAR_GAP;
                const levelsCompleted = Math.floor(this.currentLevelIdx / 5);
                const gapReduction = levelsCompleted * CONFIG.PILLAR_GAP_DECREASE_PER_5_LEVELS;
                const calculatedGap = Math.max(CONFIG.MIN_PILLAR_GAP, baseGap - gapReduction);
                return calculatedGap;
            }
            
            checkLevel() {
                const nextIdx = this.currentLevelIdx + 1;
                if (nextIdx >= this.gameLevels.length) return;
                const next = this.gameLevels[nextIdx];
                if (this.score >= next.threshold) {
                    this.currentLevelIdx++;
                    this.applyLevel();
                    this.shake = 12;
                    // Trigger Hitstop
                    this.hitStop = 3;
                    this.triggerLevelUpGlitch();
                    for (let i = 0; i < 30; i++) {
                        this.particles.push(new Particle(
                            this.canvas.width / 2, this.canvas.height / 2, 
                            this.gameLevels[this.currentLevelIdx].accent, 12,
                            Math.random() > 0.5 ? 'hexagram' : 'triangle'
                        ));
                    }
                    if (this.settings.sfx) SFX.levelUp();
                    Haptics.levelUp();
                }
            }
            
            playerJump() {
                if (this.state === GameState.PLAYING) {
                    this.player.jump();
                    Haptics.jump();
                    // COOL FEATURE: Chromatic Aberration on Jump
                    GlitchFX.trigger(50, 'rgb');
                }
            }
            
            togglePause() {
                if (this.state === GameState.PLAYING) {
                    this.state = GameState.PAUSED;
                    document.getElementById('pauseScreen').classList.remove('hidden');
                    AudioSys.pause();
                } else if (this.state === GameState.PAUSED) {
                    this.state = GameState.PLAYING;
                    document.getElementById('pauseScreen').classList.add('hidden');
                    AudioSys.resume();
                    this.gameLoop();
                }
            }
            
            showSettings() {
                document.getElementById('startScreen').classList.add('hidden');
                document.getElementById('settingsScreen').classList.remove('hidden');
                this.state = GameState.SETTINGS;
            }
            
            hideSettings() {
                document.getElementById('settingsScreen').classList.add('hidden');
                document.getElementById('startScreen').classList.remove('hidden');
                this.state = GameState.START;
            }
            
            returnToMenu() {
                this.state = GameState.START;
                document.getElementById('pauseScreen').classList.add('hidden');
                document.getElementById('startScreen').classList.remove('hidden');
                document.getElementById('scoreUi').classList.add('hidden');
                document.getElementById('pauseBtn').classList.add('hidden');
                document.getElementById('instructions').classList.add('hidden');
                document.getElementById('statsPanel').classList.add('hidden');
                document.getElementById('mobileControls').classList.add('hidden');
                if (this.settings.music) AudioSys.switchToMenuMusic();
            }
            
            gameOver() {
                if (this.state === GameState.GAME_OVER) return;
                this.state = GameState.GAME_OVER;
                this.shake = 15;
                this.triggerDeathGlitch();
                if (this.settings.sfx) SFX.crash();
                Haptics.crash();
                
                for (let i = 0; i < 25; i++) {
                    this.particles.push(new Particle(
                        this.player.x, this.player.y,
                        '#ff003c', 10,
                        Math.random() > 0.3 ? 'hexagram' : 'triangle'
                    ));
                }
                
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('93protocol_highscore', this.highScore);
                    document.getElementById('highScoreMsg').textContent = "NEW GNOSIS ATTAINED";
                } else {
                    document.getElementById('highScoreMsg').textContent = `BEST: ${this.highScore}`;
                }
                AudioSys.stop();
                document.getElementById('finalScore').innerText = this.score;
                document.getElementById('scoreUi').classList.add('hidden');
                document.getElementById('pauseBtn').classList.add('hidden');
                document.getElementById('instructions').classList.add('hidden');
                document.getElementById('statsPanel').classList.add('hidden');
                document.getElementById('mobileControls').classList.add('hidden');
                document.getElementById('gameOverScreen').classList.remove('hidden');
            }
            
            restartGame() {
                this.state = GameState.PLAYING;
                this.prepareLevels();
                document.getElementById('gameOverScreen').classList.add('hidden');
                document.getElementById('scoreUi').classList.remove('hidden');
                document.getElementById('pauseBtn').classList.remove('hidden');
                document.getElementById('instructions').classList.remove('hidden');
                if (this.isMobile) {
                    document.getElementById('mobileControls').classList.remove('hidden');
                    setTimeout(() => {
                        document.getElementById('mobileControls').classList.add('hidden');
                    }, 5000);
                }
                if (CONFIG.DEBUG) document.getElementById('statsPanel').classList.remove('hidden');
                this.initGame();
                this.gameLoop();
            }
            
            gameLoop(currentTime = 0) {
                if (this.state !== GameState.PLAYING) return;
                if (this.lastFrameTime) {
                    this.fps = Math.round(1000 / (currentTime - this.lastFrameTime));
                    if (CONFIG.DEBUG) document.getElementById('fpsCounter').textContent = this.fps;
                }
                this.lastFrameTime = currentTime;
                
                // HITSTOP LOGIC
                if (this.hitStop > 0) {
                    this.hitStop--;
                    this.drawScene(currentTime);
                    requestAnimationFrame((time) => this.gameLoop(time));
                    return;
                }

                this.frames++;
                const lvl = this.gameLevels[this.currentLevelIdx];
                
                if (Math.random() > 0.995 && this.frames % 60 === 0) {
                    GlitchFX.trigger(30, 'random');
                }
                
                this.tunnelOffset += this.tunnelSpeed * (1 + this.gameSpeed * 0.1);
                
                this.updateGameObjects();
                this.drawScene(currentTime);
                
                requestAnimationFrame((time) => this.gameLoop(time));
            }

            drawScene(currentTime) {
                const lvl = this.gameLevels[this.currentLevelIdx];
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.drawHyperspaceTunnel(lvl);
                
                GlitchFX.apply(this.ctx, currentTime);
                this.applyScreenFlash();
                if (this.glitchEffect) {
                    this.applyGlitchEffect();
                }
                
                this.ctx.save();
                if (this.shake > 0) {
                    this.ctx.translate((Math.random() - 0.5) * this.shake, (Math.random() - 0.5) * this.shake);
                    this.shake *= 0.9;
                }
                this.drawGameObjects();
                this.ctx.restore();
            }
            
            drawHyperspaceTunnel(lvl) {
                const ctx = this.ctx;
                const cx = this.canvas.width / 2;
                const cy = this.canvas.height / 2;
                const maxRadius = Math.max(this.canvas.width, this.canvas.height) * 0.8;
                
                // Breathing Effect
                const breath = (Math.sin(Date.now() * 0.002 * (1 + this.gameSpeed * 0.1)) + 1) * 0.5;
                
                ctx.strokeStyle = lvl.accent;
                ctx.lineWidth = 1.5;
                optimizedShadow.apply(ctx, 15, lvl.accent);
                
                // COOL FEATURE: Rotating Tunnel
                const baseRotation = this.frames * 0.005;

                for (let i = 0; i < 8; i++) {
                    const progress = ((this.tunnelOffset + i * 60) % 300) / 300;
                    const radius = progress * maxRadius;
                    
                    if (radius < 50) continue;
                    
                    ctx.globalAlpha = (1 - progress * 0.8) * (0.8 + breath * 0.2);
                    
                    // DRAW PENTAGRAM instead of Circle
                    ctx.save();
                    ctx.translate(cx, cy);
                    ctx.rotate(baseRotation + (i * 0.1)); // Twist effect
                    
                    ctx.beginPath();
                    for(let k = 0; k < 5; k++) {
                        // Skip vertex to create star shape
                        const angle = (k * 4 * Math.PI / 5) - (Math.PI / 2); 
                        const px = Math.cos(angle) * radius;
                        const py = Math.sin(angle) * radius;
                        if(k===0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                }
                
                optimizedShadow.clear(ctx);
                ctx.globalAlpha = 1;
                
                if (Math.random() > 0.95 && this.frames % 30 === 0) {
                    ctx.save();
                    ctx.globalAlpha = 0.05;
                    ctx.fillStyle = lvl.accent;
                    const y = Math.random() * this.canvas.height;
                    ctx.fillRect(0, y, this.canvas.width, 1);
                    ctx.restore();
                }
                
                this.backgroundParticles.forEach(p => {
                    p.y += p.speed * (1 + this.gameSpeed * 0.1);
                    if (p.y > this.canvas.height) { 
                        p.y = 0; 
                        p.x = Math.random() * this.canvas.width;
                        p.shape = Math.floor(Math.random() * 3);
                    }
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.opacity;
                    
                    // Draw Runes/Symbols instead of dots
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(this.frames * 0.02);
                    
                    if (p.shape === 0) { // Triangle
                        ctx.beginPath();
                        ctx.moveTo(0, -p.size);
                        ctx.lineTo(p.size, p.size);
                        ctx.lineTo(-p.size, p.size);
                        ctx.fill();
                    } else if (p.shape === 1) { // Diamond
                        ctx.beginPath();
                        ctx.moveTo(0, -p.size);
                        ctx.lineTo(p.size, 0);
                        ctx.lineTo(0, p.size);
                        ctx.lineTo(-p.size, 0);
                        ctx.fill();
                    } else { // Cross
                        ctx.fillRect(-p.size/2, -p.size*1.5, p.size, p.size*3);
                        ctx.fillRect(-p.size*1.5, -p.size/2, p.size*3, p.size);
                    }
                    ctx.restore();
                });
                ctx.globalAlpha = 1;
                
                ctx.globalAlpha = 0.6;
                if (lvl.loaded && lvl.img && lvl.img.complete) {
                    try {
                        const img = lvl.img;
                        const canvasRatio = this.canvas.width / this.canvas.height;
                        const imgRatio = img.width / img.height;
                        let drawWidth, drawHeight, drawX, drawY;
                        if (canvasRatio > imgRatio) {
                            drawHeight = this.canvas.height;
                            drawWidth = img.width * (drawHeight / img.height);
                            drawX = (this.canvas.width - drawWidth) / 2;
                            drawY = 0;
                        } else {
                            drawWidth = this.canvas.width;
                            drawHeight = img.height * (drawWidth / img.width);
                            drawX = 0;
                            drawY = (this.canvas.height - drawHeight) / 2;
                        }
                        ctx.filter = 'blur(1px)';
                        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                        ctx.filter = 'none';
                    } catch (e) {}
                }
                ctx.globalAlpha = 1.0;
            }
            
            updateGameObjects() {
                const currentGap = this.getCurrentGap();
                if (this.frames % Math.floor(CONFIG.PILLAR_SPAWN_RATE / (1 + this.gameSpeed * 0.05)) === 0) {
                    const p = new Pillar(this.currentLevelIdx, currentGap);
                    this.obstacles.push(p);
                    if (Math.random() > (1 - CONFIG.ORB_SPAWN_CHANCE)) {
                        this.collectibles.push(new Orb(p.x + p.w / 2, p.top + p.gap / 2));
                    }
                }
                
                this.obstacles.forEach((o, i) => {
                    o.update(this.gameSpeed);
                    const hitboxReduction = CONFIG.HITBOX_OFFSET;
                    const pLeft = this.player.x - this.player.r + hitboxReduction;
                    const pRight = this.player.x + this.player.r - hitboxReduction;
                    const pTop = this.player.y - this.player.r + hitboxReduction;
                    const pBottom = this.player.y + this.player.r - hitboxReduction;
                    const pillarLeft = o.x;
                    const pillarRight = o.x + o.w;
                    const topPillarBottom = o.top;
                    const topPillarTop = 0;
                    const bottomPillarTop = o.top + o.gap;
                    const bottomPillarBottom = this.canvas.height;
                    const horizontalOverlap = pRight > pillarLeft && pLeft < pillarRight;
                    const hittingTopPillar = horizontalOverlap && pBottom > topPillarTop && pTop < topPillarBottom;
                    const hittingBottomPillar = horizontalOverlap && pTop < bottomPillarBottom && pBottom > bottomPillarTop;
                    if (hittingTopPillar || hittingBottomPillar) {
                        this.gameOver();
                    }
                    if (!o.marked && o.x + o.w < this.player.x) {
                        this.score++;
                        o.marked = true;
                        document.getElementById('scoreUi').innerText = this.score;
                        this.checkLevel();
                    }
                    if (o.x < -100) this.obstacles.splice(i, 1);
                });
                
                this.collectibles.forEach((c, i) => {
                    c.update(this.gameSpeed);
                    const dist = Math.hypot(this.player.x - c.x, this.player.y - c.y);
                    if (dist < this.player.r + c.r && !c.collected) {
                        this.score += 5;
                        document.getElementById('scoreUi').innerText = this.score;
                        c.collected = true;
                        this.triggerOrbGlitch();
                        // Trigger Hitstop
                        this.hitStop = 3;
                        for (let k = 0; k < 20; k++) {
                            this.particles.push(new Particle(
                                c.x, c.y, 
                                '#ffd700', 8,
                                Math.random() > 0.6 ? 'hexagram' : 
                                Math.random() > 0.3 ? 'triangle' : 'diamond'
                            ));
                        }
                        if (this.settings.sfx) SFX.collect();
                        Haptics.collect();
                        this.collectibles.splice(i, 1);
                        this.checkLevel();
                    }
                    if (c.x < -50) this.collectibles.splice(i, 1);
                });
                
                this.player.update();
                
                this.particles.forEach((p, i) => {
                    p.update();
                    if (p.life <= 0) this.particles.splice(i, 1);
                });
            }
            
            drawGameObjects() {
                const currentLvlConfig = this.gameLevels[this.currentLevelIdx];
                this.obstacles.forEach(o => o.draw(this.ctx, currentLvlConfig));
                this.collectibles.forEach(c => c.draw(this.ctx));
                this.player.draw(this.ctx, currentLvlConfig);
                this.particles.forEach(p => p.draw(this.ctx));
            }
        }

        class Player {
            constructor() {
                this.x = window.innerWidth * 0.25;
                this.y = window.innerHeight / 2;
                this.vy = 0;
                this.r = CONFIG.PLAYER_RADIUS;
                this.rot = 0;
                this.trail = [];
                this.trailLength = game.isMobile ? 8 : 12;
                this.jumpCooldown = 0;
                // Squash/Stretch factors
                this.scaleX = 1;
                this.scaleY = 1;
            }
            
            update() {
                this.vy += CONFIG.GRAVITY;
                this.y += this.vy;
                this.rot += 0.03;
                
                // Squash and Stretch Calculation
                const stretch = Math.min(Math.abs(this.vy) * 0.04, 0.3);
                if (this.vy < 0) { // Jumping
                    this.scaleY = 1 + stretch;
                    this.scaleX = 1 - stretch * 0.5;
                } else { // Falling
                    this.scaleY = 1 - stretch * 0.5;
                    this.scaleX = 1 + stretch;
                }

                if (this.y > window.innerHeight - this.r * 1.5) {
                    game.gameOver();
                }
                if (this.y < this.r * 1.5) { 
                    this.y = this.r * 1.5;
                    this.vy = 0; 
                }
                
                if (this.jumpCooldown > 0) {
                    this.jumpCooldown--;
                }
                
                if (game.frames % 2 === 0) {
                    this.trail.unshift({
                        x: this.x, 
                        y: this.y, 
                        r: this.r, 
                        life: 1.0,
                        rot: this.rot,
                        scaleX: this.scaleX,
                        scaleY: this.scaleY
                    });
                    if (this.trail.length > this.trailLength) this.trail.pop();
                }
                
                this.trail.forEach(t => t.life -= 0.05);
            }
            
            draw(ctx, conf) {
                const hue = (game.frames * 2) % 360;
                const strokeColor = `hsl(${hue}, 100%, 60%)`;
                const shadowColor = `hsl(${hue}, 100%, 50%)`;
                this.trail.forEach((t, i) => {
                    if (t.life > 0) {
                        ctx.save();
                        ctx.globalAlpha = t.life * 0.6;
                        ctx.translate(t.x, t.y);
                        // Apply trail scale
                        ctx.scale(t.scaleX, t.scaleY);
                        ctx.rotate(t.rot + (this.vy * 0.05));
                        
                        const trailR = t.r * 0.7 * t.life;
                        const points = [];
                        for (let j = 0; j < 6; j++) {
                            const angle = (j * 60 - 90) * Math.PI / 180;
                            points.push({ 
                                x: Math.cos(angle) * trailR, 
                                y: Math.sin(angle) * trailR 
                            });
                        }
                        
                        optimizedShadow.apply(ctx, 20 * t.life, shadowColor);
                        ctx.strokeStyle = strokeColor;
                        ctx.lineWidth = 2 * t.life;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';

                        ctx.beginPath();
                        ctx.moveTo(points[0].x, points[0].y);
                        ctx.lineTo(points[2].x, points[2].y);
                        ctx.lineTo(points[5].x, points[5].y);
                        ctx.lineTo(points[3].x, points[3].y);
                        ctx.lineTo(points[1].x, points[1].y);
                        ctx.lineTo(points[4].x, points[4].y);
                        ctx.lineTo(points[0].x, points[0].y);
                        ctx.stroke();
                        
                        if (game.isMobile) {
                            ctx.lineWidth = 6 * t.life;
                            ctx.globalAlpha = t.life * 0.2;
                            ctx.stroke();
                        }
                        
                        ctx.restore();
                    }
                });
                ctx.globalAlpha = 1.0;
                ctx.save();
                ctx.translate(this.x, this.y);
                // Apply Main Player Scale (Squash & Stretch)
                ctx.scale(this.scaleX, this.scaleY);
                ctx.rotate(this.rot + (this.vy * 0.05));
                
                const r = this.r * 1.2;
                const points = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (i * 60 - 90) * Math.PI / 180;
                    points.push({ x: Math.cos(angle) * r, y: Math.sin(angle) * r });
                }
                
                optimizedShadow.apply(ctx, 25, shadowColor);
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                ctx.lineTo(points[2].x, points[2].y);
                ctx.lineTo(points[5].x, points[5].y);
                ctx.lineTo(points[3].x, points[3].y);
                ctx.lineTo(points[1].x, points[1].y);
                ctx.lineTo(points[4].x, points[4].y);
                ctx.lineTo(points[0].x, points[0].y);
                ctx.stroke();
                
                // Mobile Glow Layer
                if (game.isMobile) {
                    ctx.save();
                    ctx.strokeStyle = shadowColor;
                    ctx.lineWidth = 8;
                    ctx.globalAlpha = 0.3;
                    ctx.stroke();
                    ctx.restore();
                }

                const pulse = Math.sin(game.frames * 0.1) * 0.5 + 1;
                ctx.fillStyle = "#fff";
                optimizedShadow.apply(ctx, 40 * pulse, "#fff");
                ctx.beginPath();
                ctx.arc(0, 0, 3 * pulse, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
            
            jump() {
                if (this.jumpCooldown > 0) return;
                this.vy = CONFIG.PLAYER_JUMP_FORCE;
                this.jumpCooldown = game.isMobile ? 8 : 5;
                if (Math.random() > 0.7) {
                    GlitchFX.trigger(40, 'jump');
                }
                
                for (let i = 0; i < (game.isMobile ? 10 : 12); i++) {
                    const type = Math.random() > 0.7 ? 'hexagram' : Math.random() > 0.4 ? 'triangle' : 'circle';
                    game.particles.push(new Particle(
                        this.x, this.y, '#fff', 3, type
                    ));
                }
                
                if (game.settings.sfx) SFX.jump();
                Haptics.jump();
                // COOL FEATURE: Chromatic Aberration on Jump
                GlitchFX.trigger(50, 'rgb');
            }
        }

        class Pillar {
            constructor(lvlIndex, currentGap) {
                this.x = window.innerWidth;
                this.w = CONFIG.PILLAR_WIDTH;
                this.gap = currentGap;
                const maxTop = window.innerHeight - this.gap - 50;
                const minTop = 30;
                this.top = Math.random() * (maxTop - minTop) + minTop;
                this.marked = false;
                this.lvl = lvlIndex;
                this.rotation = Math.random() * Math.PI * 2;
                this.innerPattern = Math.floor(Math.random() * 3);
                this.pulse = 0;
                this.hasWarning = game.isMobile && Math.random() > 0.5;
                this.warningAlpha = 1;
            }
            
            update(speed) { 
                this.x -= speed;
                this.pulse += 0.05;
                this.rotation += 0.005;
                if (this.hasWarning) {
                    this.warningAlpha -= 0.01;
                }
            }
            
            draw(ctx, conf) {
                const hue = (game.frames * 0.5 + this.x * 0.1) % 360;
                const mainColor = `hsl(${hue}, 100%, 60%)`;
                const innerColor = `hsl(${(hue + 60) % 360}, 100%, 70%)`;
                const glowColor = `hsl(${hue}, 100%, 50%)`;
                
                if (this.hasWarning && this.x < window.innerWidth * 0.7 && this.warningAlpha > 0) {
                    ctx.save();
                    ctx.globalAlpha = this.warningAlpha * 0.3;
                    ctx.fillStyle = '#ff003c';
                    ctx.fillRect(this.x - 10, 0, this.w + 20, window.innerHeight);
                    ctx.restore();
                }
                
                ctx.save();
                ctx.translate(this.x + this.w/2, 0);
                
                optimizedShadow.apply(ctx, 30, glowColor);
                ctx.strokeStyle = mainColor;
                ctx.lineWidth = 4;
                ctx.fillStyle = "rgba(0,0,0,0.7)";
                const topHeight = this.top + 10;
                ctx.beginPath();
                ctx.moveTo(-this.w/2, -10);
                ctx.lineTo(this.w/2, -10);
                
                const jagCount = 5;
                for (let i = 0; i <= jagCount; i++) {
                    const x = this.w/2 - (i * this.w/jagCount);
                    const y = -10 + (i % 2 === 0 ? 8 : -4);
                    ctx.lineTo(x, y);
                }
                
                ctx.lineTo(-this.w/2, topHeight);
                ctx.lineTo(-this.w/2, -10);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                if (game.isMobile) {
                    ctx.save();
                    ctx.lineWidth = 10;
                    ctx.globalAlpha = 0.2;
                    ctx.stroke();
                    ctx.restore();
                }
                
                ctx.save();
                ctx.translate(0, topHeight/2);
                ctx.rotate(this.rotation);
                ctx.globalAlpha = 0.4;
                ctx.strokeStyle = innerColor;
                ctx.lineWidth = 1.5;
                optimizedShadow.apply(ctx, 15, innerColor);
                
                if (this.innerPattern === 0) {
                    const size = Math.min(this.w, topHeight) * 0.3;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = Math.cos(angle) * size;
                        const y = Math.sin(angle) * size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                } else if (this.innerPattern === 1) {
                    const size = Math.min(this.w, topHeight) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size * 0.866, size * 0.5);
                    ctx.lineTo(-size * 0.866, size * 0.5);
                    ctx.closePath();
                    ctx.stroke();
                } else {
                    const size = Math.min(this.w, topHeight) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(-size, 0);
                    ctx.lineTo(size, 0);
                    ctx.moveTo(0, -size);
                    ctx.lineTo(0, size);
                    ctx.stroke();
                }
                ctx.restore();
                const botY = this.top + this.gap;
                const botHeight = window.innerHeight - botY + 10;
                
                ctx.beginPath();
                ctx.moveTo(-this.w/2, botY);
                ctx.lineTo(this.w/2, botY);
                for (let i = 0; i <= jagCount; i++) {
                    const x = this.w/2 - (i * this.w/jagCount);
                    const y = botY + (i % 2 === 0 ? -4 : 8);
                    ctx.lineTo(x, y);
                }
                
                ctx.lineTo(this.w/2, botY + botHeight);
                ctx.lineTo(-this.w/2, botY + botHeight);
                ctx.lineTo(-this.w/2, botY);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                if (game.isMobile) {
                    ctx.save();
                    ctx.lineWidth = 10;
                    ctx.globalAlpha = 0.2;
                    ctx.stroke();
                    ctx.restore();
                }
                
                ctx.save();
                ctx.translate(0, botY + botHeight/2);
                ctx.rotate(-this.rotation);
                ctx.globalAlpha = 0.4;
                ctx.strokeStyle = innerColor;
                ctx.lineWidth = 1.5;
                
                if (this.innerPattern === 0) {
                    const size = Math.min(this.w, botHeight) * 0.3;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = Math.cos(angle) * size;
                        const y = Math.sin(angle) * size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                } else if (this.innerPattern === 1) {
                    const size = Math.min(this.w, botHeight) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size * 0.866, size * 0.5);
                    ctx.lineTo(-size * 0.866, size * 0.5);
                    ctx.closePath();
                    ctx.stroke();
                } else {
                    const size = Math.min(this.w, botHeight) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(-size, 0);
                    ctx.lineTo(size, 0);
                    ctx.moveTo(0, -size);
                    ctx.lineTo(0, size);
                    ctx.stroke();
                }
                ctx.restore();
                
                ctx.restore();
                optimizedShadow.clear(ctx);
                ctx.globalAlpha = 1.0;
            }
        }

        class Orb {
            constructor(x, y) {
                this.x = x;
                this.y = y; 
                this.r = 9;
                this.collected = false;
                this.float = Math.random() * Math.PI * 2;
                this.pulse = 0;
                this.rotation = 0;
            }
            
            update(speed) {
                this.x -= speed;
                this.float += 0.1;
                this.pulse += 0.15;
                this.rotation += 0.02;
                this.y += Math.sin(this.float) * 0.8;
            }
            
            draw(ctx) {
                if (this.collected) return;
                if (Math.random() > 0.97) {
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = '#ff00ff';
                    ctx.fillRect(this.x - this.r, this.y - this.r, this.r * 2, this.r * 2);
                    ctx.restore();
                }
                
                const pulseSize = this.r + Math.sin(this.pulse) * 3;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                optimizedShadow.apply(ctx, 25, '#ffd700');
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
                ctx.stroke();
                
                optimizedShadow.apply(ctx, 30, '#fff');
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.9;
                const r = pulseSize * 0.7;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i * 60) * Math.PI / 180;
                    const x = Math.cos(angle) * r;
                    const y = Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
                
                ctx.fillStyle = '#fff';
                optimizedShadow.apply(ctx, 40, '#fff');
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize * 0.2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
        }

        class Particle {
            constructor(x, y, c, speed, type = 'circle') {
                this.x = x;
                this.y = y; 
                this.c = c;
                this.vx = (Math.random() - 0.5) * speed;
                this.vy = (Math.random() - 0.5) * speed;
                this.life = 1; 
                this.size = Math.random() * 3 + 2;
                this.type = type;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.2;
                this.glow = Math.random() > 0.5;
            }
            
            update() { 
                this.x += this.vx;
                this.y += this.vy; 
                this.vx *= 0.97;
                this.vy *= 0.97;
                this.life -= 0.03; 
                this.rotation += this.rotationSpeed;
                this.size *= 0.98;
                if (game.isMobile) {
                    this.life -= 0.01;
                }
            }
            
            draw(ctx) {
                if (this.life <= 0) return;
                if (game.isMobile && this.type !== 'hexagram') {
                    ctx.globalAlpha = this.life * 0.5;
                    ctx.fillStyle = this.c;
                    ctx.fillRect(this.x - this.size, this.y - this.size, 
                                this.size * 2, this.size * 2);
                    ctx.globalAlpha = 1;
                    return;
                }
                
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.c;
                
                if (this.glow && this.life > 0.3) {
                    optimizedShadow.apply(ctx, 20 * this.life, this.c);
                }
                
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                if (this.type === 'hexagram') {
                    const r = this.size * 0.8;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 'triangle') {
                    const r = this.size;
                    ctx.beginPath();
                    ctx.moveTo(0, -r);
                    ctx.lineTo(r * 0.866, r * 0.5);
                    ctx.lineTo(-r * 0.866, r * 0.5);
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 'diamond') {
                    const r = this.size;
                    ctx.beginPath();
                    ctx.moveTo(0, -r);
                    ctx.lineTo(r, 0);
                    ctx.lineTo(0, r);
                    ctx.lineTo(-r, 0);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
        }
        
        class Star {
            constructor() {
                this.x = Math.random() * window.innerWidth;
                this.y = Math.random() * window.innerHeight;
                this.size = Math.random() * 2;
                this.speed = Math.random() * 0.5 + 0.1;
                this.alpha = Math.random() * 0.5 + 0.2;
                this.twinkle = Math.random() * Math.PI * 2;
            }
            update() {
                this.y += this.speed;
                if (this.y > window.innerHeight) {
                    this.y = 0;
                    this.x = Math.random() * window.innerWidth;
                }
                this.twinkle += 0.05;
                this.alpha = 0.3 + Math.sin(this.twinkle) * 0.2;
            }
            draw(ctx) {
                const conf = game.gameLevels[game.currentLevelIdx];
                ctx.fillStyle = conf ? conf.accent : '#fff';
                ctx.globalAlpha = this.alpha;
                if (Math.random() > 0.7) {
                    ctx.fillRect(this.x - this.size/2, this.y, this.size, 1);
                    ctx.fillRect(this.x, this.y - this.size/2, 1, this.size);
                } else {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size/2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1.0;
            }
        }

        let game;
        document.addEventListener('DOMContentLoaded', () => {
            game = new Game();
        });
    </script>
</body>
</html>
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* CRT Scanline Effect */
        .scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
            opacity: 0.4;
        }
        
        /* Vignette for ominous feel */
        .vignette {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, black 130%);
            pointer-events: none;
            z-index: 11;
        }

        /* UI Overlay */
        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 20;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            transition: opacity 0.3s ease;
            padding: 20px;
            box-sizing: border-box;
        }

        /* Start Screen Specifics */
        #startScreen {
            background-size: cover;
            background-position: center;
            /* Psychedelic Background Animation */
            animation: bgBreath 10s infinite alternate; 
        }
        
        /* Dark overlay to make text pop on top of image */
        #startScreen::before {
            content: '';
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: -1;
        }

        @keyframes bgBreath {
            0% { transform: scale(1); filter: hue-rotate(0deg); }
            100% { transform: scale(1.05); filter: hue-rotate(45deg); }
        }

        .hidden {
            opacity: 0 !important;
            pointer-events: none !important;
            display: none !important;
        }

        /* Neon Buttons */
        .mystic-btn {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--primary);
            color: #fff;
            padding: 15px 50px;
            font-size: 1.2rem;
            font-family: 'Cinzel Decorative', cursive;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 4px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 15px var(--primary), inset 0 0 10px var(--primary);
            margin: 10px;
            min-width: 260px;
            position: relative;
            overflow: hidden;
            text-shadow: 0 0 5px #fff;
            animation: psychedelicBorder 4s infinite linear;
        }

        @keyframes psychedelicBorder {
            0% { border-color: #ff003c; box-shadow: 0 0 15px #ff003c; }
            25% { border-color: #ff00ff; box-shadow: 0 0 15px #ff00ff; }
            50% { border-color: #00ffff; box-shadow: 0 0 15px #00ffff; }
            75% { border-color: #ffd700; box-shadow: 0 0 15px #ffd700; }
            100% { border-color: #ff003c; box-shadow: 0 0 15px #ff003c; }
        }

        .mystic-btn:hover {
            background: #fff;
            color: #000;
            transform: scale(1.05);
            text-shadow: none;
        }

        .mystic-btn:active {
            transform: scale(0.95);
        }

        .title-text {
            font-family: 'Cinzel Decorative', cursive;
            font-size: 5rem;
            color: #fff;
            text-shadow: 0 0 10px var(--primary);
            margin-bottom: 10px;
            letter-spacing: -2px;
            animation: pulseNeon 3s infinite alternate;
        }

        @keyframes pulseNeon {
            0% { text-shadow: 0 0 10px var(--primary), 0 0 20px var(--primary); opacity: 1; }
            100% { text-shadow: 0 0 20px var(--primary), 0 0 40px var(--primary), 0 0 80px var(--primary); opacity: 0.9; }
        }

        .level-indicator {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            font-size: 1.5rem;
            font-family: 'Cinzel Decorative', serif;
            font-weight: 700;
            letter-spacing: 6px;
            color: #fff;
            z-index: 15;
            text-shadow: 0 0 10px #000;
            text-transform: uppercase;
        }

        .score-display {
            position: absolute;
            top: 10%;
            width: 100%;
            text-align: center;
            font-size: 9rem;
            font-family: 'Cinzel Decorative', serif;
            color: rgba(255, 255, 255, 0.1);
            z-index: 5;
            pointer-events: none;
            mix-blend-mode: screen;
            font-weight: 900;
        }

        .progress-bar {
            width: 300px;
            height: 4px;
            background: #222;
            margin: 20px 0;
            position: relative;
            box-shadow: 0 0 10px #000;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width 0.2s ease;
            box-shadow: 0 0 15px var(--primary);
        }

        .instructions {
            position: absolute;
            bottom: 100px;
            width: 100%;
            text-align: center;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 3px;
            z-index: 15;
            font-family: 'Orbitron', sans-serif;
            
            /* FADE OUT ANIMATION */
            animation: fadeOut 5s ease-in-out forwards;
            animation-delay: 2s; /* Wait 2 seconds before fading */
            pointer-events: none;
        }

        @keyframes fadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; visibility: hidden; }
        }

        .pause-btn {
            position: absolute;
            top: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--primary);
            color: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            z-index: 25;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            pointer-events: auto;
            box-shadow: 0 0 10px var(--primary);
            transition: 0.3s;
        }
        
        .pause-btn:hover {
            background: var(--primary);
            color: #000;
            box-shadow: 0 0 20px var(--primary);
        }

        .stats-panel {
            position: absolute;
            top: 30px;
            left: 30px;
            background: rgba(0, 0, 0, 0.7);
            border-left: 3px solid var(--primary);
            padding: 10px 15px;
            font-size: 0.8rem;
            color: #ccc;
            z-index: 25;
            pointer-events: auto;
            font-family: 'Orbitron', monospace;
            text-align: left;
            backdrop-filter: blur(4px);
        }
        
        /* Custom File Upload Styling */
        .file-upload-label {
            display: inline-block;
            margin-top: 20px;
            padding: 10px 20px;
            border: 1px dashed #666;
            color: #888;
            cursor: pointer;
            font-size: 0.8rem;
            transition: 0.3s;
            font-family: 'Orbitron', sans-serif;
        }
        .file-upload-label:hover {
            border-color: var(--primary);
            color: var(--primary);
            box-shadow: 0 0 10px rgba(255, 0, 60, 0.2);
        }

        /* Mobile Controls */
        .mobile-controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 30;
        }

        .mobile-jump-area {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40%;
            pointer-events: auto;
            background: transparent;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .mobile-jump-indicator {
            background: rgba(255, 0, 60, 0.3);
            border: 2px solid rgba(255, 0, 60, 0.7);
            border-radius: 50%;
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 0.8rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            backdrop-filter: blur(5px);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.1); opacity: 0.9; }
            100% { transform: scale(1); opacity: 0.7; }
        }

        /* Responsive Styles */
        @media (max-width: 768px) {
            .title-text { 
                font-size: 3.5rem !important; 
                margin-bottom: 20px;
            }
            .score-display { 
                font-size: 6rem !important; 
                top: 8% !important;
            }
            .level-indicator { 
                font-size: 1.2rem !important; 
                bottom: 70px !important;
                letter-spacing: 4px !important;
            }
            .mystic-btn { 
                padding: 12px 30px !important;
                font-size: 1rem !important;
                min-width: 220px !important;
                margin: 8px !important;
            }
            .instructions {
                bottom: 130px !important;
                font-size: 0.7rem !important;
                letter-spacing: 2px !important;
            }
            .stats-panel {
                top: 15px !important;
                left: 15px !important;
                font-size: 0.7rem !important;
                padding: 8px 12px !important;
            }
            .pause-btn {
                top: 15px !important;
                right: 15px !important;
                width: 45px !important;
                height: 45px !important;
                font-size: 1.2rem !important;
            }
            .progress-bar {
                width: 250px !important;
            }
            #gameOverScreen .title-text {
                font-size: 3rem !important;
            }
            #pauseScreen .title-text {
                font-size: 2.5rem !important;
            }
            #settingsScreen .title-text {
                font-size: 2rem !important;
            }
        }

        @media (max-width: 480px) {
            .title-text { 
                font-size: 2.8rem !important; 
            }
            .score-display { 
                font-size: 5rem !important; 
                top: 6% !important;
            }
            .level-indicator { 
                font-size: 1rem !important; 
                bottom: 60px !important;
            }
            .mystic-btn { 
                min-width: 200px !important;
                padding: 10px 25px !important;
                font-size: 0.9rem !important;
                letter-spacing: 2px !important;
            }
            .instructions {
                font-size: 0.65rem !important;
                letter-spacing: 1.5px !important;
                bottom: 140px !important;
            }
            .progress-bar {
                width: 200px !important;
            }
        }

        @media (orientation: portrait) and (max-height: 700px) {
            .title-text { font-size: 2.5rem !important; }
            .score-display { font-size: 4.5rem !important; }
            .level-indicator { bottom: 50px !important; }
            .instructions { bottom: 100px !important; }
        }

        @media (orientation: landscape) {
            .title-text { font-size: 3rem !important; }
            .score-display { font-size: 4rem !important; top: 5% !important; }
            .level-indicator { bottom: 20px !important; font-size: 1rem !important; }
            .mystic-btn { 
                padding: 8px 20px !important;
                margin: 5px !important;
                min-width: 180px !important;
            }
            .instructions {
                bottom: 70px !important;
                font-size: 0.6rem !important;
            }
            .mobile-jump-area {
                height: 50%;
            }
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .title-text { font-size: 2.2rem !important; }
            .score-display { font-size: 3rem !important; }
            .mystic-btn { 
                padding: 6px 15px !important;
                font-size: 0.8rem !important;
                min-width: 150px !important;
            }
        }

        /* Safe area padding for notched phones */
        @supports (padding: max(0px)) {
            .ui-layer {
                padding-left: max(20px, env(safe-area-inset-left));
                padding-right: max(20px, env(safe-area-inset-right));
                padding-top: max(20px, env(safe-area-inset-top));
                padding-bottom: max(20px, env(safe-area-inset-bottom));
            }
        }

        .loader {
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid var(--primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="scanlines"></div>
        <div class="vignette"></div>
        
        <div id="scoreUi" class="score-display">0</div>
        <div id="levelUi" class="level-indicator">INITIATION</div>
        
        <!-- Mobile Controls -->
        <div id="mobileControls" class="mobile-controls hidden">
            <div class="mobile-jump-area">
                <div class="mobile-jump-indicator">
                    TAP
                </div>
            </div>
        </div>
        
        <!-- Start Screen with NEW Background Image -->
        <div id="startScreen" class="ui-layer" style="background-image: url('https://lh3.googleusercontent.com/d/1BXrXXd9TKSqCFNwvS-cJpNORbyvP6fkR=s0');">
            <h1 class="title-text">Sex Magick</h1>
            <p style="letter-spacing: 8px; color: #ff003c; margin-bottom: 40px; font-size: 1.1rem; text-shadow: 0 0 10px #ff003c; font-family: 'Cinzel Decorative', cursive;">Do Your Will Foo</p>
            
            <div id="loadingMsg">
                <div class="loader"></div>
                <p id="loadingText" style="letter-spacing: 4px; font-size: 0.9rem; margin-top: 15px; font-family: 'Cinzel Decorative';">CHARGING SIGIL...</p>
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill"></div>
                </div>
            </div>

            <div id="menuButtons" class="hidden">
                <button id="startBtn" class="mystic-btn">INVOKE</button>
                <button id="settingsBtn" class="mystic-btn">RITES</button>
                
                <label for="fileUpload" class="file-upload-label">
                    [ OPTIONAL: LOAD LOCAL MP3 ]
                </label>
                <input type="file" id="fileUpload" accept="audio/*" style="display:none;">
                <p id="trackName" style="margin-top: 5px; font-size: 0.6rem; color: #555;">SOURCE: GITHUB CDN</p>
            </div>
        </div>

        <div id="gameOverScreen" class="ui-layer hidden" style="background: rgba(0,0,0,0.85);">
            <h1 class="title-text" style="color: #ff003c; font-size: 4rem;">ABORTED</h1>
            <p style="font-size: 1.2rem; letter-spacing: 4px; margin-bottom: 20px; font-family: 'Cinzel Decorative';">RITUAL FAILED</p>
            <p class="text-xl mb-6 text-gray-300">WILL: <span id="finalScore" style="color: #fff; font-weight:bold; text-shadow: 0 0 10px #fff;">0</span></p>
            <p id="highScoreMsg" style="color: #ffd700; margin-bottom: 30px; font-size: 1rem; letter-spacing: 2px;"></p>
            <button id="restartBtn" class="mystic-btn">REINCARNATE</button>
        </div>

        <div id="pauseScreen" class="ui-layer hidden">
            <h1 class="title-text" style="font-size: 3.5rem; color: #ffd700;">MEDITATION</h1>
            <button id="resumeBtn" class="mystic-btn">RESUME</button>
            <button id="menuBtn" class="mystic-btn">ABORT</button>
        </div>

        <div id="settingsScreen" class="ui-layer hidden" style="background: rgba(0,0,0,0.9);">
            <h1 class="title-text" style="font-size: 2.5rem;">SACRED RITES</h1>
            <div style="width: 320px; margin: 20px 0; background: rgba(20,20,20,0.8); padding: 20px; border: 1px solid var(--primary);">
                <div style="display: flex; justify-content: space-between; margin: 15px 0; border-bottom: 1px solid #444; padding-bottom: 10px;">
                    <span>CHANT (MUSIC)</span>
                    <input type="checkbox" id="musicToggle" checked style="accent-color: var(--primary);">
                </div>
                <div style="display: flex; justify-content: space-between; margin: 15px 0; border-bottom: 1px solid #444; padding-bottom: 10px;">
                    <span>RESONANCE (SFX)</span>
                    <input type="checkbox" id="sfxToggle" checked style="accent-color: var(--primary);">
                </div>
                <div style="display: flex; justify-content: space-between; margin: 15px 0;">
                    <span>KUNDALINI (VIBE)</span>
                    <input type="checkbox" id="vibrationToggle" checked style="accent-color: var(--primary);">
                </div>
            </div>
            <button id="backBtn" class="mystic-btn">RETURN</button>
        </div>

        <button id="pauseBtn" class="pause-btn hidden">||</button>
        
        <div id="statsPanel" class="stats-panel">
            <div style="color: var(--primary); font-weight: bold; margin-bottom: 5px;">:: GNOSIS ::</div>
            FPS: <span id="fpsCounter" style="color: #fff;">0</span><br>
            AUDIO: <span id="audioStatus" style="color: #fff;">STANDBY</span>
        </div>

        <div id="instructions" class="instructions hidden">
            [ TAP / SPACE TO ASCEND ]
        </div>
    </div>

    <script>
        // High-Speed CDN Prefix
        const CDN_PREFIX = "https://cdn.jsdelivr.net/gh/bookthief666/93-protocol-game-assets-@662f3d608769e9e945295ac00d668447d974dc5c/";

        const CONFIG = {
            DEBUG: false,
            MENU_MUSIC: CDN_PREFIX + "iamerror%20-%20The%20Zelda%20Song%20(Hyr00l).mp3",
            GAME_PLAYLIST: [
                CDN_PREFIX + "iamerror%20-%20Hyr00l%20Rough.mp4",
                CDN_PREFIX + "bookthief%F0%9F%A5%80%20-%20booothief-%20All%20gay%F0%9F%98%87%202024-07-10%2001_11%20(1).m4a",
                CDN_PREFIX + "Vae!%20Puto%20Deus%20Fio!%20(3).mp3",
                CDN_PREFIX + "IAMERROR%20-%20The%20Iceclops%20Cometh.mp3",
                CDN_PREFIX + "Forest%20of%20Fellatio%20%5BTTn3kjGwXi0%5D.mp3",
                CDN_PREFIX + "LEX_LFL_80_wurli_loop_ate_bit_Cm.wav",
                CDN_PREFIX + "iamerror%20-%20The%20Zelda%20Song%20(Hyr00l).mp3"
            ],
            BASE_URL: "https://lh3.googleusercontent.com/d/",
            IMG_SUFFIX: "=s0",
            
            // EASIER SETTINGS:
            INITIAL_GAME_SPEED: 2.5,
            SPEED_INCREASE_PER_LEVEL: 0.15,
            PILLAR_SPAWN_RATE: 120,
            PILLAR_WIDTH: 45,
            PILLAR_GAP: 250, // Starting gap (larger for easier gameplay)
            PILLAR_GAP_DECREASE_PER_5_LEVELS: 8, // Gets 8px smaller every 5 levels
            MIN_PILLAR_GAP: 180, // Minimum gap size
            ORB_SPAWN_CHANCE: 0.5,
            PLAYER_JUMP_FORCE: -6.5,
            GRAVITY: 0.20,
            
            // Responsive settings - PLAYER IS NOW BIGGER (from 12 to 16)
            PLAYER_RADIUS: 16, // CHANGED FROM 12 TO 16 (33% bigger)
            HITBOX_OFFSET: 4, // Reduced offset for more precise collisions
            MOBILE_CONTROL_DEADZONE: 50,
        };

        const originalLevels = [
            { name: "MALKUTH", id: "1jI7bl3hsVOuzYf6u35L4bhHq5JUiBDa1" },
            { name: "YESOD", id: "1tHgxNvDO5md4z24hS81eTa9uva25mtr5" },
            { name: "HOD", id: "1Mtp6cP6lwGbPRhLWjQKKDijrLX53K4UR" },
            { name: "NETZACH", id: "1y1i5lxL1jVp37bIz1mtJh4-Puce-E5k0" },
            { name: "TIPHARETH", id: "12png0vOPyJC1Ab4Vffcw2R_K-yRw1sqj" },
            { name: "GEBURAH", id: "1le2Hox1ORxhL28fv7WujO0410vM6jUEJ" },
            { name: "CHESED", id: "1Gsq1xSx9ivfVEq6W2nCMrO-dOIMrSYrW" },
            { name: "DA'ATH", id: "1o601hrLi5RpuGL_kiVEoPXxXk2SCbM2z" },
            { name: "BINAH", id: "1iSYJfPsaYjA1rmRTsujLcn1Do-lBydF7" },
            { name: "CHOKMAH", id: "1PvOC62nv5HdsE1cuCF8RENY9Z8HTabn7" },
            { name: "KETHER", id: "1Ym_eyrXJEQUBA7Lg_2oUc6dQ-gy9yfGs" }
        ];

        const newImageIDs = [
            "1pJ5CUGyKXgkSgEREkKos1Kch5FmfUyxE", "1spT4HpO_4q9joE4x6bLjZQRlFTS9j-ie", "1YGzyjcjiCoPCLbYjJEiqT8USUhe4S6hM", "1ELjoJU7KDC88nUk_Vs57OKUG9oLl5E8N",
            "1faa2c3QFWhZ8UgvyZ_ZrlnyFsnsKRclm", "10W5oYkoqB9LC3YjvB_aozR0kG3hWaHka", "1l9Jdm0EQh8sgWh1W0wsXQCzrQM19Bfm9", "1BrHTF2dvfbRkyYfXAbPUiujwE1AJskY4",
            "1KqV8IYF7KDbmgHS3ph6eRQKl4uAAFG_u", "1sZ02UH_vb1xLaOvyETqptc5FuvOtVKd4", "1hLKOGYXCBemcIKt8OLEX4dHTn6bd88cr", "1g_DQeG6qldMBxHzZ82MOVoxk9APwb4NO",
            "1-SIvE5EZyUd7FKXJ7eyB4JCrtOpQoF18", "1S4y4YSCjxSb-b_U1BfMw_0PhabJ-METm", "1OL-kWl-TJNcZFPcsCAtynW2NWp-YYjGd", "1ApPgou40N2Q6GlNKNuyoQ2Gk5DqAfmw_",
            "1OeH1GMu2rDcwzdtWFZSB1WWe0OjkmxV0", "12Z92v9Mu9yNOnDTtK-bjMRZ8_2BAW2eW", "1Erf3DKxZpfbG57oGcUCjuHIhajsweLZz", "1qK22CJhJ1XgElL156uOQxYrucaRG16p0",
            "1euwdAWg-xQw7isR-JAiZ-krXQXOS8pi0", "1A3hT3mJibINtsr8CVxTmp71QsYgPB2JZ", "1QUVr-RK2kP7IIAuy0wX3pOZRQuyr-o-e", "1eF02YMyYBcgx7Ga20pXgoltzWXPYznfD",
            "1zx1vrrbuSA4xCFKXAHgXbkG1rX8PUPel", "1ds1iqXf90gy9PUFs80t4QOxamkJj0u1I", "14-t6dPPv5MeXe7LWPIp7Tjc8x4w5Vj2d", "1pUtIizMzVhjzB46dhah5mgz6Tr-vaSLO",
            "1ZOEkUW8q2s5zerS7BubYJU69RHk7_Zlo", "15ZHj0fLYu-4rEQy43BMJKDgXnnQ5FeyP", "1ZzgVT0O6XQzW3DUP4i1aoKd_DD5wV5LZ", "1rZHZM0bR_j6uiYZLS82J0BkbIfEUoXvY",
            "1CNrQ_EeMXQgHJGXxe7EHysQi_A0A9UE7", "1ubCqIg7ETOIsHGfBjQfVsRzjlZIpBP6E", "1pojzjR-uiQ0oTHRJxXXCW_w0hlJUCqyb", "1SnclBlH6sflhaTWzFhbcNedzNeh25-BV",
            "1thfc-9DnM4GhCi0zTbcX4MH-yaQEpomX", "1BXrXXd9TKSqCFNwvS-cJpNORbyvP6fkR", "1D1bOksatIt6Jw6Zq8Sbmhbq_GC_2EQHh", "1eP_Xnk80YnL3w3Q69wQmVo9_F0OaA3Wo",
            "1ARDOipcr0lB1GYf3gmhqlHXlpC23Q2JE", "1io39jfggXQl-OyvSFGIpgOtoIzHbml3M", "1o0rJmx3vEKITMx1ixP5iruOX2ujOT6VO", "1Irw61utgSGdip21OgTcYqz56LpWWS9fb",
            "19V2ObVoQn9R9bt1ZgMNEBJokaAjYdX_9", "1WWvLnkkPBN7Q0ZsGi16FL1anhPlti3Qd", "1HoYqC0SLc3nrSDnoW9KJ2-z8AnRWIz5M", "1oS0J3F-zh5H48-Qs5Mrm10dPR993kF-b",
            "1bRwsBEuZiAIZW_5f3WOZVI6-KVnCEslk", "1GLza2_RmR4c_KD_KGxbXPOoCAw9SITKl", "1uWFSChozQmHEnuJwXqiPNApXuAwPAzKS", "1t2hNBEudzIo19kuP8ksPY_cNetDdTd8P",
            "1KhMBL7a3NSggVerbyy53fQ-dLq11adwj", "1wgxalTR68YM7oIku8JYZYKtG50atEnG_", "1BceMgnHgVn9U_7EYnXQu9HDwEQY1UBa_", "14_iwYDQjp34-R_iby8QadKnI9m3zVnOu",
            "1cZ_ci9J80jnqCAdag8SQofYZw1dfsX3C", "15z3bGrCqUy8SQjX1dO5C1vlN3y4-soai", "10xAFw98B39Ou0SSeB4eWyoY2D_OLLPgz", "1CexZQw11p33u1-YA7JhPAkGV6NBCgd6e",
            "16t1EdHfHRpb7GmqNAfo2iKKm57qLfbKn", "12wQOhUztVCVEFV21fPDq-JXGi5zxdkeQ", "1-0u9JUH0oUHD1--5iaySxRpO_PuyxkH6", "1wnITY3i6XxOr1b3l6P0cT10LkEHQauO5"
        ].filter((value, index, self) => self.indexOf(value) === index);

        const esotericNames = [
            "KUNDALINI", "HIEROS GAMOS", "SACRED UNION", "RED TINCTURE", "WHITE GLUTEN", 
            "CUP OF BABALON", "BLOOD OF SAINTS", "CITY OF PYRAMIDS", "NIGHT OF PAN", 
            "HADIT'S FLAME", "NUIT'S EMBRACE", "LAW OF THELEMA", "LOVE UNDER WILL", 
            "GREAT WORK", "STONE OF WISE", "ELIXIR OF LIFE", "RED LION", "WHITE EAGLE",
            "ABRAHADABRA", "LASHTAL", "KA", "BA", "KHU", "SCARLET WOMAN", "THE BEAST",
            "AEON OF HORUS", "93", "AGAPE", "THELEMA", "VIA OVUM", "SPERMATOZOON",
            "HOMUNCULUS", "DIVINE EROS", "TANTRA", "YONI", "LINGAM", "O.T.O.", "A.'.A.'.",
            "STAR SAPPHIRE", "MASS OF PHOENIX", "LIBER AL", "RESH", "SAMEKH", "TZADDI"
        ];

        let MASTER_POOL = [...originalLevels];
        
        const palette = ["#ff003c", "#ff00ff", "#9d00ff", "#00f0ff", "#00ff9d", "#d4ff00", "#ff8800"];

        newImageIDs.forEach((id, index) => {
            const nameIndex = index % esotericNames.length;
            MASTER_POOL.push({
                name: esotericNames[nameIndex],
                id: id,
                color: "#000",
                accent: palette[index % palette.length],
                img: null,
                loaded: false
            });
        });

        const GameState = {
            START: 'start',
            LOADING: 'loading',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAME_OVER: 'gameover',
            SETTINGS: 'settings'
        };

        // Detect mobile device
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Mobile-optimized shadow rendering
        const optimizedShadow = {
            apply(ctx, blur, color) {
                if (isMobile) {
                    ctx.shadowBlur = Math.min(blur, 10);
                    ctx.shadowColor = color;
                } else {
                    ctx.shadowBlur = blur;
                    ctx.shadowColor = color;
                }
            },
            clear(ctx) {
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }
        };

        // Glitch Effect System (Lightweight)
        const GlitchFX = {
            active: false,
            duration: 0,
            intensity: 1,
            type: 'rgb',
            
            // Lightweight RGB split effect
            rgbSplit(ctx, intensity) {
                const offset = Math.floor(Math.random() * 3 * intensity);
                const rOffset = Math.random() > 0.5 ? offset : -offset;
                const gOffset = Math.random() > 0.5 ? offset : -offset;
                const bOffset = Math.random() > 0.5 ? offset : -offset;
                
                // Only apply on some frames to save performance
                if (Math.random() > 0.3) return null;
                
                return {
                    rOffset, gOffset, bOffset,
                    draw: function(ctx, width, height) {
                        // Copy current canvas
                        const imageData = ctx.getImageData(0, 0, width, height);
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = width;
                        tempCanvas.height = height;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.putImageData(imageData, 0, 0);
                        
                        // Draw with RGB offsets
                        ctx.save();
                        ctx.globalCompositeOperation = 'screen';
                        
                        // Red channel
                        ctx.globalAlpha = 0.8;
                        ctx.drawImage(tempCanvas, rOffset, 0);
                        
                        // Green channel
                        ctx.globalAlpha = 0.8;
                        ctx.drawImage(tempCanvas, 0, gOffset);
                        
                        // Blue channel
                        ctx.globalAlpha = 0.8;
                        ctx.drawImage(tempCanvas, bOffset, bOffset);
                        
                        ctx.restore();
                    }
                };
            },
            
            // Digital static effect (very lightweight)
            staticEffect(ctx, intensity) {
                // Draw random pixels/rectangles
                ctx.save();
                ctx.globalAlpha = 0.1 * intensity;
                
                for (let i = 0; i < 5; i++) { // Only 5 per frame
                    const x = Math.random() * ctx.canvas.width;
                    const y = Math.random() * ctx.canvas.height;
                    const size = Math.random() * 10 * intensity + 2;
                    
                    ctx.fillStyle = Math.random() > 0.5 ? '#ff003c' : '#00ffff';
                    ctx.fillRect(x, y, size, 1);
                    
                    if (Math.random() > 0.7) {
                        ctx.fillStyle = Math.random() > 0.5 ? '#ff00ff' : '#00ff9d';
                        ctx.fillRect(x, y + 2, 1, size);
                    }
                }
                ctx.restore();
            },
            
            // Scanline distortion (lightweight)
            scanlineDistort(ctx, intensity) {
                if (Math.random() > 0.5) return;
                
                ctx.save();
                ctx.globalAlpha = 0.05 * intensity;
                ctx.fillStyle = '#fff';
                
                const lineCount = Math.floor(3 * intensity);
                for (let i = 0; i < lineCount; i++) {
                    const y = Math.floor(Math.random() * ctx.canvas.height);
                    const height = Math.random() * 2 + 1;
                    const wave = Math.sin(Date.now() * 0.01 + i) * 10 * intensity;
                    
                    ctx.fillRect(0, y, ctx.canvas.width, height);
                    ctx.fillRect(wave, y + 5, ctx.canvas.width, 1);
                }
                ctx.restore();
            },
            
            // Block displacement (very cheap)
            blockDisplace(ctx, intensity) {
                if (Math.random() > 0.7) return;
                
                ctx.save();
                ctx.globalAlpha = 0.3 * intensity;
                
                // Draw a few displaced blocks
                for (let i = 0; i < 2; i++) {
                    const x = Math.random() * ctx.canvas.width;
                    const y = Math.random() * ctx.canvas.height;
                    const width = Math.random() * 50 * intensity + 20;
                    const height = Math.random() * 50 * intensity + 20;
                    const offsetX = (Math.random() - 0.5) * 10 * intensity;
                    const offsetY = (Math.random() - 0.5) * 10 * intensity;
                    
                    ctx.fillStyle = Math.random() > 0.5 ? '#ff003c' : '#00ffff';
                    ctx.fillRect(x + offsetX, y + offsetY, width, height);
                }
                ctx.restore();
            },
            
            // Apply all glitch effects (called each frame)
            apply(ctx, currentTime) {
                if (!this.active || this.duration <= 0) return;
                
                const progress = this.duration / 100; // Normalized progress
                this.intensity = Math.min(1, progress * 2);
                
                // Apply different effects based on random chance
                if (Math.random() > 0.5) this.staticEffect(ctx, this.intensity);
                if (Math.random() > 0.6) this.scanlineDistort(ctx, this.intensity);
                if (Math.random() > 0.7) this.blockDisplace(ctx, this.intensity);
                
                // RGB split only occasionally as it's more expensive
                if (Math.random() > 0.8) {
                    const rgbEffect = this.rgbSplit(ctx, this.intensity);
                    if (rgbEffect) rgbEffect.draw(ctx, ctx.canvas.width, ctx.canvas.height);
                }
                
                this.duration -= 16; // Decrease by ~1 frame at 60fps
                if (this.duration <= 0) {
                    this.active = false;
                    this.intensity = 1;
                }
            },
            
            // Trigger a glitch effect
            trigger(duration = 100, type = 'all') {
                this.active = true;
                this.duration = duration;
                this.type = type;
                this.intensity = 1;
            }
        };

        const SFX = {
            audioContext: null,
            init() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
            },
            playTone(freq, type, duration, vol, detune = 0) {
                if (!game?.settings?.sfx) return;
                if (!this.audioContext) this.init();
                if (this.audioContext.state === 'suspended') this.audioContext.resume();
                
                try {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    
                    osc.type = type;
                    osc.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                    osc.detune.setValueAtTime(detune, this.audioContext.currentTime);
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    gain.gain.setValueAtTime(vol, this.audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                    
                    osc.start();
                    osc.stop(this.audioContext.currentTime + duration);
                } catch(e){}
            },
            jump() { 
                this.playTone(400, 'square', 0.08, 0.1);
                this.playTone(600, 'sine', 0.05, 0.05, 100);
            },
            collect() { 
                this.playTone(800, 'sine', 0.2, 0.1);
                this.playTone(1200, 'triangle', 0.1, 0.05, 50);
            },
            crash() { 
                this.playTone(100, 'sawtooth', 0.5, 0.3);
                this.playTone(80, 'square', 0.3, 0.2, -100);
            },
            levelUp() { 
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.5);
                osc.connect(gain);
                gain.connect(this.audioContext.destination);
                gain.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                osc.start();
                osc.stop(this.audioContext.currentTime + 0.5);
            }
        };

        // Haptic Feedback System
        const Haptics = {
            jump() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([15]);
                }
            },
            collect() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([30, 20, 30]);
                }
            },
            crash() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([150, 30, 80, 30, 40]);
                }
            },
            levelUp() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([80, 20, 80, 20, 80]);
                }
            }
        };

        const AudioSys = {
            bgm: null,
            localBlobUrl: null,
            currentMode: 'none', 
            retryCount: 0,
            
            setStatus(msg) {
                const el = document.getElementById('audioStatus');
                if (el) {
                    el.textContent = msg;
                    el.style.color = '#fff';
                    setTimeout(() => el.style.color = 'var(--primary)', 200);
                }
            },

            init() {
                this.setupAudioElement(CONFIG.MENU_MUSIC);
                this.currentMode = 'menu';
                this.setStatus("MENU AUDIO RDY");
            },

            setupAudioElement(src) {
                if (this.bgm) {
                    this.bgm.pause();
                    this.bgm.src = "";
                    this.bgm.load();
                }
                this.bgm = new Audio();
                this.bgm.src = src;
                this.bgm.loop = true;
                this.bgm.volume = 0.8;
                this.bgm.preload = "auto";
                
                this.bgm.onwaiting = () => this.setStatus("BUFFERING...");
                this.bgm.onplaying = () => {
                    this.setStatus("PLAYING");
                    this.retryCount = 0;
                };
                
                this.bgm.onerror = (e) => {
                    console.warn("Audio error:", e);
                    this.setStatus("LOAD ERROR");
                };
            },

            loadLocalFile(file) {
                if (this.localBlobUrl) URL.revokeObjectURL(this.localBlobUrl);
                this.localBlobUrl = URL.createObjectURL(file);
                this.setupAudioElement(this.localBlobUrl);
                this.setStatus("FILE LOADED");
            },
            
            switchToGameMusic() {
                if (this.localBlobUrl) return; 
                const randomIndex = Math.floor(Math.random() * CONFIG.GAME_PLAYLIST.length);
                const track = CONFIG.GAME_PLAYLIST[randomIndex];
                this.currentMode = 'game';
                this.setStatus("LOADING TRK " + (randomIndex + 1));
                this.setupAudioElement(track);
                this.play();
            },

            switchToMenuMusic() {
                if (this.localBlobUrl) return;
                this.currentMode = 'menu';
                this.setStatus("LOADING MENU");
                this.setupAudioElement(CONFIG.MENU_MUSIC);
            },
            
            play() {
                if (!this.bgm) return;
                const playPromise = this.bgm.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => this.setStatus("PLAYING")).catch(error => {
                        console.warn("Play failed:", error);
                        this.setStatus("AUTOPLAY BLOCK");
                    });
                }
            },
            
            pause() { if (this.bgm) { this.bgm.pause(); this.setStatus("PAUSED"); } },
            resume() { if (this.bgm && this.bgm.paused) { this.bgm.play(); this.setStatus("RESUMED"); } },
            stop() { if (this.bgm) { this.bgm.pause(); this.bgm.currentTime = 0; this.setStatus("STOPPED"); } }
        };

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.root = document.documentElement;
                
                this.state = GameState.START;
                this.currentLevelIdx = 0;
                this.frames = 0;
                this.score = 0;
                this.highScore = localStorage.getItem('93protocol_highscore') || 0;
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED;
                this.shake = 0;
                this.lastFrameTime = 0;
                this.fps = 0;
                
                // Responsive properties
                this.isMobile = isMobile;
                this.aspectRatio = 16/9;
                this.baseWidth = 800;
                this.baseHeight = 450;
                this.scaleFactor = 1;
                
                // Glitch effect properties
                this.glitchEffect = false;
                this.glitchTimer = 0;
                this.glitchDuration = 300;
                
                // Hyperspace tunnel properties
                this.tunnelOffset = 0;
                this.tunnelSpeed = 0.5;
                
                // Screen flash effect
                this.screenFlash = null;
                
                this.backgroundParticles = [];
                
                this.player = null;
                this.particles = [];
                this.stars = [];
                this.obstacles = [];
                this.collectibles = [];
                this.gameLevels = []; 
                
                this.settings = { music: true, sfx: true, vibration: true };
                
                this.loadSettings();
                this.initEventListeners();
                this.resizeCanvas();
                this.preloadAllImages();
                this.createBackgroundParticles();
                
                AudioSys.init();
                SFX.init();
            }
            
            createBackgroundParticles() {
                for (let i = 0; i < 60; i++) {
                    this.backgroundParticles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        z: Math.random() * 2 + 0.5,
                        size: Math.random() * 2 + 1,
                        speed: Math.random() * 0.5 + 0.1,
                        color: palette[Math.floor(Math.random() * palette.length)],
                        opacity: Math.random() * 0.4 + 0.1,
                        shape: Math.floor(Math.random() * 3)
                    });
                }
            }
            
            // Glitch effect methods
            triggerOrbGlitch() {
                // Quick, intense glitch for orb collection
                GlitchFX.trigger(80, 'orb');
                
                // Also add screen flash
                this.screenFlash = {
                    active: true,
                    duration: 10,
                    color: '#ffd700',
                    intensity: 0.3
                };
            }
            
            triggerLevelUpGlitch() {
                // Longer, more intense glitch for level up
                GlitchFX.trigger(150, 'level');
                
                // Screen flash
                this.screenFlash = {
                    active: true,
                    duration: 20,
                    color: this.gameLevels[this.currentLevelIdx]?.accent || '#ff003c',
                    intensity: 0.4
                };
            }
            
            triggerDeathGlitch() {
                // Long, intense glitch for death
                GlitchFX.trigger(200, 'death');
                
                // Red screen flash
                this.screenFlash = {
                    active: true,
                    duration: 30,
                    color: '#ff003c',
                    intensity: 0.6
                };
            }
            
            applyScreenFlash() {
                if (!this.screenFlash || !this.screenFlash.active) return;
                
                this.ctx.save();
                this.ctx.fillStyle = this.screenFlash.color;
                this.ctx.globalAlpha = this.screenFlash.intensity * (this.screenFlash.duration / 30);
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.restore();
                
                this.screenFlash.duration--;
                if (this.screenFlash.duration <= 0) {
                    this.screenFlash.active = false;
                }
            }
            
            initEventListeners() {
                document.getElementById('fileUpload').addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) AudioSys.loadLocalFile(file);
                });

                window.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && this.state === GameState.PLAYING) this.playerJump();
                    else if (e.code === 'Escape') this.togglePause();
                });
                
                window.addEventListener('mousedown', (e) => {
                    if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'LABEL' && this.state === GameState.PLAYING) this.playerJump();
                });
                
                window.addEventListener('touchstart', (e) => {
                    if (this.state === GameState.PLAYING) {
                        e.preventDefault();
                        const touchY = e.touches[0].clientY;
                        // Check if touch is in the bottom 40% of screen (jump area)
                        if (touchY > window.innerHeight * 0.6) {
                            this.playerJump();
                        }
                    }
                }, { passive: false });
                
                document.getElementById('startBtn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (this.settings.music) AudioSys.switchToGameMusic();
                    this.startGame();
                });
                
                document.getElementById('restartBtn').addEventListener('click', (e) => {
                     e.stopPropagation();
                     if (this.settings.music) AudioSys.switchToGameMusic();
                     this.restartGame();
                });
                
                document.getElementById('pauseBtn').addEventListener('click', (e) => { e.stopPropagation(); this.togglePause(); });
                document.getElementById('resumeBtn').addEventListener('click', (e) => { e.stopPropagation(); this.togglePause(); });
                document.getElementById('menuBtn').addEventListener('click', (e) => { e.stopPropagation(); this.returnToMenu(); });
                document.getElementById('settingsBtn').addEventListener('click', (e) => { e.stopPropagation(); this.showSettings(); });
                document.getElementById('backBtn').addEventListener('click', (e) => { e.stopPropagation(); this.hideSettings(); });
                
                document.getElementById('musicToggle').addEventListener('change', (e) => {
                    this.settings.music = e.target.checked;
                    this.saveSettings();
                    if (!this.settings.music) AudioSys.stop();
                    else if (this.state === GameState.PLAYING) AudioSys.play();
                });
                
                document.getElementById('sfxToggle').addEventListener('change', (e) => {
                    this.settings.sfx = e.target.checked;
                    this.saveSettings();
                });
                
                document.getElementById('vibrationToggle').addEventListener('change', (e) => {
                    this.settings.vibration = e.target.checked;
                    this.saveSettings();
                });
                
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            loadSettings() {
                const saved = localStorage.getItem('93protocol_settings');
                if (saved) this.settings = { ...this.settings, ...JSON.parse(saved) };
                document.getElementById('musicToggle').checked = this.settings.music;
                document.getElementById('sfxToggle').checked = this.settings.sfx;
                document.getElementById('vibrationToggle').checked = this.settings.vibration;
            }
            
            saveSettings() { localStorage.setItem('93protocol_settings', JSON.stringify(this.settings)); }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.calculateScaleFactor();
                this.adjustForScreenSize();
            }
            
            calculateScaleFactor() {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const targetRatio = 16/9;
                const currentRatio = width/height;
                
                if (currentRatio > targetRatio) {
                    this.scaleFactor = height / this.baseHeight;
                } else {
                    this.scaleFactor = width / this.baseWidth;
                }
                
                this.scaleFactor = Math.max(0.6, Math.min(this.scaleFactor, 1.5));
            }
            
            adjustForScreenSize() {
                const screenHeight = this.canvas.height;
                
                // Adjust pillar gap based on screen height
                let baseGap = CONFIG.PILLAR_GAP;
                
                // Smaller screens get slightly larger gaps for easier gameplay
                if (screenHeight < 600) {
                    baseGap = Math.min(270, baseGap * 1.08);
                } else if (screenHeight > 800) {
                    baseGap = Math.max(240, baseGap * 0.95);
                }
                
                // Store the base gap for this screen size
                this.currentBaseGap = baseGap;
            }
            
            preloadAllImages() {
                const progressFill = document.getElementById('progressFill');
                const loadingText = document.getElementById('loadingText');
                let loadedCount = 0;
                
                const failsafe = setTimeout(() => {
                    if (loadedCount < MASTER_POOL.length) {
                        console.warn("Loading timed out. Forcing start.");
                        this.finishLoading();
                    }
                }, 5000);
                
                MASTER_POOL.forEach(lvl => {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.onload = () => {
                        lvl.img = img;
                        lvl.loaded = true;
                        loadedCount++;
                        const percent = Math.floor((loadedCount / MASTER_POOL.length) * 100);
                        progressFill.style.width = `${percent}%`;
                        loadingText.innerText = `CHARGING SIGIL... ${loadedCount}/${MASTER_POOL.length}`;
                        if (loadedCount >= MASTER_POOL.length) {
                            clearTimeout(failsafe);
                            this.finishLoading();
                        }
                    };
                    img.onerror = () => {
                        console.warn(`Failed to load image: ${lvl.id}`);
                        loadedCount++;
                        if (loadedCount >= MASTER_POOL.length) {
                            clearTimeout(failsafe);
                            this.finishLoading();
                        }
                    };
                    img.src = CONFIG.BASE_URL + lvl.id + CONFIG.IMG_SUFFIX;
                });
            }
            
            finishLoading() {
                setTimeout(() => {
                    document.getElementById('loadingMsg').classList.add('hidden');
                    document.getElementById('menuButtons').classList.remove('hidden');
                }, 500);
            }
            
            prepareLevels() {
                let shuffled = [...MASTER_POOL];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                this.gameLevels = shuffled.map((lvl, index) => {
                    return { ...lvl, threshold: index * 5 };
                });
            }

            startGame() {
                this.prepareLevels();
                this.state = GameState.PLAYING;
                document.getElementById('startScreen').classList.add('hidden');
                document.getElementById('scoreUi').classList.remove('hidden');
                document.getElementById('pauseBtn').classList.remove('hidden');
                document.getElementById('instructions').classList.remove('hidden');
                
                // Show mobile controls on mobile devices
                if (this.isMobile) {
                    document.getElementById('mobileControls').classList.remove('hidden');
                    // Hide mobile controls after 5 seconds
                    setTimeout(() => {
                        document.getElementById('mobileControls').classList.add('hidden');
                    }, 5000);
                }
                
                if (CONFIG.DEBUG) document.getElementById('statsPanel').classList.remove('hidden');
                this.initGame();
                this.gameLoop();
            }
            
            initGame() {
                this.player = new Player();
                this.obstacles = [];
                this.collectibles = [];
                this.particles = [];
                this.stars = [];
                for (let i = 0; i < 40; i++) this.stars.push(new Star());
                this.score = 0;
                this.currentLevelIdx = 0;
                this.frames = 0;
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED;
                this.shake = 0;
                this.tunnelOffset = 0;
                document.getElementById('scoreUi').innerText = "0";
                this.applyLevel();
            }
            
            applyLevel() {
                if (this.currentLevelIdx >= this.gameLevels.length) return;
                const l = this.gameLevels[this.currentLevelIdx];
                document.getElementById('levelUi').innerText = l.name;
                document.getElementById('levelUi').style.color = l.accent;
                document.getElementById('levelUi').style.textShadow = `0 0 15px ${l.accent}`;
                this.root.style.setProperty('--primary', l.accent);
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED + (this.currentLevelIdx * CONFIG.SPEED_INCREASE_PER_LEVEL);
                
                if (this.currentLevelIdx > 0) {
                    this.triggerGlitchEffect();
                    Haptics.levelUp();
                    if (this.settings.sfx) SFX.levelUp();
                }
            }
            
            triggerGlitchEffect() {
                this.glitchEffect = true;
                this.glitchTimer = this.glitchDuration;
            }
            
            applyGlitchEffect() {
                if (!this.glitchEffect) return;
                
                const ctx = this.ctx;
                const intensity = this.glitchTimer / this.glitchDuration;
                
                if (Math.random() > 0.7) {
                    const shiftX = Math.floor(Math.random() * 10 * intensity) - 5;
                    const shiftY = Math.floor(Math.random() * 10 * intensity) - 5;
                    
                    ctx.save();
                    ctx.translate(shiftX, shiftY);
                    ctx.restore();
                }
                
                if (Math.random() > 0.8) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fillRect(0, Math.floor(Math.random() * this.canvas.height), this.canvas.width, 1);
                }
                
                this.glitchTimer -= 16;
                if (this.glitchTimer <= 0) {
                    this.glitchEffect = false;
                }
            }
            
            getCurrentGap() {
                // Calculate gap based on current level - gets smaller every 5 levels
                const baseGap = this.currentBaseGap || CONFIG.PILLAR_GAP;
                const levelsCompleted = Math.floor(this.currentLevelIdx / 5);
                const gapReduction = levelsCompleted * CONFIG.PILLAR_GAP_DECREASE_PER_5_LEVELS;
                const calculatedGap = Math.max(CONFIG.MIN_PILLAR_GAP, baseGap - gapReduction);
                
                return calculatedGap;
            }
            
            checkLevel() {
                const nextIdx = this.currentLevelIdx + 1;
                if (nextIdx >= this.gameLevels.length) return;
                const next = this.gameLevels[nextIdx];
                if (this.score >= next.threshold) {
                    this.currentLevelIdx++;
                    this.applyLevel();
                    this.shake = 12;
                    
                    // Trigger level up glitch
                    this.triggerLevelUpGlitch();
                    
                    for (let i = 0; i < 30; i++) {
                        this.particles.push(new Particle(
                            this.canvas.width / 2, this.canvas.height / 2, 
                            this.gameLevels[this.currentLevelIdx].accent, 12,
                            Math.random() > 0.5 ? 'hexagram' : 'triangle'
                        ));
                    }
                    
                    if (this.settings.sfx) SFX.levelUp();
                    Haptics.levelUp();
                }
            }
            
            playerJump() {
                if (this.state === GameState.PLAYING) {
                    this.player.jump();
                    Haptics.jump();
                }
            }
            
            togglePause() {
                if (this.state === GameState.PLAYING) {
                    this.state = GameState.PAUSED;
                    document.getElementById('pauseScreen').classList.remove('hidden');
                    AudioSys.pause();
                } else if (this.state === GameState.PAUSED) {
                    this.state = GameState.PLAYING;
                    document.getElementById('pauseScreen').classList.add('hidden');
                    AudioSys.resume();
                    this.gameLoop();
                }
            }
            
            showSettings() {
                document.getElementById('startScreen').classList.add('hidden');
                document.getElementById('settingsScreen').classList.remove('hidden');
                this.state = GameState.SETTINGS;
            }
            
            hideSettings() {
                document.getElementById('settingsScreen').classList.add('hidden');
                document.getElementById('startScreen').classList.remove('hidden');
                this.state = GameState.START;
            }
            
            returnToMenu() {
                this.state = GameState.START;
                document.getElementById('pauseScreen').classList.add('hidden');
                document.getElementById('startScreen').classList.remove('hidden');
                document.getElementById('scoreUi').classList.add('hidden');
                document.getElementById('pauseBtn').classList.add('hidden');
                document.getElementById('instructions').classList.add('hidden');
                document.getElementById('statsPanel').classList.add('hidden');
                document.getElementById('mobileControls').classList.add('hidden');
                if (this.settings.music) AudioSys.switchToMenuMusic();
            }
            
            gameOver() {
                if (this.state === GameState.GAME_OVER) return;
                this.state = GameState.GAME_OVER;
                this.shake = 15;
                
                // Trigger death glitch
                this.triggerDeathGlitch();
                
                if (this.settings.sfx) SFX.crash();
                Haptics.crash();
                
                for (let i = 0; i < 25; i++) {
                    this.particles.push(new Particle(
                        this.player.x, this.player.y,
                        '#ff003c', 10,
                        Math.random() > 0.3 ? 'hexagram' : 'triangle'
                    ));
                }
                
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('93protocol_highscore', this.highScore);
                    document.getElementById('highScoreMsg').textContent = "NEW GNOSIS ATTAINED";
                } else {
                    document.getElementById('highScoreMsg').textContent = `BEST: ${this.highScore}`;
                }
                AudioSys.stop();
                document.getElementById('finalScore').innerText = this.score;
                document.getElementById('scoreUi').classList.add('hidden');
                document.getElementById('pauseBtn').classList.add('hidden');
                document.getElementById('instructions').classList.add('hidden');
                document.getElementById('statsPanel').classList.add('hidden');
                document.getElementById('mobileControls').classList.add('hidden');
                document.getElementById('gameOverScreen').classList.remove('hidden');
            }
            
            restartGame() {
                this.state = GameState.PLAYING;
                this.prepareLevels();
                document.getElementById('gameOverScreen').classList.add('hidden');
                document.getElementById('scoreUi').classList.remove('hidden');
                document.getElementById('pauseBtn').classList.remove('hidden');
                document.getElementById('instructions').classList.remove('hidden');
                if (this.isMobile) {
                    document.getElementById('mobileControls').classList.remove('hidden');
                    setTimeout(() => {
                        document.getElementById('mobileControls').classList.add('hidden');
                    }, 5000);
                }
                if (CONFIG.DEBUG) document.getElementById('statsPanel').classList.remove('hidden');
                this.initGame();
                this.gameLoop();
            }
            
            gameLoop(currentTime = 0) {
                if (this.state !== GameState.PLAYING) return;
                if (this.lastFrameTime) {
                    this.fps = Math.round(1000 / (currentTime - this.lastFrameTime));
                    if (CONFIG.DEBUG) document.getElementById('fpsCounter').textContent = this.fps;
                }
                this.lastFrameTime = currentTime;
                this.frames++;
                const lvl = this.gameLevels[this.currentLevelIdx];
                
                // Random occasional glitch (very rare, minimal performance impact)
                if (Math.random() > 0.995 && this.frames % 60 === 0) {
                    GlitchFX.trigger(30, 'random');
                }
                
                this.tunnelOffset += this.tunnelSpeed * (1 + this.gameSpeed * 0.1);
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.drawHyperspaceTunnel(lvl);
                
                // Apply glitch effects
                GlitchFX.apply(this.ctx, currentTime);
                
                // Apply screen flash if active
                this.applyScreenFlash();
                
                if (this.glitchEffect) {
                    this.applyGlitchEffect();
                }
                
                this.ctx.save();
                if (this.shake > 0) {
                    this.ctx.translate((Math.random() - 0.5) * this.shake, (Math.random() - 0.5) * this.shake);
                    this.shake *= 0.9;
                }
                this.updateGameObjects();
                this.drawGameObjects();
                this.ctx.restore();
                
                requestAnimationFrame((time) => this.gameLoop(time));
            }
            
            drawHyperspaceTunnel(lvl) {
                const ctx = this.ctx;
                const cx = this.canvas.width / 2;
                const cy = this.canvas.height / 2;
                const maxRadius = Math.max(this.canvas.width, this.canvas.height) * 0.8;
                
                ctx.strokeStyle = lvl.accent;
                ctx.lineWidth = 1.5;
                optimizedShadow.apply(ctx, 15, lvl.accent);
                
                for (let i = 0; i < 10; i++) {
                    const progress = ((this.tunnelOffset + i * 50) % 300) / 300;
                    const radius = progress * maxRadius;
                    
                    if (radius < 50) continue;
                    
                    ctx.globalAlpha = 1 - progress * 0.8;
                    ctx.beginPath();
                    ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    for (let j = 0; j < 8; j++) {
                        const angle = (j / 8) * Math.PI * 2;
                        const x1 = cx + Math.cos(angle) * radius;
                        const y1 = cy + Math.sin(angle) * radius;
                        const x2 = cx + Math.cos(angle) * (radius + 20);
                        const y2 = cy + Math.sin(angle) * (radius + 20);
                        
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }
                
                optimizedShadow.clear(ctx);
                ctx.globalAlpha = 1;
                
                // Random subtle glitch on background (very lightweight)
                if (Math.random() > 0.95 && this.frames % 30 === 0) {
                    ctx.save();
                    ctx.globalAlpha = 0.05;
                    ctx.fillStyle = lvl.accent;
                    
                    // Draw a random line
                    const y = Math.random() * this.canvas.height;
                    ctx.fillRect(0, y, this.canvas.width, 1);
                    
                    // Maybe a random rectangle
                    if (Math.random() > 0.5) {
                        const x = Math.random() * this.canvas.width;
                        const size = Math.random() * 20 + 5;
                        ctx.fillRect(x, Math.random() * this.canvas.height, size, 1);
                    }
                    ctx.restore();
                }
                
                this.backgroundParticles.forEach(p => {
                    p.y += p.speed * (1 + this.gameSpeed * 0.1);
                    if (p.y > this.canvas.height) { 
                        p.y = 0; 
                        p.x = Math.random() * this.canvas.width;
                        p.shape = Math.floor(Math.random() * 3);
                    }
                    
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.opacity;
                    
                    if (p.shape === 1) {
                        ctx.save();
                        ctx.translate(p.x, p.y);
                        ctx.rotate(this.frames * 0.01);
                        ctx.beginPath();
                        ctx.moveTo(0, -p.size);
                        ctx.lineTo(p.size * 0.866, p.size * 0.5);
                        ctx.lineTo(-p.size * 0.866, p.size * 0.5);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    } else if (p.shape === 2) {
                        ctx.save();
                        ctx.translate(p.x, p.y);
                        ctx.rotate(this.frames * 0.02);
                        const r = p.size * 0.8;
                        ctx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * 60) * Math.PI / 180;
                            const x = Math.cos(angle) * r;
                            const y = Math.sin(angle) * r;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    } else {
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                ctx.globalAlpha = 1;
                
                // FIXED: Improved background image scaling to prevent cropping
                ctx.globalAlpha = 0.6; 
                if (lvl.loaded && lvl.img && lvl.img.complete) {
                    try {
                        const img = lvl.img;
                        const canvasRatio = this.canvas.width / this.canvas.height;
                        const imgRatio = img.width / img.height;
                        
                        let drawWidth, drawHeight, drawX, drawY;
                        
                        if (canvasRatio > imgRatio) {
                            // Canvas is wider than image - fit to height, center horizontally
                            drawHeight = this.canvas.height;
                            drawWidth = img.width * (drawHeight / img.height);
                            drawX = (this.canvas.width - drawWidth) / 2;
                            drawY = 0;
                        } else {
                            // Canvas is taller than image - fit to width, center vertically
                            drawWidth = this.canvas.width;
                            drawHeight = img.height * (drawWidth / img.width);
                            drawX = 0;
                            drawY = (this.canvas.height - drawHeight) / 2;
                        }
                        
                        // Add a subtle blur effect to hide any minor edges
                        ctx.filter = 'blur(1px)';
                        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                        ctx.filter = 'none';
                        
                    } catch (e) {
                        console.warn("Error drawing background image:", e);
                    }
                }
                ctx.globalAlpha = 1.0;
            }
            
            updateGameObjects() {
                // Calculate current gap based on level
                const currentGap = this.getCurrentGap();
                
                if (this.frames % Math.floor(CONFIG.PILLAR_SPAWN_RATE / (1 + this.gameSpeed * 0.05)) === 0) {
                    const p = new Pillar(this.currentLevelIdx, currentGap);
                    this.obstacles.push(p);
                    if (Math.random() > (1 - CONFIG.ORB_SPAWN_CHANCE)) {
                        this.collectibles.push(new Orb(p.x + p.w / 2, p.top + p.gap / 2));
                    }
                }
                
                this.obstacles.forEach((o, i) => {
                    o.update(this.gameSpeed);
                    
                    // FIXED COLLISION DETECTION - More precise hitbox
                    const hitboxReduction = CONFIG.HITBOX_OFFSET;
                    
                    // Player hitbox boundaries
                    const pLeft = this.player.x - this.player.r + hitboxReduction;
                    const pRight = this.player.x + this.player.r - hitboxReduction;
                    const pTop = this.player.y - this.player.r + hitboxReduction;
                    const pBottom = this.player.y + this.player.r - hitboxReduction;
                    
                    // Pillar boundaries
                    const pillarLeft = o.x;
                    const pillarRight = o.x + o.w;
                    
                    // Check collision with TOP pillar
                    const topPillarBottom = o.top;
                    const topPillarTop = 0;
                    
                    // Check collision with BOTTOM pillar
                    const bottomPillarTop = o.top + o.gap;
                    const bottomPillarBottom = this.canvas.height;
                    
                    // Check if player is horizontally aligned with pillar
                    const horizontalOverlap = pRight > pillarLeft && pLeft < pillarRight;
                    
                    // Check collision with TOP pillar
                    const hittingTopPillar = horizontalOverlap && 
                                             pBottom > topPillarTop && 
                                             pTop < topPillarBottom;
                    
                    // Check collision with BOTTOM pillar
                    const hittingBottomPillar = horizontalOverlap && 
                                                pTop < bottomPillarBottom && 
                                                pBottom > bottomPillarTop;
                    
                    // Game over if hitting either pillar
                    if (hittingTopPillar || hittingBottomPillar) {
                        this.gameOver();
                    }
                    
                    if (!o.marked && o.x + o.w < this.player.x) {
                        this.score++;
                        o.marked = true;
                        document.getElementById('scoreUi').innerText = this.score;
                        this.checkLevel();
                    }
                    if (o.x < -100) this.obstacles.splice(i, 1);
                });
                
                this.collectibles.forEach((c, i) => {
                    c.update(this.gameSpeed);
                    const dist = Math.hypot(this.player.x - c.x, this.player.y - c.y);
                    if (dist < this.player.r + c.r && !c.collected) {
                        this.score += 5;
                        document.getElementById('scoreUi').innerText = this.score;
                        c.collected = true;
                        
                        // Trigger glitch effect
                        this.triggerOrbGlitch();
                        
                        for (let k = 0; k < 20; k++) {
                            this.particles.push(new Particle(
                                c.x, c.y, 
                                '#ffd700', 8,
                                Math.random() > 0.6 ? 'hexagram' : 
                                Math.random() > 0.3 ? 'triangle' : 'diamond'
                            ));
                        }
                        
                        if (this.settings.sfx) SFX.collect();
                        Haptics.collect();
                        
                        this.collectibles.splice(i, 1);
                        this.checkLevel();
                    }
                    if (c.x < -50) this.collectibles.splice(i, 1);
                });
                
                this.player.update();
                
                this.particles.forEach((p, i) => {
                    p.update();
                    if (p.life <= 0) this.particles.splice(i, 1);
                });
            }
            
            drawGameObjects() {
                const currentLvlConfig = this.gameLevels[this.currentLevelIdx];
                this.obstacles.forEach(o => o.draw(this.ctx, currentLvlConfig));
                this.collectibles.forEach(c => c.draw(this.ctx));
                this.player.draw(this.ctx, currentLvlConfig);
                this.particles.forEach(p => p.draw(this.ctx));
            }
        }

        class Player {
            constructor() {
                this.x = window.innerWidth * 0.25;
                this.y = window.innerHeight / 2;
                this.vy = 0;
                this.r = CONFIG.PLAYER_RADIUS; // Now 16 instead of 12
                this.rot = 0;
                this.trail = [];
                this.trailLength = game.isMobile ? 8 : 12;
                this.jumpCooldown = 0;
            }
            
            update() {
                this.vy += CONFIG.GRAVITY;
                this.y += this.vy;
                this.rot += 0.03;
                if (this.y > window.innerHeight - this.r * 1.5) {
                    game.gameOver();
                }
                if (this.y < this.r * 1.5) { 
                    this.y = this.r * 1.5; 
                    this.vy = 0; 
                }
                
                if (this.jumpCooldown > 0) {
                    this.jumpCooldown--;
                }
                
                if (game.frames % 2 === 0) {
                    this.trail.unshift({
                        x: this.x, 
                        y: this.y, 
                        r: this.r, 
                        life: 1.0,
                        rot: this.rot
                    });
                    if (this.trail.length > this.trailLength) this.trail.pop();
                }
                
                this.trail.forEach(t => t.life -= 0.05);
            }
            
            draw(ctx, conf) {
                const hue = (game.frames * 2) % 360;
                const strokeColor = `hsl(${hue}, 100%, 60%)`;
                const shadowColor = `hsl(${hue}, 100%, 50%)`;

                this.trail.forEach((t, i) => {
                    if (t.life > 0) {
                        ctx.save();
                        ctx.globalAlpha = t.life * 0.6;
                        ctx.translate(t.x, t.y);
                        ctx.rotate(t.rot + (this.vy * 0.05));
                        
                        const trailR = t.r * 0.7 * t.life;
                        const points = [];
                        for (let j = 0; j < 6; j++) {
                            const angle = (j * 60 - 90) * Math.PI / 180;
                            points.push({ 
                                x: Math.cos(angle) * trailR, 
                                y: Math.sin(angle) * trailR 
                            });
                        }
                        
                        optimizedShadow.apply(ctx, 20 * t.life, shadowColor);
                        ctx.strokeStyle = strokeColor;
                        ctx.lineWidth = 2 * t.life;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';

                        ctx.beginPath();
                        ctx.moveTo(points[0].x, points[0].y);
                        ctx.lineTo(points[2].x, points[2].y);
                        ctx.lineTo(points[5].x, points[5].y);
                        ctx.lineTo(points[3].x, points[3].y);
                        ctx.lineTo(points[1].x, points[1].y);
                        ctx.lineTo(points[4].x, points[4].y);
                        ctx.lineTo(points[0].x, points[0].y);
                        ctx.stroke();
                        
                        ctx.restore();
                    }
                });
                ctx.globalAlpha = 1.0;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rot + (this.vy * 0.05));
                
                const r = this.r * 1.2; // Bigger radius makes the player appear larger
                const points = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (i * 60 - 90) * Math.PI / 180;
                    points.push({ x: Math.cos(angle) * r, y: Math.sin(angle) * r });
                }
                
                optimizedShadow.apply(ctx, 25, shadowColor);
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                ctx.lineTo(points[2].x, points[2].y);
                ctx.lineTo(points[5].x, points[5].y);
                ctx.lineTo(points[3].x, points[3].y);
                ctx.lineTo(points[1].x, points[1].y);
                ctx.lineTo(points[4].x, points[4].y);
                ctx.lineTo(points[0].x, points[0].y);
                ctx.stroke();
                
                const pulse = Math.sin(game.frames * 0.1) * 0.5 + 1;
                ctx.fillStyle = "#fff";
                optimizedShadow.apply(ctx, 40 * pulse, "#fff");
                ctx.beginPath();
                ctx.arc(0, 0, 3 * pulse, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
            
            jump() {
                if (this.jumpCooldown > 0) return;
                
                this.vy = CONFIG.PLAYER_JUMP_FORCE;
                this.jumpCooldown = game.isMobile ? 8 : 5;
                
                // Small glitch on jump
                if (Math.random() > 0.7) {
                    GlitchFX.trigger(40, 'jump');
                }
                
                for (let i = 0; i < (game.isMobile ? 10 : 12); i++) {
                    const type = Math.random() > 0.7 ? 'hexagram' : 
                                Math.random() > 0.4 ? 'triangle' : 'circle';
                    game.particles.push(new Particle(
                        this.x, this.y, '#fff', 3, type
                    ));
                }
                
                if (game.settings.sfx) SFX.jump();
                Haptics.jump();
            }
        }

        class Pillar {
            constructor(lvlIndex, currentGap) {
                this.x = window.innerWidth;
                this.w = CONFIG.PILLAR_WIDTH;
                this.gap = currentGap; // Use the dynamically calculated gap
                
                // Ensure gap is always playable based on screen size
                const maxTop = window.innerHeight - this.gap - 50;
                const minTop = 30;
                this.top = Math.random() * (maxTop - minTop) + minTop;
                
                this.marked = false;
                this.lvl = lvlIndex;
                this.rotation = Math.random() * Math.PI * 2;
                this.innerPattern = Math.floor(Math.random() * 3);
                this.pulse = 0;
                
                // Add visual indicator on mobile for better visibility
                this.hasWarning = game.isMobile && Math.random() > 0.5;
                this.warningAlpha = 1;
            }
            
            update(speed) { 
                this.x -= speed; 
                this.pulse += 0.05;
                this.rotation += 0.005;
                if (this.hasWarning) {
                    this.warningAlpha -= 0.01;
                }
            }
            
            draw(ctx, conf) {
                const hue = (game.frames * 0.5 + this.x * 0.1) % 360;
                const mainColor = `hsl(${hue}, 100%, 60%)`;
                const innerColor = `hsl(${(hue + 60) % 360}, 100%, 70%)`;
                const glowColor = `hsl(${hue}, 100%, 50%)`;
                
                // Add warning glow on mobile for better visibility
                if (this.hasWarning && this.x < window.innerWidth * 0.7 && this.warningAlpha > 0) {
                    ctx.save();
                    ctx.globalAlpha = this.warningAlpha * 0.3;
                    ctx.fillStyle = '#ff003c';
                    ctx.fillRect(this.x - 10, 0, this.w + 20, window.innerHeight);
                    ctx.restore();
                }
                
                ctx.save();
                ctx.translate(this.x + this.w/2, 0);
                
                optimizedShadow.apply(ctx, 30, glowColor);
                ctx.strokeStyle = mainColor;
                ctx.lineWidth = 4;
                ctx.fillStyle = "rgba(0,0,0,0.7)";
                
                const topHeight = this.top + 10;
                ctx.beginPath();
                ctx.moveTo(-this.w/2, -10);
                ctx.lineTo(this.w/2, -10);
                
                const jagCount = 5;
                for (let i = 0; i <= jagCount; i++) {
                    const x = this.w/2 - (i * this.w/jagCount);
                    const y = -10 + (i % 2 === 0 ? 8 : -4);
                    ctx.lineTo(x, y);
                }
                
                ctx.lineTo(-this.w/2, topHeight);
                ctx.lineTo(-this.w/2, -10);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.save();
                ctx.translate(0, topHeight/2);
                ctx.rotate(this.rotation);
                ctx.globalAlpha = 0.4;
                ctx.strokeStyle = innerColor;
                ctx.lineWidth = 1.5;
                optimizedShadow.apply(ctx, 15, innerColor);
                
                if (this.innerPattern === 0) {
                    const size = Math.min(this.w, topHeight) * 0.3;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = Math.cos(angle) * size;
                        const y = Math.sin(angle) * size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                } else if (this.innerPattern === 1) {
                    const size = Math.min(this.w, topHeight) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size * 0.866, size * 0.5);
                    ctx.lineTo(-size * 0.866, size * 0.5);
                    ctx.closePath();
                    ctx.stroke();
                } else {
                    const size = Math.min(this.w, topHeight) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(-size, 0);
                    ctx.lineTo(size, 0);
                    ctx.moveTo(0, -size);
                    ctx.lineTo(0, size);
                    ctx.stroke();
                }
                ctx.restore();
                
                const botY = this.top + this.gap;
                const botHeight = window.innerHeight - botY + 10;
                
                ctx.beginPath();
                ctx.moveTo(-this.w/2, botY);
                ctx.lineTo(this.w/2, botY);
                
                for (let i = 0; i <= jagCount; i++) {
                    const x = this.w/2 - (i * this.w/jagCount);
                    const y = botY + (i % 2 === 0 ? -4 : 8);
                    ctx.lineTo(x, y);
                }
                
                ctx.lineTo(this.w/2, botY + botHeight);
                ctx.lineTo(-this.w/2, botY + botHeight);
                ctx.lineTo(-this.w/2, botY);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.save();
                ctx.translate(0, botY + botHeight/2);
                ctx.rotate(-this.rotation);
                ctx.globalAlpha = 0.4;
                ctx.strokeStyle = innerColor;
                ctx.lineWidth = 1.5;
                
                if (this.innerPattern === 0) {
                    const size = Math.min(this.w, botHeight) * 0.3;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = Math.cos(angle) * size;
                        const y = Math.sin(angle) * size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                } else if (this.innerPattern === 1) {
                    const size = Math.min(this.w, botHeight) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size * 0.866, size * 0.5);
                    ctx.lineTo(-size * 0.866, size * 0.5);
                    ctx.closePath();
                    ctx.stroke();
                } else {
                    const size = Math.min(this.w, botHeight) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(-size, 0);
                    ctx.lineTo(size, 0);
                    ctx.moveTo(0, -size);
                    ctx.lineTo(0, size);
                    ctx.stroke();
                }
                ctx.restore();
                
                ctx.restore();
                optimizedShadow.clear(ctx);
                ctx.globalAlpha = 1.0;
            }
        }

        class Orb {
            constructor(x, y) {
                this.x = x; 
                this.y = y; 
                this.r = 9;
                this.collected = false;
                this.float = Math.random() * Math.PI * 2;
                this.pulse = 0;
                this.rotation = 0;
            }
            
            update(speed) {
                this.x -= speed;
                this.float += 0.1;
                this.pulse += 0.15;
                this.rotation += 0.02;
                this.y += Math.sin(this.float) * 0.8;
            }
            
            draw(ctx) {
                if (this.collected) return;
                
                // Add occasional visual glitch to orbs
                if (Math.random() > 0.97) {
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = '#ff00ff';
                    ctx.fillRect(this.x - this.r, this.y - this.r, this.r * 2, this.r * 2);
                    ctx.restore();
                }
                
                const pulseSize = this.r + Math.sin(this.pulse) * 3;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                optimizedShadow.apply(ctx, 25, '#ffd700');
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
                ctx.stroke();
                
                optimizedShadow.apply(ctx, 30, '#fff');
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.9;
                
                const r = pulseSize * 0.7;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i * 60) * Math.PI / 180;
                    const x = Math.cos(angle) * r;
                    const y = Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
                
                ctx.fillStyle = '#fff';
                optimizedShadow.apply(ctx, 40, '#fff');
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize * 0.2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
        }

        class Particle {
            constructor(x, y, c, speed, type = 'circle') {
                this.x = x; 
                this.y = y; 
                this.c = c;
                this.vx = (Math.random() - 0.5) * speed;
                this.vy = (Math.random() - 0.5) * speed;
                this.life = 1; 
                this.size = Math.random() * 3 + 2;
                this.type = type;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.2;
                this.glow = Math.random() > 0.5;
            }
            
            update() { 
                this.x += this.vx; 
                this.y += this.vy; 
                this.vx *= 0.97;
                this.vy *= 0.97;
                this.life -= 0.03; 
                this.rotation += this.rotationSpeed;
                this.size *= 0.98;
                
                if (game.isMobile) {
                    this.life -= 0.01;
                }
            }
            
            draw(ctx) {
                if (this.life <= 0) return;
                
                if (game.isMobile && this.type !== 'hexagram') {
                    ctx.globalAlpha = this.life * 0.5;
                    ctx.fillStyle = this.c;
                    ctx.fillRect(this.x - this.size, this.y - this.size, 
                                this.size * 2, this.size * 2);
                    ctx.globalAlpha = 1;
                    return;
                }
                
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.c;
                
                if (this.glow && this.life > 0.3) {
                    optimizedShadow.apply(ctx, 20 * this.life, this.c);
                }
                
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                if (this.type === 'hexagram') {
                    const r = this.size * 0.8;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 'triangle') {
                    const r = this.size;
                    ctx.beginPath();
                    ctx.moveTo(0, -r);
                    ctx.lineTo(r * 0.866, r * 0.5);
                    ctx.lineTo(-r * 0.866, r * 0.5);
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 'diamond') {
                    const r = this.size;
                    ctx.beginPath();
                    ctx.moveTo(0, -r);
                    ctx.lineTo(r, 0);
                    ctx.lineTo(0, r);
                    ctx.lineTo(-r, 0);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
        }
        
        class Star {
            constructor() {
                this.x = Math.random() * window.innerWidth;
                this.y = Math.random() * window.innerHeight;
                this.size = Math.random() * 2;
                this.speed = Math.random() * 0.5 + 0.1;
                this.alpha = Math.random() * 0.5 + 0.2;
                this.twinkle = Math.random() * Math.PI * 2;
            }
            update() {
                this.y += this.speed;
                if (this.y > window.innerHeight) {
                    this.y = 0; 
                    this.x = Math.random() * window.innerWidth;
                }
                this.twinkle += 0.05;
                this.alpha = 0.3 + Math.sin(this.twinkle) * 0.2;
            }
            draw(ctx) {
                const conf = game.gameLevels[game.currentLevelIdx];
                ctx.fillStyle = conf ? conf.accent : '#fff';
                ctx.globalAlpha = this.alpha;
                
                if (Math.random() > 0.7) {
                    ctx.fillRect(this.x - this.size/2, this.y, this.size, 1);
                    ctx.fillRect(this.x, this.y - this.size/2, 1, this.size);
                } else {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size/2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1.0;
            }
        }

        let game;
        document.addEventListener('DOMContentLoaded', () => {
            game = new Game();
        });
    </script>
</body>
</html>            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: -1;
        }

        @keyframes bgBreath {
            0% { transform: scale(1); filter: hue-rotate(0deg); }
            100% { transform: scale(1.05); filter: hue-rotate(45deg); }
        }

        .hidden {
            opacity: 0 !important;
            pointer-events: none !important;
            display: none !important;
        }

        /* Neon Buttons */
        .mystic-btn {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--primary);
            color: #fff;
            padding: 15px 50px;
            font-size: 1.2rem;
            font-family: 'Cinzel Decorative', cursive;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 4px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 15px var(--primary), inset 0 0 10px var(--primary);
            margin: 10px;
            min-width: 260px;
            position: relative;
            overflow: hidden;
            text-shadow: 0 0 5px #fff;
            animation: psychedelicBorder 4s infinite linear;
        }

        @keyframes psychedelicBorder {
            0% { border-color: #ff003c; box-shadow: 0 0 15px #ff003c; }
            25% { border-color: #ff00ff; box-shadow: 0 0 15px #ff00ff; }
            50% { border-color: #00ffff; box-shadow: 0 0 15px #00ffff; }
            75% { border-color: #ffd700; box-shadow: 0 0 15px #ffd700; }
            100% { border-color: #ff003c; box-shadow: 0 0 15px #ff003c; }
        }

        .mystic-btn:hover {
            background: #fff;
            color: #000;
            transform: scale(1.05);
            text-shadow: none;
        }

        .mystic-btn:active {
            transform: scale(0.95);
        }

        .title-text {
            font-family: 'Cinzel Decorative', cursive;
            font-size: 5rem;
            color: #fff;
            text-shadow: 0 0 10px var(--primary);
            margin-bottom: 10px;
            letter-spacing: -2px;
            animation: pulseNeon 3s infinite alternate;
        }

        @keyframes pulseNeon {
            0% { text-shadow: 0 0 10px var(--primary), 0 0 20px var(--primary); opacity: 1; }
            100% { text-shadow: 0 0 20px var(--primary), 0 0 40px var(--primary), 0 0 80px var(--primary); opacity: 0.9; }
        }

        .level-indicator {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            font-size: 1.5rem;
            font-family: 'Cinzel Decorative', serif;
            font-weight: 700;
            letter-spacing: 6px;
            color: #fff;
            z-index: 15;
            text-shadow: 0 0 10px #000;
            text-transform: uppercase;
        }

        .score-display {
            position: absolute;
            top: 10%;
            width: 100%;
            text-align: center;
            font-size: 9rem;
            font-family: 'Cinzel Decorative', serif;
            color: rgba(255, 255, 255, 0.1);
            z-index: 5;
            pointer-events: none;
            mix-blend-mode: screen;
            font-weight: 900;
        }

        .progress-bar {
            width: 300px;
            height: 4px;
            background: #222;
            margin: 20px 0;
            position: relative;
            box-shadow: 0 0 10px #000;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width 0.2s ease;
            box-shadow: 0 0 15px var(--primary);
        }

        .instructions {
            position: absolute;
            bottom: 100px;
            width: 100%;
            text-align: center;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 3px;
            z-index: 15;
            font-family: 'Orbitron', sans-serif;
            
            /* FADE OUT ANIMATION */
            animation: fadeOut 5s ease-in-out forwards;
            animation-delay: 2s; /* Wait 2 seconds before fading */
            pointer-events: none;
        }

        @keyframes fadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; visibility: hidden; }
        }

        .pause-btn {
            position: absolute;
            top: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--primary);
            color: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            z-index: 25;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            pointer-events: auto;
            box-shadow: 0 0 10px var(--primary);
            transition: 0.3s;
        }
        
        .pause-btn:hover {
            background: var(--primary);
            color: #000;
            box-shadow: 0 0 20px var(--primary);
        }

        .stats-panel {
            position: absolute;
            top: 30px;
            left: 30px;
            background: rgba(0, 0, 0, 0.7);
            border-left: 3px solid var(--primary);
            padding: 10px 15px;
            font-size: 0.8rem;
            color: #ccc;
            z-index: 25;
            pointer-events: auto;
            font-family: 'Orbitron', monospace;
            text-align: left;
            backdrop-filter: blur(4px);
        }
        
        /* Custom File Upload Styling */
        .file-upload-label {
            display: inline-block;
            margin-top: 20px;
            padding: 10px 20px;
            border: 1px dashed #666;
            color: #888;
            cursor: pointer;
            font-size: 0.8rem;
            transition: 0.3s;
            font-family: 'Orbitron', sans-serif;
        }
        .file-upload-label:hover {
            border-color: var(--primary);
            color: var(--primary);
            box-shadow: 0 0 10px rgba(255, 0, 60, 0.2);
        }

        /* Mobile Controls */
        .mobile-controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 30;
        }

        .mobile-jump-area {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40%;
            pointer-events: auto;
            background: transparent;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .mobile-jump-indicator {
            background: rgba(255, 0, 60, 0.3);
            border: 2px solid rgba(255, 0, 60, 0.7);
            border-radius: 50%;
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 0.8rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            backdrop-filter: blur(5px);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.1); opacity: 0.9; }
            100% { transform: scale(1); opacity: 0.7; }
        }

        /* Responsive Styles */
        @media (max-width: 768px) {
            .title-text { 
                font-size: 3.5rem !important; 
                margin-bottom: 20px;
            }
            .score-display { 
                font-size: 6rem !important; 
                top: 8% !important;
            }
            .level-indicator { 
                font-size: 1.2rem !important; 
                bottom: 70px !important;
                letter-spacing: 4px !important;
            }
            .mystic-btn { 
                padding: 12px 30px !important;
                font-size: 1rem !important;
                min-width: 220px !important;
                margin: 8px !important;
            }
            .instructions {
                bottom: 130px !important;
                font-size: 0.7rem !important;
                letter-spacing: 2px !important;
            }
            .stats-panel {
                top: 15px !important;
                left: 15px !important;
                font-size: 0.7rem !important;
                padding: 8px 12px !important;
            }
            .pause-btn {
                top: 15px !important;
                right: 15px !important;
                width: 45px !important;
                height: 45px !important;
                font-size: 1.2rem !important;
            }
            .progress-bar {
                width: 250px !important;
            }
            #gameOverScreen .title-text {
                font-size: 3rem !important;
            }
            #pauseScreen .title-text {
                font-size: 2.5rem !important;
            }
            #settingsScreen .title-text {
                font-size: 2rem !important;
            }
        }

        @media (max-width: 480px) {
            .title-text { 
                font-size: 2.8rem !important; 
            }
            .score-display { 
                font-size: 5rem !important; 
                top: 6% !important;
            }
            .level-indicator { 
                font-size: 1rem !important; 
                bottom: 60px !important;
            }
            .mystic-btn { 
                min-width: 200px !important;
                padding: 10px 25px !important;
                font-size: 0.9rem !important;
                letter-spacing: 2px !important;
            }
            .instructions {
                font-size: 0.65rem !important;
                letter-spacing: 1.5px !important;
                bottom: 140px !important;
            }
            .progress-bar {
                width: 200px !important;
            }
        }

        @media (orientation: portrait) and (max-height: 700px) {
            .title-text { font-size: 2.5rem !important; }
            .score-display { font-size: 4.5rem !important; }
            .level-indicator { bottom: 50px !important; }
            .instructions { bottom: 100px !important; }
        }

        @media (orientation: landscape) {
            .title-text { font-size: 3rem !important; }
            .score-display { font-size: 4rem !important; top: 5% !important; }
            .level-indicator { bottom: 20px !important; font-size: 1rem !important; }
            .mystic-btn { 
                padding: 8px 20px !important;
                margin: 5px !important;
                min-width: 180px !important;
            }
            .instructions {
                bottom: 70px !important;
                font-size: 0.6rem !important;
            }
            .mobile-jump-area {
                height: 50%;
            }
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .title-text { font-size: 2.2rem !important; }
            .score-display { font-size: 3rem !important; }
            .mystic-btn { 
                padding: 6px 15px !important;
                font-size: 0.8rem !important;
                min-width: 150px !important;
            }
        }

        /* Safe area padding for notched phones */
        @supports (padding: max(0px)) {
            .ui-layer {
                padding-left: max(20px, env(safe-area-inset-left));
                padding-right: max(20px, env(safe-area-inset-right));
                padding-top: max(20px, env(safe-area-inset-top));
                padding-bottom: max(20px, env(safe-area-inset-bottom));
            }
        }

        .loader {
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid var(--primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="scanlines"></div>
        <div class="vignette"></div>
        
        <div id="scoreUi" class="score-display">0</div>
        <div id="levelUi" class="level-indicator">INITIATION</div>
        
        <!-- Mobile Controls -->
        <div id="mobileControls" class="mobile-controls hidden">
            <div class="mobile-jump-area">
                <div class="mobile-jump-indicator">
                    TAP
                </div>
            </div>
        </div>
        
        <!-- Start Screen with NEW Background Image -->
        <div id="startScreen" class="ui-layer" style="background-image: url('https://lh3.googleusercontent.com/d/1BXrXXd9TKSqCFNwvS-cJpNORbyvP6fkR=s0');">
            <h1 class="title-text">Sex Magick</h1>
            <p style="letter-spacing: 8px; color: #ff003c; margin-bottom: 40px; font-size: 1.1rem; text-shadow: 0 0 10px #ff003c; font-family: 'Cinzel Decorative', cursive;">Do Your Will Foo</p>
            
            <div id="loadingMsg">
                <div class="loader"></div>
                <p id="loadingText" style="letter-spacing: 4px; font-size: 0.9rem; margin-top: 15px; font-family: 'Cinzel Decorative';">CHARGING SIGIL...</p>
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill"></div>
                </div>
            </div>

            <div id="menuButtons" class="hidden">
                <button id="startBtn" class="mystic-btn">INVOKE</button>
                <button id="settingsBtn" class="mystic-btn">RITES</button>
                
                <label for="fileUpload" class="file-upload-label">
                    [ OPTIONAL: LOAD LOCAL MP3 ]
                </label>
                <input type="file" id="fileUpload" accept="audio/*" style="display:none;">
                <p id="trackName" style="margin-top: 5px; font-size: 0.6rem; color: #555;">SOURCE: GITHUB CDN</p>
            </div>
        </div>

        <div id="gameOverScreen" class="ui-layer hidden" style="background: rgba(0,0,0,0.85);">
            <h1 class="title-text" style="color: #ff003c; font-size: 4rem;">ABORTED</h1>
            <p style="font-size: 1.2rem; letter-spacing: 4px; margin-bottom: 20px; font-family: 'Cinzel Decorative';">RITUAL FAILED</p>
            <p class="text-xl mb-6 text-gray-300">WILL: <span id="finalScore" style="color: #fff; font-weight:bold; text-shadow: 0 0 10px #fff;">0</span></p>
            <p id="highScoreMsg" style="color: #ffd700; margin-bottom: 30px; font-size: 1rem; letter-spacing: 2px;"></p>
            <button id="restartBtn" class="mystic-btn">REINCARNATE</button>
        </div>

        <div id="pauseScreen" class="ui-layer hidden">
            <h1 class="title-text" style="font-size: 3.5rem; color: #ffd700;">MEDITATION</h1>
            <button id="resumeBtn" class="mystic-btn">RESUME</button>
            <button id="menuBtn" class="mystic-btn">ABORT</button>
        </div>

        <div id="settingsScreen" class="ui-layer hidden" style="background: rgba(0,0,0,0.9);">
            <h1 class="title-text" style="font-size: 2.5rem;">SACRED RITES</h1>
            <div style="width: 320px; margin: 20px 0; background: rgba(20,20,20,0.8); padding: 20px; border: 1px solid var(--primary);">
                <div style="display: flex; justify-content: space-between; margin: 15px 0; border-bottom: 1px solid #444; padding-bottom: 10px;">
                    <span>CHANT (MUSIC)</span>
                    <input type="checkbox" id="musicToggle" checked style="accent-color: var(--primary);">
                </div>
                <div style="display: flex; justify-content: space-between; margin: 15px 0; border-bottom: 1px solid #444; padding-bottom: 10px;">
                    <span>RESONANCE (SFX)</span>
                    <input type="checkbox" id="sfxToggle" checked style="accent-color: var(--primary);">
                </div>
                <div style="display: flex; justify-content: space-between; margin: 15px 0;">
                    <span>KUNDALINI (VIBE)</span>
                    <input type="checkbox" id="vibrationToggle" checked style="accent-color: var(--primary);">
                </div>
            </div>
            <button id="backBtn" class="mystic-btn">RETURN</button>
        </div>

        <button id="pauseBtn" class="pause-btn hidden">||</button>
        
        <div id="statsPanel" class="stats-panel">
            <div style="color: var(--primary); font-weight: bold; margin-bottom: 5px;">:: GNOSIS ::</div>
            FPS: <span id="fpsCounter" style="color: #fff;">0</span><br>
            AUDIO: <span id="audioStatus" style="color: #fff;">STANDBY</span>
        </div>

        <div id="instructions" class="instructions hidden">
            [ TAP / SPACE TO ASCEND ]
        </div>
    </div>

    <script>
        // High-Speed CDN Prefix
        const CDN_PREFIX = "https://cdn.jsdelivr.net/gh/bookthief666/93-protocol-game-assets-@662f3d608769e9e945295ac00d668447d974dc5c/";

        const CONFIG = {
            DEBUG: false,
            MENU_MUSIC: CDN_PREFIX + "iamerror%20-%20The%20Zelda%20Song%20(Hyr00l).mp3",
            GAME_PLAYLIST: [
                CDN_PREFIX + "iamerror%20-%20Hyr00l%20Rough.mp4",
                CDN_PREFIX + "bookthief%F0%9F%A5%80%20-%20booothief-%20All%20gay%F0%9F%98%87%202024-07-10%2001_11%20(1).m4a",
                CDN_PREFIX + "Vae!%20Puto%20Deus%20Fio!%20(3).mp3",
                CDN_PREFIX + "IAMERROR%20-%20The%20Iceclops%20Cometh.mp3",
                CDN_PREFIX + "Forest%20of%20Fellatio%20%5BTTn3kjGwXi0%5D.mp3",
                CDN_PREFIX + "LEX_LFL_80_wurli_loop_ate_bit_Cm.wav",
                CDN_PREFIX + "iamerror%20-%20The%20Zelda%20Song%20(Hyr00l).mp3"
            ],
            BASE_URL: "https://lh3.googleusercontent.com/d/",
            IMG_SUFFIX: "=s0",
            
            // EASIER SETTINGS:
            INITIAL_GAME_SPEED: 2.5,
            SPEED_INCREASE_PER_LEVEL: 0.15,
            PILLAR_SPAWN_RATE: 120,
            PILLAR_WIDTH: 45,
            PILLAR_GAP: 250, // Starting gap (larger for easier gameplay)
            PILLAR_GAP_DECREASE_PER_5_LEVELS: 8, // Gets 8px smaller every 5 levels
            MIN_PILLAR_GAP: 180, // Minimum gap size
            ORB_SPAWN_CHANCE: 0.5,
            PLAYER_JUMP_FORCE: -6.5,
            GRAVITY: 0.20,
            
            // Responsive settings
            PLAYER_RADIUS: 12,
            HITBOX_OFFSET: 8,
            MOBILE_CONTROL_DEADZONE: 50,
        };

        const originalLevels = [
            { name: "MALKUTH", id: "1jI7bl3hsVOuzYf6u35L4bhHq5JUiBDa1" },
            { name: "YESOD", id: "1tHgxNvDO5md4z24hS81eTa9uva25mtr5" },
            { name: "HOD", id: "1Mtp6cP6lwGbPRhLWjQKKDijrLX53K4UR" },
            { name: "NETZACH", id: "1y1i5lxL1jVp37bIz1mtJh4-Puce-E5k0" },
            { name: "TIPHARETH", id: "12png0vOPyJC1Ab4Vffcw2R_K-yRw1sqj" },
            { name: "GEBURAH", id: "1le2Hox1ORxhL28fv7WujO0410vM6jUEJ" },
            { name: "CHESED", id: "1Gsq1xSx9ivfVEq6W2nCMrO-dOIMrSYrW" },
            { name: "DA'ATH", id: "1o601hrLi5RpuGL_kiVEoPXxXk2SCbM2z" },
            { name: "BINAH", id: "1iSYJfPsaYjA1rmRTsujLcn1Do-lBydF7" },
            { name: "CHOKMAH", id: "1PvOC62nv5HdsE1cuCF8RENY9Z8HTabn7" },
            { name: "KETHER", id: "1Ym_eyrXJEQUBA7Lg_2oUc6dQ-gy9yfGs" }
        ];

        const newImageIDs = [
            "1pJ5CUGyKXgkSgEREkKos1Kch5FmfUyxE", "1spT4HpO_4q9joE4x6bLjZQRlFTS9j-ie", "1YGzyjcjiCoPCLbYjJEiqT8USUhe4S6hM", "1ELjoJU7KDC88nUk_Vs57OKUG9oLl5E8N",
            "1faa2c3QFWhZ8UgvyZ_ZrlnyFsnsKRclm", "10W5oYkoqB9LC3YjvB_aozR0kG3hWaHka", "1l9Jdm0EQh8sgWh1W0wsXQCzrQM19Bfm9", "1BrHTF2dvfbRkyYfXAbPUiujwE1AJskY4",
            "1KqV8IYF7KDbmgHS3ph6eRQKl4uAAFG_u", "1sZ02UH_vb1xLaOvyETqptc5FuvOtVKd4", "1hLKOGYXCBemcIKt8OLEX4dHTn6bd88cr", "1g_DQeG6qldMBxHzZ82MOVoxk9APwb4NO",
            "1-SIvE5EZyUd7FKXJ7eyB4JCrtOpQoF18", "1S4y4YSCjxSb-b_U1BfMw_0PhabJ-METm", "1OL-kWl-TJNcZFPcsCAtynW2NWp-YYjGd", "1ApPgou40N2Q6GlNKNuyoQ2Gk5DqAfmw_",
            "1OeH1GMu2rDcwzdtWFZSB1WWe0OjkmxV0", "12Z92v9Mu9yNOnDTtK-bjMRZ8_2BAW2eW", "1Erf3DKxZpfbG57oGcUCjuHIhajsweLZz", "1qK22CJhJ1XgElL156uOQxYrucaRG16p0",
            "1euwdAWg-xQw7isR-JAiZ-krXQXOS8pi0", "1A3hT3mJibINtsr8CVxTmp71QsYgPB2JZ", "1QUVr-RK2kP7IIAuy0wX3pOZRQuyr-o-e", "1eF02YMyYBcgx7Ga20pXgoltzWXPYznfD",
            "1zx1vrrbuSA4xCFKXAHgXbkG1rX8PUPel", "1ds1iqXf90gy9PUFs80t4QOxamkJj0u1I", "14-t6dPPv5MeXe7LWPIp7Tjc8x4w5Vj2d", "1pUtIizMzVhjzB46dhah5mgz6Tr-vaSLO",
            "1ZOEkUW8q2s5zerS7BubYJU69RHk7_Zlo", "15ZHj0fLYu-4rEQy43BMJKDgXnnQ5FeyP", "1ZzgVT0O6XQzW3DUP4i1aoKd_DD5wV5LZ", "1rZHZM0bR_j6uiYZLS82J0BkbIfEUoXvY",
            "1CNrQ_EeMXQgHJGXxe7EHysQi_A0A9UE7", "1ubCqIg7ETOIsHGfBjQfVsRzjlZIpBP6E", "1pojzjR-uiQ0oTHRJxXXCW_w0hlJUCqyb", "1SnclBlH6sflhaTWzFhbcNedzNeh25-BV",
            "1thfc-9DnM4GhCi0zTbcX4MH-yaQEpomX", "1BXrXXd9TKSqCFNwvS-cJpNORbyvP6fkR", "1D1bOksatIt6Jw6Zq8Sbmhbq_GC_2EQHh", "1eP_Xnk80YnL3w3Q69wQmVo9_F0OaA3Wo",
            "1ARDOipcr0lB1GYf3gmhqlHXlpC23Q2JE", "1io39jfggXQl-OyvSFGIpgOtoIzHbml3M", "1o0rJmx3vEKITMx1ixP5iruOX2ujOT6VO", "1Irw61utgSGdip21OgTcYqz56LpWWS9fb",
            "19V2ObVoQn9R9bt1ZgMNEBJokaAjYdX_9", "1WWvLnkkPBN7Q0ZsGi16FL1anhPlti3Qd", "1HoYqC0SLc3nrSDnoW9KJ2-z8AnRWIz5M", "1oS0J3F-zh5H48-Qs5Mrm10dPR993kF-b",
            "1bRwsBEuZiAIZW_5f3WOZVI6-KVnCEslk", "1GLza2_RmR4c_KD_KGxbXPOoCAw9SITKl", "1uWFSChozQmHEnuJwXqiPNApXuAwPAzKS", "1t2hNBEudzIo19kuP8ksPY_cNetDdTd8P",
            "1KhMBL7a3NSggVerbyy53fQ-dLq11adwj", "1wgxalTR68YM7oIku8JYZYKtG50atEnG_", "1BceMgnHgVn9U_7EYnXQu9HDwEQY1UBa_", "14_iwYDQjp34-R_iby8QadKnI9m3zVnOu",
            "1cZ_ci9J80jnqCAdag8SQofYZw1dfsX3C", "15z3bGrCqUy8SQjX1dO5C1vlN3y4-soai", "10xAFw98B39Ou0SSeB4eWyoY2D_OLLPgz", "1CexZQw11p33u1-YA7JhPAkGV6NBCgd6e",
            "16t1EdHfHRpb7GmqNAfo2iKKm57qLfbKn", "12wQOhUztVCVEFV21fPDq-JXGi5zxdkeQ", "1-0u9JUH0oUHD1--5iaySxRpO_PuyxkH6", "1wnITY3i6XxOr1b3l6P0cT10LkEHQauO5"
        ].filter((value, index, self) => self.indexOf(value) === index);

        const esotericNames = [
            "KUNDALINI", "HIEROS GAMOS", "SACRED UNION", "RED TINCTURE", "WHITE GLUTEN", 
            "CUP OF BABALON", "BLOOD OF SAINTS", "CITY OF PYRAMIDS", "NIGHT OF PAN", 
            "HADIT'S FLAME", "NUIT'S EMBRACE", "LAW OF THELEMA", "LOVE UNDER WILL", 
            "GREAT WORK", "STONE OF WISE", "ELIXIR OF LIFE", "RED LION", "WHITE EAGLE",
            "ABRAHADABRA", "LASHTAL", "KA", "BA", "KHU", "SCARLET WOMAN", "THE BEAST",
            "AEON OF HORUS", "93", "AGAPE", "THELEMA", "VIA OVUM", "SPERMATOZOON",
            "HOMUNCULUS", "DIVINE EROS", "TANTRA", "YONI", "LINGAM", "O.T.O.", "A.'.A.'.",
            "STAR SAPPHIRE", "MASS OF PHOENIX", "LIBER AL", "RESH", "SAMEKH", "TZADDI"
        ];

        let MASTER_POOL = [...originalLevels];
        
        const palette = ["#ff003c", "#ff00ff", "#9d00ff", "#00f0ff", "#00ff9d", "#d4ff00", "#ff8800"];

        newImageIDs.forEach((id, index) => {
            const nameIndex = index % esotericNames.length;
            MASTER_POOL.push({
                name: esotericNames[nameIndex],
                id: id,
                color: "#000",
                accent: palette[index % palette.length],
                img: null,
                loaded: false
            });
        });

        const GameState = {
            START: 'start',
            LOADING: 'loading',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAME_OVER: 'gameover',
            SETTINGS: 'settings'
        };

        // Detect mobile device
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Mobile-optimized shadow rendering
        const optimizedShadow = {
            apply(ctx, blur, color) {
                if (isMobile) {
                    ctx.shadowBlur = Math.min(blur, 10);
                    ctx.shadowColor = color;
                } else {
                    ctx.shadowBlur = blur;
                    ctx.shadowColor = color;
                }
            },
            clear(ctx) {
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }
        };

        // Glitch Effect System (Lightweight)
        const GlitchFX = {
            active: false,
            duration: 0,
            intensity: 1,
            type: 'rgb',
            
            // Lightweight RGB split effect
            rgbSplit(ctx, intensity) {
                const offset = Math.floor(Math.random() * 3 * intensity);
                const rOffset = Math.random() > 0.5 ? offset : -offset;
                const gOffset = Math.random() > 0.5 ? offset : -offset;
                const bOffset = Math.random() > 0.5 ? offset : -offset;
                
                // Only apply on some frames to save performance
                if (Math.random() > 0.3) return null;
                
                return {
                    rOffset, gOffset, bOffset,
                    draw: function(ctx, width, height) {
                        // Copy current canvas
                        const imageData = ctx.getImageData(0, 0, width, height);
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = width;
                        tempCanvas.height = height;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.putImageData(imageData, 0, 0);
                        
                        // Draw with RGB offsets
                        ctx.save();
                        ctx.globalCompositeOperation = 'screen';
                        
                        // Red channel
                        ctx.globalAlpha = 0.8;
                        ctx.drawImage(tempCanvas, rOffset, 0);
                        
                        // Green channel
                        ctx.globalAlpha = 0.8;
                        ctx.drawImage(tempCanvas, 0, gOffset);
                        
                        // Blue channel
                        ctx.globalAlpha = 0.8;
                        ctx.drawImage(tempCanvas, bOffset, bOffset);
                        
                        ctx.restore();
                    }
                };
            },
            
            // Digital static effect (very lightweight)
            staticEffect(ctx, intensity) {
                // Draw random pixels/rectangles
                ctx.save();
                ctx.globalAlpha = 0.1 * intensity;
                
                for (let i = 0; i < 5; i++) { // Only 5 per frame
                    const x = Math.random() * ctx.canvas.width;
                    const y = Math.random() * ctx.canvas.height;
                    const size = Math.random() * 10 * intensity + 2;
                    
                    ctx.fillStyle = Math.random() > 0.5 ? '#ff003c' : '#00ffff';
                    ctx.fillRect(x, y, size, 1);
                    
                    if (Math.random() > 0.7) {
                        ctx.fillStyle = Math.random() > 0.5 ? '#ff00ff' : '#00ff9d';
                        ctx.fillRect(x, y + 2, 1, size);
                    }
                }
                ctx.restore();
            },
            
            // Scanline distortion (lightweight)
            scanlineDistort(ctx, intensity) {
                if (Math.random() > 0.5) return;
                
                ctx.save();
                ctx.globalAlpha = 0.05 * intensity;
                ctx.fillStyle = '#fff';
                
                const lineCount = Math.floor(3 * intensity);
                for (let i = 0; i < lineCount; i++) {
                    const y = Math.floor(Math.random() * ctx.canvas.height);
                    const height = Math.random() * 2 + 1;
                    const wave = Math.sin(Date.now() * 0.01 + i) * 10 * intensity;
                    
                    ctx.fillRect(0, y, ctx.canvas.width, height);
                    ctx.fillRect(wave, y + 5, ctx.canvas.width, 1);
                }
                ctx.restore();
            },
            
            // Block displacement (very cheap)
            blockDisplace(ctx, intensity) {
                if (Math.random() > 0.7) return;
                
                ctx.save();
                ctx.globalAlpha = 0.3 * intensity;
                
                // Draw a few displaced blocks
                for (let i = 0; i < 2; i++) {
                    const x = Math.random() * ctx.canvas.width;
                    const y = Math.random() * ctx.canvas.height;
                    const width = Math.random() * 50 * intensity + 20;
                    const height = Math.random() * 50 * intensity + 20;
                    const offsetX = (Math.random() - 0.5) * 10 * intensity;
                    const offsetY = (Math.random() - 0.5) * 10 * intensity;
                    
                    ctx.fillStyle = Math.random() > 0.5 ? '#ff003c' : '#00ffff';
                    ctx.fillRect(x + offsetX, y + offsetY, width, height);
                }
                ctx.restore();
            },
            
            // Apply all glitch effects (called each frame)
            apply(ctx, currentTime) {
                if (!this.active || this.duration <= 0) return;
                
                const progress = this.duration / 100; // Normalized progress
                this.intensity = Math.min(1, progress * 2);
                
                // Apply different effects based on random chance
                if (Math.random() > 0.5) this.staticEffect(ctx, this.intensity);
                if (Math.random() > 0.6) this.scanlineDistort(ctx, this.intensity);
                if (Math.random() > 0.7) this.blockDisplace(ctx, this.intensity);
                
                // RGB split only occasionally as it's more expensive
                if (Math.random() > 0.8) {
                    const rgbEffect = this.rgbSplit(ctx, this.intensity);
                    if (rgbEffect) rgbEffect.draw(ctx, ctx.canvas.width, ctx.canvas.height);
                }
                
                this.duration -= 16; // Decrease by ~1 frame at 60fps
                if (this.duration <= 0) {
                    this.active = false;
                    this.intensity = 1;
                }
            },
            
            // Trigger a glitch effect
            trigger(duration = 100, type = 'all') {
                this.active = true;
                this.duration = duration;
                this.type = type;
                this.intensity = 1;
            }
        };

        const SFX = {
            audioContext: null,
            init() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
            },
            playTone(freq, type, duration, vol, detune = 0) {
                if (!game?.settings?.sfx) return;
                if (!this.audioContext) this.init();
                if (this.audioContext.state === 'suspended') this.audioContext.resume();
                
                try {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    
                    osc.type = type;
                    osc.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                    osc.detune.setValueAtTime(detune, this.audioContext.currentTime);
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    gain.gain.setValueAtTime(vol, this.audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                    
                    osc.start();
                    osc.stop(this.audioContext.currentTime + duration);
                } catch(e){}
            },
            jump() { 
                this.playTone(400, 'square', 0.08, 0.1);
                this.playTone(600, 'sine', 0.05, 0.05, 100);
            },
            collect() { 
                this.playTone(800, 'sine', 0.2, 0.1);
                this.playTone(1200, 'triangle', 0.1, 0.05, 50);
            },
            crash() { 
                this.playTone(100, 'sawtooth', 0.5, 0.3);
                this.playTone(80, 'square', 0.3, 0.2, -100);
            },
            levelUp() { 
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.5);
                osc.connect(gain);
                gain.connect(this.audioContext.destination);
                gain.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                osc.start();
                osc.stop(this.audioContext.currentTime + 0.5);
            }
        };

        // Haptic Feedback System
        const Haptics = {
            jump() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([15]);
                }
            },
            collect() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([30, 20, 30]);
                }
            },
            crash() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([150, 30, 80, 30, 40]);
                }
            },
            levelUp() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([80, 20, 80, 20, 80]);
                }
            }
        };

        const AudioSys = {
            bgm: null,
            localBlobUrl: null,
            currentMode: 'none', 
            retryCount: 0,
            
            setStatus(msg) {
                const el = document.getElementById('audioStatus');
                if (el) {
                    el.textContent = msg;
                    el.style.color = '#fff';
                    setTimeout(() => el.style.color = 'var(--primary)', 200);
                }
            },

            init() {
                this.setupAudioElement(CONFIG.MENU_MUSIC);
                this.currentMode = 'menu';
                this.setStatus("MENU AUDIO RDY");
            },

            setupAudioElement(src) {
                if (this.bgm) {
                    this.bgm.pause();
                    this.bgm.src = "";
                    this.bgm.load();
                }
                this.bgm = new Audio();
                this.bgm.src = src;
                this.bgm.loop = true;
                this.bgm.volume = 0.8;
                this.bgm.preload = "auto";
                
                this.bgm.onwaiting = () => this.setStatus("BUFFERING...");
                this.bgm.onplaying = () => {
                    this.setStatus("PLAYING");
                    this.retryCount = 0;
                };
                
                this.bgm.onerror = (e) => {
                    console.warn("Audio error:", e);
                    this.setStatus("LOAD ERROR");
                };
            },

            loadLocalFile(file) {
                if (this.localBlobUrl) URL.revokeObjectURL(this.localBlobUrl);
                this.localBlobUrl = URL.createObjectURL(file);
                this.setupAudioElement(this.localBlobUrl);
                this.setStatus("FILE LOADED");
            },
            
            switchToGameMusic() {
                if (this.localBlobUrl) return; 
                const randomIndex = Math.floor(Math.random() * CONFIG.GAME_PLAYLIST.length);
                const track = CONFIG.GAME_PLAYLIST[randomIndex];
                this.currentMode = 'game';
                this.setStatus("LOADING TRK " + (randomIndex + 1));
                this.setupAudioElement(track);
                this.play();
            },

            switchToMenuMusic() {
                if (this.localBlobUrl) return;
                this.currentMode = 'menu';
                this.setStatus("LOADING MENU");
                this.setupAudioElement(CONFIG.MENU_MUSIC);
            },
            
            play() {
                if (!this.bgm) return;
                const playPromise = this.bgm.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => this.setStatus("PLAYING")).catch(error => {
                        console.warn("Play failed:", error);
                        this.setStatus("AUTOPLAY BLOCK");
                    });
                }
            },
            
            pause() { if (this.bgm) { this.bgm.pause(); this.setStatus("PAUSED"); } },
            resume() { if (this.bgm && this.bgm.paused) { this.bgm.play(); this.setStatus("RESUMED"); } },
            stop() { if (this.bgm) { this.bgm.pause(); this.bgm.currentTime = 0; this.setStatus("STOPPED"); } }
        };

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.root = document.documentElement;
                
                this.state = GameState.START;
                this.currentLevelIdx = 0;
                this.frames = 0;
                this.score = 0;
                this.highScore = localStorage.getItem('93protocol_highscore') || 0;
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED;
                this.shake = 0;
                this.lastFrameTime = 0;
                this.fps = 0;
                
                // Responsive properties
                this.isMobile = isMobile;
                this.aspectRatio = 16/9;
                this.baseWidth = 800;
                this.baseHeight = 450;
                this.scaleFactor = 1;
                
                // Glitch effect properties
                this.glitchEffect = false;
                this.glitchTimer = 0;
                this.glitchDuration = 300;
                
                // Hyperspace tunnel properties
                this.tunnelOffset = 0;
                this.tunnelSpeed = 0.5;
                
                // Screen flash effect
                this.screenFlash = null;
                
                this.backgroundParticles = [];
                
                this.player = null;
                this.particles = [];
                this.stars = [];
                this.obstacles = [];
                this.collectibles = [];
                this.gameLevels = []; 
                
                this.settings = { music: true, sfx: true, vibration: true };
                
                this.loadSettings();
                this.initEventListeners();
                this.resizeCanvas();
                this.preloadAllImages();
                this.createBackgroundParticles();
                
                AudioSys.init();
                SFX.init();
            }
            
            createBackgroundParticles() {
                for (let i = 0; i < 60; i++) {
                    this.backgroundParticles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        z: Math.random() * 2 + 0.5,
                        size: Math.random() * 2 + 1,
                        speed: Math.random() * 0.5 + 0.1,
                        color: palette[Math.floor(Math.random() * palette.length)],
                        opacity: Math.random() * 0.4 + 0.1,
                        shape: Math.floor(Math.random() * 3)
                    });
                }
            }
            
            // Glitch effect methods
            triggerOrbGlitch() {
                // Quick, intense glitch for orb collection
                GlitchFX.trigger(80, 'orb');
                
                // Also add screen flash
                this.screenFlash = {
                    active: true,
                    duration: 10,
                    color: '#ffd700',
                    intensity: 0.3
                };
            }
            
            triggerLevelUpGlitch() {
                // Longer, more intense glitch for level up
                GlitchFX.trigger(150, 'level');
                
                // Screen flash
                this.screenFlash = {
                    active: true,
                    duration: 20,
                    color: this.gameLevels[this.currentLevelIdx]?.accent || '#ff003c',
                    intensity: 0.4
                };
            }
            
            triggerDeathGlitch() {
                // Long, intense glitch for death
                GlitchFX.trigger(200, 'death');
                
                // Red screen flash
                this.screenFlash = {
                    active: true,
                    duration: 30,
                    color: '#ff003c',
                    intensity: 0.6
                };
            }
            
            applyScreenFlash() {
                if (!this.screenFlash || !this.screenFlash.active) return;
                
                this.ctx.save();
                this.ctx.fillStyle = this.screenFlash.color;
                this.ctx.globalAlpha = this.screenFlash.intensity * (this.screenFlash.duration / 30);
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.restore();
                
                this.screenFlash.duration--;
                if (this.screenFlash.duration <= 0) {
                    this.screenFlash.active = false;
                }
            }
            
            initEventListeners() {
                document.getElementById('fileUpload').addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) AudioSys.loadLocalFile(file);
                });

                window.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && this.state === GameState.PLAYING) this.playerJump();
                    else if (e.code === 'Escape') this.togglePause();
                });
                
                window.addEventListener('mousedown', (e) => {
                    if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'LABEL' && this.state === GameState.PLAYING) this.playerJump();
                });
                
                window.addEventListener('touchstart', (e) => {
                    if (this.state === GameState.PLAYING) {
                        e.preventDefault();
                        const touchY = e.touches[0].clientY;
                        // Check if touch is in the bottom 40% of screen (jump area)
                        if (touchY > window.innerHeight * 0.6) {
                            this.playerJump();
                        }
                    }
                }, { passive: false });
                
                document.getElementById('startBtn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (this.settings.music) AudioSys.switchToGameMusic();
                    this.startGame();
                });
                
                document.getElementById('restartBtn').addEventListener('click', (e) => {
                     e.stopPropagation();
                     if (this.settings.music) AudioSys.switchToGameMusic();
                     this.restartGame();
                });
                
                document.getElementById('pauseBtn').addEventListener('click', (e) => { e.stopPropagation(); this.togglePause(); });
                document.getElementById('resumeBtn').addEventListener('click', (e) => { e.stopPropagation(); this.togglePause(); });
                document.getElementById('menuBtn').addEventListener('click', (e) => { e.stopPropagation(); this.returnToMenu(); });
                document.getElementById('settingsBtn').addEventListener('click', (e) => { e.stopPropagation(); this.showSettings(); });
                document.getElementById('backBtn').addEventListener('click', (e) => { e.stopPropagation(); this.hideSettings(); });
                
                document.getElementById('musicToggle').addEventListener('change', (e) => {
                    this.settings.music = e.target.checked;
                    this.saveSettings();
                    if (!this.settings.music) AudioSys.stop();
                    else if (this.state === GameState.PLAYING) AudioSys.play();
                });
                
                document.getElementById('sfxToggle').addEventListener('change', (e) => {
                    this.settings.sfx = e.target.checked;
                    this.saveSettings();
                });
                
                document.getElementById('vibrationToggle').addEventListener('change', (e) => {
                    this.settings.vibration = e.target.checked;
                    this.saveSettings();
                });
                
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            loadSettings() {
                const saved = localStorage.getItem('93protocol_settings');
                if (saved) this.settings = { ...this.settings, ...JSON.parse(saved) };
                document.getElementById('musicToggle').checked = this.settings.music;
                document.getElementById('sfxToggle').checked = this.settings.sfx;
                document.getElementById('vibrationToggle').checked = this.settings.vibration;
            }
            
            saveSettings() { localStorage.setItem('93protocol_settings', JSON.stringify(this.settings)); }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.calculateScaleFactor();
                this.adjustForScreenSize();
            }
            
            calculateScaleFactor() {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const targetRatio = 16/9;
                const currentRatio = width/height;
                
                if (currentRatio > targetRatio) {
                    this.scaleFactor = height / this.baseHeight;
                } else {
                    this.scaleFactor = width / this.baseWidth;
                }
                
                this.scaleFactor = Math.max(0.6, Math.min(this.scaleFactor, 1.5));
            }
            
            adjustForScreenSize() {
                const screenHeight = this.canvas.height;
                
                // Adjust pillar gap based on screen height
                let baseGap = CONFIG.PILLAR_GAP;
                
                // Smaller screens get slightly larger gaps for easier gameplay
                if (screenHeight < 600) {
                    baseGap = Math.min(270, baseGap * 1.08);
                } else if (screenHeight > 800) {
                    baseGap = Math.max(240, baseGap * 0.95);
                }
                
                // Store the base gap for this screen size
                this.currentBaseGap = baseGap;
            }
            
            preloadAllImages() {
                const progressFill = document.getElementById('progressFill');
                const loadingText = document.getElementById('loadingText');
                let loadedCount = 0;
                
                const failsafe = setTimeout(() => {
                    if (loadedCount < MASTER_POOL.length) {
                        console.warn("Loading timed out. Forcing start.");
                        this.finishLoading();
                    }
                }, 5000);
                
                MASTER_POOL.forEach(lvl => {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.onload = () => {
                        lvl.img = img;
                        lvl.loaded = true;
                        loadedCount++;
                        const percent = Math.floor((loadedCount / MASTER_POOL.length) * 100);
                        progressFill.style.width = `${percent}%`;
                        loadingText.innerText = `CHARGING SIGIL... ${loadedCount}/${MASTER_POOL.length}`;
                        if (loadedCount >= MASTER_POOL.length) {
                            clearTimeout(failsafe);
                            this.finishLoading();
                        }
                    };
                    img.onerror = () => {
                        console.warn(`Failed to load image: ${lvl.id}`);
                        loadedCount++;
                        if (loadedCount >= MASTER_POOL.length) {
                            clearTimeout(failsafe);
                            this.finishLoading();
                        }
                    };
                    img.src = CONFIG.BASE_URL + lvl.id + CONFIG.IMG_SUFFIX;
                });
            }
            
            finishLoading() {
                setTimeout(() => {
                    document.getElementById('loadingMsg').classList.add('hidden');
                    document.getElementById('menuButtons').classList.remove('hidden');
                }, 500);
            }
            
            prepareLevels() {
                let shuffled = [...MASTER_POOL];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                this.gameLevels = shuffled.map((lvl, index) => {
                    return { ...lvl, threshold: index * 5 };
                });
            }

            startGame() {
                this.prepareLevels();
                this.state = GameState.PLAYING;
                document.getElementById('startScreen').classList.add('hidden');
                document.getElementById('scoreUi').classList.remove('hidden');
                document.getElementById('pauseBtn').classList.remove('hidden');
                document.getElementById('instructions').classList.remove('hidden');
                
                // Show mobile controls on mobile devices
                if (this.isMobile) {
                    document.getElementById('mobileControls').classList.remove('hidden');
                    // Hide mobile controls after 5 seconds
                    setTimeout(() => {
                        document.getElementById('mobileControls').classList.add('hidden');
                    }, 5000);
                }
                
                if (CONFIG.DEBUG) document.getElementById('statsPanel').classList.remove('hidden');
                this.initGame();
                this.gameLoop();
            }
            
            initGame() {
                this.player = new Player();
                this.obstacles = [];
                this.collectibles = [];
                this.particles = [];
                this.stars = [];
                for (let i = 0; i < 40; i++) this.stars.push(new Star());
                this.score = 0;
                this.currentLevelIdx = 0;
                this.frames = 0;
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED;
                this.shake = 0;
                this.tunnelOffset = 0;
                document.getElementById('scoreUi').innerText = "0";
                this.applyLevel();
            }
            
            applyLevel() {
                if (this.currentLevelIdx >= this.gameLevels.length) return;
                const l = this.gameLevels[this.currentLevelIdx];
                document.getElementById('levelUi').innerText = l.name;
                document.getElementById('levelUi').style.color = l.accent;
                document.getElementById('levelUi').style.textShadow = `0 0 15px ${l.accent}`;
                this.root.style.setProperty('--primary', l.accent);
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED + (this.currentLevelIdx * CONFIG.SPEED_INCREASE_PER_LEVEL);
                
                if (this.currentLevelIdx > 0) {
                    this.triggerGlitchEffect();
                    Haptics.levelUp();
                    if (this.settings.sfx) SFX.levelUp();
                }
            }
            
            triggerGlitchEffect() {
                this.glitchEffect = true;
                this.glitchTimer = this.glitchDuration;
            }
            
            applyGlitchEffect() {
                if (!this.glitchEffect) return;
                
                const ctx = this.ctx;
                const intensity = this.glitchTimer / this.glitchDuration;
                
                if (Math.random() > 0.7) {
                    const shiftX = Math.floor(Math.random() * 10 * intensity) - 5;
                    const shiftY = Math.floor(Math.random() * 10 * intensity) - 5;
                    
                    ctx.save();
                    ctx.translate(shiftX, shiftY);
                    ctx.restore();
                }
                
                if (Math.random() > 0.8) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fillRect(0, Math.floor(Math.random() * this.canvas.height), this.canvas.width, 1);
                }
                
                this.glitchTimer -= 16;
                if (this.glitchTimer <= 0) {
                    this.glitchEffect = false;
                }
            }
            
            getCurrentGap() {
                // Calculate gap based on current level - gets smaller every 5 levels
                const baseGap = this.currentBaseGap || CONFIG.PILLAR_GAP;
                const levelsCompleted = Math.floor(this.currentLevelIdx / 5);
                const gapReduction = levelsCompleted * CONFIG.PILLAR_GAP_DECREASE_PER_5_LEVELS;
                const calculatedGap = Math.max(CONFIG.MIN_PILLAR_GAP, baseGap - gapReduction);
                
                return calculatedGap;
            }
            
            checkLevel() {
                const nextIdx = this.currentLevelIdx + 1;
                if (nextIdx >= this.gameLevels.length) return;
                const next = this.gameLevels[nextIdx];
                if (this.score >= next.threshold) {
                    this.currentLevelIdx++;
                    this.applyLevel();
                    this.shake = 12;
                    
                    // Trigger level up glitch
                    this.triggerLevelUpGlitch();
                    
                    for (let i = 0; i < 30; i++) {
                        this.particles.push(new Particle(
                            this.canvas.width / 2, this.canvas.height / 2, 
                            this.gameLevels[this.currentLevelIdx].accent, 12,
                            Math.random() > 0.5 ? 'hexagram' : 'triangle'
                        ));
                    }
                    
                    if (this.settings.sfx) SFX.levelUp();
                    Haptics.levelUp();
                }
            }
            
            playerJump() {
                if (this.state === GameState.PLAYING) {
                    this.player.jump();
                    Haptics.jump();
                }
            }
            
            togglePause() {
                if (this.state === GameState.PLAYING) {
                    this.state = GameState.PAUSED;
                    document.getElementById('pauseScreen').classList.remove('hidden');
                    AudioSys.pause();
                } else if (this.state === GameState.PAUSED) {
                    this.state = GameState.PLAYING;
                    document.getElementById('pauseScreen').classList.add('hidden');
                    AudioSys.resume();
                    this.gameLoop();
                }
            }
            
            showSettings() {
                document.getElementById('startScreen').classList.add('hidden');
                document.getElementById('settingsScreen').classList.remove('hidden');
                this.state = GameState.SETTINGS;
            }
            
            hideSettings() {
                document.getElementById('settingsScreen').classList.add('hidden');
                document.getElementById('startScreen').classList.remove('hidden');
                this.state = GameState.START;
            }
            
            returnToMenu() {
                this.state = GameState.START;
                document.getElementById('pauseScreen').classList.add('hidden');
                document.getElementById('startScreen').classList.remove('hidden');
                document.getElementById('scoreUi').classList.add('hidden');
                document.getElementById('pauseBtn').classList.add('hidden');
                document.getElementById('instructions').classList.add('hidden');
                document.getElementById('statsPanel').classList.add('hidden');
                document.getElementById('mobileControls').classList.add('hidden');
                if (this.settings.music) AudioSys.switchToMenuMusic();
            }
            
            gameOver() {
                if (this.state === GameState.GAME_OVER) return;
                this.state = GameState.GAME_OVER;
                this.shake = 15;
                
                // Trigger death glitch
                this.triggerDeathGlitch();
                
                if (this.settings.sfx) SFX.crash();
                Haptics.crash();
                
                for (let i = 0; i < 25; i++) {
                    this.particles.push(new Particle(
                        this.player.x, this.player.y,
                        '#ff003c', 10,
                        Math.random() > 0.3 ? 'hexagram' : 'triangle'
                    ));
                }
                
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('93protocol_highscore', this.highScore);
                    document.getElementById('highScoreMsg').textContent = "NEW GNOSIS ATTAINED";
                } else {
                    document.getElementById('highScoreMsg').textContent = `BEST: ${this.highScore}`;
                }
                AudioSys.stop();
                document.getElementById('finalScore').innerText = this.score;
                document.getElementById('scoreUi').classList.add('hidden');
                document.getElementById('pauseBtn').classList.add('hidden');
                document.getElementById('instructions').classList.add('hidden');
                document.getElementById('statsPanel').classList.add('hidden');
                document.getElementById('mobileControls').classList.add('hidden');
                document.getElementById('gameOverScreen').classList.remove('hidden');
            }
            
            restartGame() {
                this.state = GameState.PLAYING;
                this.prepareLevels();
                document.getElementById('gameOverScreen').classList.add('hidden');
                document.getElementById('scoreUi').classList.remove('hidden');
                document.getElementById('pauseBtn').classList.remove('hidden');
                document.getElementById('instructions').classList.remove('hidden');
                if (this.isMobile) {
                    document.getElementById('mobileControls').classList.remove('hidden');
                    setTimeout(() => {
                        document.getElementById('mobileControls').classList.add('hidden');
                    }, 5000);
                }
                if (CONFIG.DEBUG) document.getElementById('statsPanel').classList.remove('hidden');
                this.initGame();
                this.gameLoop();
            }
            
            gameLoop(currentTime = 0) {
                if (this.state !== GameState.PLAYING) return;
                if (this.lastFrameTime) {
                    this.fps = Math.round(1000 / (currentTime - this.lastFrameTime));
                    if (CONFIG.DEBUG) document.getElementById('fpsCounter').textContent = this.fps;
                }
                this.lastFrameTime = currentTime;
                this.frames++;
                const lvl = this.gameLevels[this.currentLevelIdx];
                
                // Random occasional glitch (very rare, minimal performance impact)
                if (Math.random() > 0.995 && this.frames % 60 === 0) {
                    GlitchFX.trigger(30, 'random');
                }
                
                this.tunnelOffset += this.tunnelSpeed * (1 + this.gameSpeed * 0.1);
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.drawHyperspaceTunnel(lvl);
                
                // Apply glitch effects
                GlitchFX.apply(this.ctx, currentTime);
                
                // Apply screen flash if active
                this.applyScreenFlash();
                
                if (this.glitchEffect) {
                    this.applyGlitchEffect();
                }
                
                this.ctx.save();
                if (this.shake > 0) {
                    this.ctx.translate((Math.random() - 0.5) * this.shake, (Math.random() - 0.5) * this.shake);
                    this.shake *= 0.9;
                }
                this.updateGameObjects();
                this.drawGameObjects();
                this.ctx.restore();
                
                requestAnimationFrame((time) => this.gameLoop(time));
            }
            
            drawHyperspaceTunnel(lvl) {
                const ctx = this.ctx;
                const cx = this.canvas.width / 2;
                const cy = this.canvas.height / 2;
                const maxRadius = Math.max(this.canvas.width, this.canvas.height) * 0.8;
                
                ctx.strokeStyle = lvl.accent;
                ctx.lineWidth = 1.5;
                optimizedShadow.apply(ctx, 15, lvl.accent);
                
                for (let i = 0; i < 10; i++) {
                    const progress = ((this.tunnelOffset + i * 50) % 300) / 300;
                    const radius = progress * maxRadius;
                    
                    if (radius < 50) continue;
                    
                    ctx.globalAlpha = 1 - progress * 0.8;
                    ctx.beginPath();
                    ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    for (let j = 0; j < 8; j++) {
                        const angle = (j / 8) * Math.PI * 2;
                        const x1 = cx + Math.cos(angle) * radius;
                        const y1 = cy + Math.sin(angle) * radius;
                        const x2 = cx + Math.cos(angle) * (radius + 20);
                        const y2 = cy + Math.sin(angle) * (radius + 20);
                        
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }
                
                optimizedShadow.clear(ctx);
                ctx.globalAlpha = 1;
                
                // Random subtle glitch on background (very lightweight)
                if (Math.random() > 0.95 && this.frames % 30 === 0) {
                    ctx.save();
                    ctx.globalAlpha = 0.05;
                    ctx.fillStyle = lvl.accent;
                    
                    // Draw a random line
                    const y = Math.random() * this.canvas.height;
                    ctx.fillRect(0, y, this.canvas.width, 1);
                    
                    // Maybe a random rectangle
                    if (Math.random() > 0.5) {
                        const x = Math.random() * this.canvas.width;
                        const size = Math.random() * 20 + 5;
                        ctx.fillRect(x, Math.random() * this.canvas.height, size, 1);
                    }
                    ctx.restore();
                }
                
                this.backgroundParticles.forEach(p => {
                    p.y += p.speed * (1 + this.gameSpeed * 0.1);
                    if (p.y > this.canvas.height) { 
                        p.y = 0; 
                        p.x = Math.random() * this.canvas.width;
                        p.shape = Math.floor(Math.random() * 3);
                    }
                    
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.opacity;
                    
                    if (p.shape === 1) {
                        ctx.save();
                        ctx.translate(p.x, p.y);
                        ctx.rotate(this.frames * 0.01);
                        ctx.beginPath();
                        ctx.moveTo(0, -p.size);
                        ctx.lineTo(p.size * 0.866, p.size * 0.5);
                        ctx.lineTo(-p.size * 0.866, p.size * 0.5);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    } else if (p.shape === 2) {
                        ctx.save();
                        ctx.translate(p.x, p.y);
                        ctx.rotate(this.frames * 0.02);
                        const r = p.size * 0.8;
                        ctx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * 60) * Math.PI / 180;
                            const x = Math.cos(angle) * r;
                            const y = Math.sin(angle) * r;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    } else {
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                ctx.globalAlpha = 1;
                
                // FIXED: Improved background image scaling to prevent cropping
                ctx.globalAlpha = 0.6; 
                if (lvl.loaded && lvl.img && lvl.img.complete) {
                    try {
                        const img = lvl.img;
                        const canvasRatio = this.canvas.width / this.canvas.height;
                        const imgRatio = img.width / img.height;
                        
                        let drawWidth, drawHeight, drawX, drawY;
                        
                        if (canvasRatio > imgRatio) {
                            // Canvas is wider than image - fit to height, center horizontally
                            drawHeight = this.canvas.height;
                            drawWidth = img.width * (drawHeight / img.height);
                            drawX = (this.canvas.width - drawWidth) / 2;
                            drawY = 0;
                        } else {
                            // Canvas is taller than image - fit to width, center vertically
                            drawWidth = this.canvas.width;
                            drawHeight = img.height * (drawWidth / img.width);
                            drawX = 0;
                            drawY = (this.canvas.height - drawHeight) / 2;
                        }
                        
                        // Add a subtle blur effect to hide any minor edges
                        ctx.filter = 'blur(1px)';
                        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                        ctx.filter = 'none';
                        
                    } catch (e) {
                        console.warn("Error drawing background image:", e);
                    }
                }
                ctx.globalAlpha = 1.0;
            }
            
            updateGameObjects() {
                // Calculate current gap based on level
                const currentGap = this.getCurrentGap();
                
                if (this.frames % Math.floor(CONFIG.PILLAR_SPAWN_RATE / (1 + this.gameSpeed * 0.05)) === 0) {
                    const p = new Pillar(this.currentLevelIdx, currentGap);
                    this.obstacles.push(p);
                    if (Math.random() > (1 - CONFIG.ORB_SPAWN_CHANCE)) {
                        this.collectibles.push(new Orb(p.x + p.w / 2, p.top + p.gap / 2));
                    }
                }
                
                this.obstacles.forEach((o, i) => {
                    o.update(this.gameSpeed);
                    
                    // More forgiving collision detection
                    const hitboxReduction = CONFIG.HITBOX_OFFSET;
                    let pL = this.player.x - this.player.r + hitboxReduction;
                    let pR = this.player.x + this.player.r - hitboxReduction;
                    let pT = this.player.y - this.player.r + hitboxReduction;
                    let pB = this.player.y + this.player.r - hitboxReduction;
                    
                    let hTop = (pR > o.x && pL < o.x + o.w && pT < o.top);
                    let hBot = (pR > o.x && pL < o.x + o.w && pB > o.top + o.gap);
                    
                    // Grace period when passing between pillars
                    const gracePeriod = 3;
                    if ((hTop && this.player.y + gracePeriod < o.top) || 
                        (hBot && this.player.y - gracePeriod > o.top + o.gap)) {
                        // Player is close to the edge but might be passing through
                    } else if (hTop || hBot) {
                        this.gameOver();
                    }
                    
                    if (!o.marked && o.x + o.w < this.player.x) {
                        this.score++;
                        o.marked = true;
                        document.getElementById('scoreUi').innerText = this.score;
                        this.checkLevel();
                    }
                    if (o.x < -100) this.obstacles.splice(i, 1);
                });
                
                this.collectibles.forEach((c, i) => {
                    c.update(this.gameSpeed);
                    const dist = Math.hypot(this.player.x - c.x, this.player.y - c.y);
                    if (dist < this.player.r + c.r && !c.collected) {
                        this.score += 5;
                        document.getElementById('scoreUi').innerText = this.score;
                        c.collected = true;
                        
                        // Trigger glitch effect
                        this.triggerOrbGlitch();
                        
                        for (let k = 0; k < 20; k++) {
                            this.particles.push(new Particle(
                                c.x, c.y, 
                                '#ffd700', 8,
                                Math.random() > 0.6 ? 'hexagram' : 
                                Math.random() > 0.3 ? 'triangle' : 'diamond'
                            ));
                        }
                        
                        if (this.settings.sfx) SFX.collect();
                        Haptics.collect();
                        
                        this.collectibles.splice(i, 1);
                        this.checkLevel();
                    }
                    if (c.x < -50) this.collectibles.splice(i, 1);
                });
                
                this.player.update();
                
                this.particles.forEach((p, i) => {
                    p.update();
                    if (p.life <= 0) this.particles.splice(i, 1);
                });
            }
            
            drawGameObjects() {
                const currentLvlConfig = this.gameLevels[this.currentLevelIdx];
                this.obstacles.forEach(o => o.draw(this.ctx, currentLvlConfig));
                this.collectibles.forEach(c => c.draw(this.ctx));
                this.player.draw(this.ctx, currentLvlConfig);
                this.particles.forEach(p => p.draw(this.ctx));
            }
        }

        class Player {
            constructor() {
                this.x = window.innerWidth * 0.25;
                this.y = window.innerHeight / 2;
                this.vy = 0;
                this.r = CONFIG.PLAYER_RADIUS;
                this.rot = 0;
                this.trail = [];
                this.trailLength = game.isMobile ? 8 : 12;
                this.jumpCooldown = 0;
            }
            
            update() {
                this.vy += CONFIG.GRAVITY;
                this.y += this.vy;
                this.rot += 0.03;
                if (this.y > window.innerHeight - this.r * 1.5) {
                    game.gameOver();
                }
                if (this.y < this.r * 1.5) { 
                    this.y = this.r * 1.5; 
                    this.vy = 0; 
                }
                
                if (this.jumpCooldown > 0) {
                    this.jumpCooldown--;
                }
                
                if (game.frames % 2 === 0) {
                    this.trail.unshift({
                        x: this.x, 
                        y: this.y, 
                        r: this.r, 
                        life: 1.0,
                        rot: this.rot
                    });
                    if (this.trail.length > this.trailLength) this.trail.pop();
                }
                
                this.trail.forEach(t => t.life -= 0.05);
            }
            
            draw(ctx, conf) {
                const hue = (game.frames * 2) % 360;
                const strokeColor = `hsl(${hue}, 100%, 60%)`;
                const shadowColor = `hsl(${hue}, 100%, 50%)`;

                this.trail.forEach((t, i) => {
                    if (t.life > 0) {
                        ctx.save();
                        ctx.globalAlpha = t.life * 0.6;
                        ctx.translate(t.x, t.y);
                        ctx.rotate(t.rot + (this.vy * 0.05));
                        
                        const trailR = t.r * 0.7 * t.life;
                        const points = [];
                        for (let j = 0; j < 6; j++) {
                            const angle = (j * 60 - 90) * Math.PI / 180;
                            points.push({ 
                                x: Math.cos(angle) * trailR, 
                                y: Math.sin(angle) * trailR 
                            });
                        }
                        
                        optimizedShadow.apply(ctx, 20 * t.life, shadowColor);
                        ctx.strokeStyle = strokeColor;
                        ctx.lineWidth = 2 * t.life;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';

                        ctx.beginPath();
                        ctx.moveTo(points[0].x, points[0].y);
                        ctx.lineTo(points[2].x, points[2].y);
                        ctx.lineTo(points[5].x, points[5].y);
                        ctx.lineTo(points[3].x, points[3].y);
                        ctx.lineTo(points[1].x, points[1].y);
                        ctx.lineTo(points[4].x, points[4].y);
                        ctx.lineTo(points[0].x, points[0].y);
                        ctx.stroke();
                        
                        ctx.restore();
                    }
                });
                ctx.globalAlpha = 1.0;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rot + (this.vy * 0.05));
                
                const r = this.r * 1.2;
                const points = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (i * 60 - 90) * Math.PI / 180;
                    points.push({ x: Math.cos(angle) * r, y: Math.sin(angle) * r });
                }
                
                optimizedShadow.apply(ctx, 25, shadowColor);
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                ctx.lineTo(points[2].x, points[2].y);
                ctx.lineTo(points[5].x, points[5].y);
                ctx.lineTo(points[3].x, points[3].y);
                ctx.lineTo(points[1].x, points[1].y);
                ctx.lineTo(points[4].x, points[4].y);
                ctx.lineTo(points[0].x, points[0].y);
                ctx.stroke();
                
                const pulse = Math.sin(game.frames * 0.1) * 0.5 + 1;
                ctx.fillStyle = "#fff";
                optimizedShadow.apply(ctx, 40 * pulse, "#fff");
                ctx.beginPath();
                ctx.arc(0, 0, 3 * pulse, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
            
            jump() {
                if (this.jumpCooldown > 0) return;
                
                this.vy = CONFIG.PLAYER_JUMP_FORCE;
                this.jumpCooldown = game.isMobile ? 8 : 5;
                
                // Small glitch on jump
                if (Math.random() > 0.7) {
                    GlitchFX.trigger(40, 'jump');
                }
                
                for (let i = 0; i < (game.isMobile ? 10 : 12); i++) {
                    const type = Math.random() > 0.7 ? 'hexagram' : 
                                Math.random() > 0.4 ? 'triangle' : 'circle';
                    game.particles.push(new Particle(
                        this.x, this.y, '#fff', 3, type
                    ));
                }
                
                if (game.settings.sfx) SFX.jump();
                Haptics.jump();
            }
        }

        class Pillar {
            constructor(lvlIndex, currentGap) {
                this.x = window.innerWidth;
                this.w = CONFIG.PILLAR_WIDTH;
                this.gap = currentGap; // Use the dynamically calculated gap
                
                // Ensure gap is always playable based on screen size
                const maxTop = window.innerHeight - this.gap - 50;
                const minTop = 30;
                this.top = Math.random() * (maxTop - minTop) + minTop;
                
                this.marked = false;
                this.lvl = lvlIndex;
                this.rotation = Math.random() * Math.PI * 2;
                this.innerPattern = Math.floor(Math.random() * 3);
                this.pulse = 0;
                
                // Add visual indicator on mobile for better visibility
                this.hasWarning = game.isMobile && Math.random() > 0.5;
                this.warningAlpha = 1;
            }
            
            update(speed) { 
                this.x -= speed; 
                this.pulse += 0.05;
                this.rotation += 0.005;
                if (this.hasWarning) {
                    this.warningAlpha -= 0.01;
                }
            }
            
            draw(ctx, conf) {
                const hue = (game.frames * 0.5 + this.x * 0.1) % 360;
                const mainColor = `hsl(${hue}, 100%, 60%)`;
                const innerColor = `hsl(${(hue + 60) % 360}, 100%, 70%)`;
                const glowColor = `hsl(${hue}, 100%, 50%)`;
                
                // Add warning glow on mobile for better visibility
                if (this.hasWarning && this.x < window.innerWidth * 0.7 && this.warningAlpha > 0) {
                    ctx.save();
                    ctx.globalAlpha = this.warningAlpha * 0.3;
                    ctx.fillStyle = '#ff003c';
                    ctx.fillRect(this.x - 10, 0, this.w + 20, window.innerHeight);
                    ctx.restore();
                }
                
                ctx.save();
                ctx.translate(this.x + this.w/2, 0);
                
                optimizedShadow.apply(ctx, 30, glowColor);
                ctx.strokeStyle = mainColor;
                ctx.lineWidth = 4;
                ctx.fillStyle = "rgba(0,0,0,0.7)";
                
                const topHeight = this.top + 10;
                ctx.beginPath();
                ctx.moveTo(-this.w/2, -10);
                ctx.lineTo(this.w/2, -10);
                
                const jagCount = 5;
                for (let i = 0; i <= jagCount; i++) {
                    const x = this.w/2 - (i * this.w/jagCount);
                    const y = -10 + (i % 2 === 0 ? 8 : -4);
                    ctx.lineTo(x, y);
                }
                
                ctx.lineTo(-this.w/2, topHeight);
                ctx.lineTo(-this.w/2, -10);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.save();
                ctx.translate(0, topHeight/2);
                ctx.rotate(this.rotation);
                ctx.globalAlpha = 0.4;
                ctx.strokeStyle = innerColor;
                ctx.lineWidth = 1.5;
                optimizedShadow.apply(ctx, 15, innerColor);
                
                if (this.innerPattern === 0) {
                    const size = Math.min(this.w, topHeight) * 0.3;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = Math.cos(angle) * size;
                        const y = Math.sin(angle) * size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                } else if (this.innerPattern === 1) {
                    const size = Math.min(this.w, topHeight) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size * 0.866, size * 0.5);
                    ctx.lineTo(-size * 0.866, size * 0.5);
                    ctx.closePath();
                    ctx.stroke();
                } else {
                    const size = Math.min(this.w, topHeight) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(-size, 0);
                    ctx.lineTo(size, 0);
                    ctx.moveTo(0, -size);
                    ctx.lineTo(0, size);
                    ctx.stroke();
                }
                ctx.restore();
                
                const botY = this.top + this.gap;
                const botHeight = window.innerHeight - botY + 10;
                
                ctx.beginPath();
                ctx.moveTo(-this.w/2, botY);
                ctx.lineTo(this.w/2, botY);
                
                for (let i = 0; i <= jagCount; i++) {
                    const x = this.w/2 - (i * this.w/jagCount);
                    const y = botY + (i % 2 === 0 ? -4 : 8);
                    ctx.lineTo(x, y);
                }
                
                ctx.lineTo(this.w/2, botY + botHeight);
                ctx.lineTo(-this.w/2, botY + botHeight);
                ctx.lineTo(-this.w/2, botY);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.save();
                ctx.translate(0, botY + botHeight/2);
                ctx.rotate(-this.rotation);
                ctx.globalAlpha = 0.4;
                ctx.strokeStyle = innerColor;
                ctx.lineWidth = 1.5;
                
                if (this.innerPattern === 0) {
                    const size = Math.min(this.w, botHeight) * 0.3;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = Math.cos(angle) * size;
                        const y = Math.sin(angle) * size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                } else if (this.innerPattern === 1) {
                    const size = Math.min(this.w, botHeight) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size * 0.866, size * 0.5);
                    ctx.lineTo(-size * 0.866, size * 0.5);
                    ctx.closePath();
                    ctx.stroke();
                } else {
                    const size = Math.min(this.w, botHeight) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(-size, 0);
                    ctx.lineTo(size, 0);
                    ctx.moveTo(0, -size);
                    ctx.lineTo(0, size);
                    ctx.stroke();
                }
                ctx.restore();
                
                ctx.restore();
                optimizedShadow.clear(ctx);
                ctx.globalAlpha = 1.0;
            }
        }

        class Orb {
            constructor(x, y) {
                this.x = x; 
                this.y = y; 
                this.r = 9;
                this.collected = false;
                this.float = Math.random() * Math.PI * 2;
                this.pulse = 0;
                this.rotation = 0;
            }
            
            update(speed) {
                this.x -= speed;
                this.float += 0.1;
                this.pulse += 0.15;
                this.rotation += 0.02;
                this.y += Math.sin(this.float) * 0.8;
            }
            
            draw(ctx) {
                if (this.collected) return;
                
                // Add occasional visual glitch to orbs
                if (Math.random() > 0.97) {
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = '#ff00ff';
                    ctx.fillRect(this.x - this.r, this.y - this.r, this.r * 2, this.r * 2);
                    ctx.restore();
                }
                
                const pulseSize = this.r + Math.sin(this.pulse) * 3;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                optimizedShadow.apply(ctx, 25, '#ffd700');
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
                ctx.stroke();
                
                optimizedShadow.apply(ctx, 30, '#fff');
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.9;
                
                const r = pulseSize * 0.7;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i * 60) * Math.PI / 180;
                    const x = Math.cos(angle) * r;
                    const y = Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
                
                ctx.fillStyle = '#fff';
                optimizedShadow.apply(ctx, 40, '#fff');
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize * 0.2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
        }

        class Particle {
            constructor(x, y, c, speed, type = 'circle') {
                this.x = x; 
                this.y = y; 
                this.c = c;
                this.vx = (Math.random() - 0.5) * speed;
                this.vy = (Math.random() - 0.5) * speed;
                this.life = 1; 
                this.size = Math.random() * 3 + 2;
                this.type = type;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.2;
                this.glow = Math.random() > 0.5;
            }
            
            update() { 
                this.x += this.vx; 
                this.y += this.vy; 
                this.vx *= 0.97;
                this.vy *= 0.97;
                this.life -= 0.03; 
                this.rotation += this.rotationSpeed;
                this.size *= 0.98;
                
                if (game.isMobile) {
                    this.life -= 0.01;
                }
            }
            
            draw(ctx) {
                if (this.life <= 0) return;
                
                if (game.isMobile && this.type !== 'hexagram') {
                    ctx.globalAlpha = this.life * 0.5;
                    ctx.fillStyle = this.c;
                    ctx.fillRect(this.x - this.size, this.y - this.size, 
                                this.size * 2, this.size * 2);
                    ctx.globalAlpha = 1;
                    return;
                }
                
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.c;
                
                if (this.glow && this.life > 0.3) {
                    optimizedShadow.apply(ctx, 20 * this.life, this.c);
                }
                
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                if (this.type === 'hexagram') {
                    const r = this.size * 0.8;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 'triangle') {
                    const r = this.size;
                    ctx.beginPath();
                    ctx.moveTo(0, -r);
                    ctx.lineTo(r * 0.866, r * 0.5);
                    ctx.lineTo(-r * 0.866, r * 0.5);
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 'diamond') {
                    const r = this.size;
                    ctx.beginPath();
                    ctx.moveTo(0, -r);
                    ctx.lineTo(r, 0);
                    ctx.lineTo(0, r);
                    ctx.lineTo(-r, 0);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
        }
        
        class Star {
            constructor() {
                this.x = Math.random() * window.innerWidth;
                this.y = Math.random() * window.innerHeight;
                this.size = Math.random() * 2;
                this.speed = Math.random() * 0.5 + 0.1;
                this.alpha = Math.random() * 0.5 + 0.2;
                this.twinkle = Math.random() * Math.PI * 2;
            }
            update() {
                this.y += this.speed;
                if (this.y > window.innerHeight) {
                    this.y = 0; 
                    this.x = Math.random() * window.innerWidth;
                }
                this.twinkle += 0.05;
                this.alpha = 0.3 + Math.sin(this.twinkle) * 0.2;
            }
            draw(ctx) {
                const conf = game.gameLevels[game.currentLevelIdx];
                ctx.fillStyle = conf ? conf.accent : '#fff';
                ctx.globalAlpha = this.alpha;
                
                if (Math.random() > 0.7) {
                    ctx.fillRect(this.x - this.size/2, this.y, this.size, 1);
                    ctx.fillRect(this.x, this.y - this.size/2, 1, this.size);
                } else {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size/2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1.0;
            }
        }

        let game;
        document.addEventListener('DOMContentLoaded', () => {
            game = new Game();
        });
    </script>
</body>
</html>        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* CRT Scanline Effect */
        .scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
            opacity: 0.4;
        }
        
        /* Vignette for ominous feel */
        .vignette {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, black 130%);
            pointer-events: none;
            z-index: 11;
        }

        /* UI Overlay */
        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 20;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            transition: opacity 0.3s ease;
        }

        /* Start Screen Specifics */
        #startScreen {
            background-size: cover;
            background-position: center;
            /* Psychedelic Background Animation */
            animation: bgBreath 10s infinite alternate; 
        }
        
        /* Dark overlay to make text pop on top of image */
        #startScreen::before {
            content: '';
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: -1;
        }

        @keyframes bgBreath {
            0% { transform: scale(1); filter: hue-rotate(0deg); }
            100% { transform: scale(1.05); filter: hue-rotate(45deg); }
        }

        .hidden {
            opacity: 0 !important;
            pointer-events: none !important;
        }

        /* Neon Buttons */
        .mystic-btn {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--primary);
            color: #fff;
            padding: 15px 50px;
            font-size: 1.2rem;
            font-family: 'Cinzel Decorative', cursive;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 4px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 15px var(--primary), inset 0 0 10px var(--primary);
            margin: 15px;
            min-width: 260px;
            position: relative;
            overflow: hidden;
            text-shadow: 0 0 5px #fff;
            animation: psychedelicBorder 4s infinite linear;
        }

        @keyframes psychedelicBorder {
            0% { border-color: #ff003c; box-shadow: 0 0 15px #ff003c; }
            25% { border-color: #ff00ff; box-shadow: 0 0 15px #ff00ff; }
            50% { border-color: #00ffff; box-shadow: 0 0 15px #00ffff; }
            75% { border-color: #ffd700; box-shadow: 0 0 15px #ffd700; }
            100% { border-color: #ff003c; box-shadow: 0 0 15px #ff003c; }
        }

        .mystic-btn:hover {
            background: #fff;
            color: #000;
            transform: scale(1.05);
            text-shadow: none;
        }

        .mystic-btn:active {
            transform: scale(0.95);
        }

        .title-text {
            font-family: 'Cinzel Decorative', cursive;
            font-size: 5rem;
            color: #fff;
            text-shadow: 0 0 10px var(--primary);
            margin-bottom: 10px;
            letter-spacing: -2px;
            animation: pulseNeon 3s infinite alternate;
        }

        @keyframes pulseNeon {
            0% { text-shadow: 0 0 10px var(--primary), 0 0 20px var(--primary); opacity: 1; }
            100% { text-shadow: 0 0 20px var(--primary), 0 0 40px var(--primary), 0 0 80px var(--primary); opacity: 0.9; }
        }

        .level-indicator {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            font-size: 1.5rem;
            font-family: 'Cinzel Decorative', serif;
            font-weight: 700;
            letter-spacing: 6px;
            color: #fff;
            z-index: 15;
            text-shadow: 0 0 10px #000;
            text-transform: uppercase;
        }

        .score-display {
            position: absolute;
            top: 10%;
            width: 100%;
            text-align: center;
            font-size: 9rem;
            font-family: 'Cinzel Decorative', serif;
            color: rgba(255, 255, 255, 0.1);
            z-index: 5;
            pointer-events: none;
            mix-blend-mode: screen;
            font-weight: 900;
        }

        .progress-bar {
            width: 300px;
            height: 4px;
            background: #222;
            margin: 20px 0;
            position: relative;
            box-shadow: 0 0 10px #000;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width 0.2s ease;
            box-shadow: 0 0 15px var(--primary);
        }

        .instructions {
            position: absolute;
            bottom: 100px;
            width: 100%;
            text-align: center;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 3px;
            z-index: 15;
            font-family: 'Orbitron', sans-serif;
            
            /* FADE OUT ANIMATION */
            animation: fadeOut 5s ease-in-out forwards;
            animation-delay: 2s; /* Wait 2 seconds before fading */
            pointer-events: none;
        }

        @keyframes fadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; visibility: hidden; }
        }

        .pause-btn {
            position: absolute;
            top: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--primary);
            color: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            z-index: 25;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            pointer-events: auto;
            box-shadow: 0 0 10px var(--primary);
            transition: 0.3s;
        }
        
        .pause-btn:hover {
            background: var(--primary);
            color: #000;
            box-shadow: 0 0 20px var(--primary);
        }

        .stats-panel {
            position: absolute;
            top: 30px;
            left: 30px;
            background: rgba(0, 0, 0, 0.7);
            border-left: 3px solid var(--primary);
            padding: 10px 15px;
            font-size: 0.8rem;
            color: #ccc;
            z-index: 25;
            pointer-events: auto;
            font-family: 'Orbitron', monospace;
            text-align: left;
            backdrop-filter: blur(4px);
        }
        
        /* Custom File Upload Styling */
        .file-upload-label {
            display: inline-block;
            margin-top: 20px;
            padding: 10px 20px;
            border: 1px dashed #666;
            color: #888;
            cursor: pointer;
            font-size: 0.8rem;
            transition: 0.3s;
            font-family: 'Orbitron', sans-serif;
        }
        .file-upload-label:hover {
            border-color: var(--primary);
            color: var(--primary);
            box-shadow: 0 0 10px rgba(255, 0, 60, 0.2);
        }

        @media(max-width: 600px) {
            .title-text { font-size: 3.5rem; }
            .score-display { font-size: 6rem; }
            .mystic-btn { 
                padding: 12px 30px; 
                font-size: 1rem;
                min-width: 200px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="scanlines"></div>
        <div class="vignette"></div>
        
        <div id="scoreUi" class="score-display">0</div>
        <div id="levelUi" class="level-indicator">INITIATION</div>
        
        <!-- Start Screen with NEW Background Image -->
        <div id="startScreen" class="ui-layer" style="background-image: url('https://lh3.googleusercontent.com/d/1BXrXXd9TKSqCFNwvS-cJpNORbyvP6fkR=s0');">
            <h1 class="title-text">Sex Magick</h1>
            <p style="letter-spacing: 8px; color: #ff003c; margin-bottom: 40px; font-size: 1.1rem; text-shadow: 0 0 10px #ff003c; font-family: 'Cinzel Decorative', cursive;">Do Your Will Foo</p>
            
            <div id="loadingMsg">
                <div class="loader"></div>
                <p id="loadingText" style="letter-spacing: 4px; font-size: 0.9rem; margin-top: 15px; font-family: 'Cinzel Decorative';">CHARGING SIGIL...</p>
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill"></div>
                </div>
            </div>

            <div id="menuButtons" class="hidden">
                <button id="startBtn" class="mystic-btn">INVOKE</button>
                <button id="settingsBtn" class="mystic-btn">RITES</button>
                
                <label for="fileUpload" class="file-upload-label">
                    [ OPTIONAL: LOAD LOCAL MP3 ]
                </label>
                <input type="file" id="fileUpload" accept="audio/*" style="display:none;">
                <p id="trackName" style="margin-top: 5px; font-size: 0.6rem; color: #555;">SOURCE: GITHUB CDN</p>
            </div>
        </div>

        <div id="gameOverScreen" class="ui-layer hidden" style="background: rgba(0,0,0,0.85);">
            <h1 class="title-text" style="color: #ff003c; font-size: 4rem;">ABORTED</h1>
            <p style="font-size: 1.2rem; letter-spacing: 4px; margin-bottom: 20px; font-family: 'Cinzel Decorative';">RITUAL FAILED</p>
            <p class="text-xl mb-6 text-gray-300">WILL: <span id="finalScore" style="color: #fff; font-weight:bold; text-shadow: 0 0 10px #fff;">0</span></p>
            <p id="highScoreMsg" style="color: #ffd700; margin-bottom: 30px; font-size: 1rem; letter-spacing: 2px;"></p>
            <button id="restartBtn" class="mystic-btn">REINCARNATE</button>
        </div>

        <div id="pauseScreen" class="ui-layer hidden">
            <h1 class="title-text" style="font-size: 3.5rem; color: #ffd700;">MEDITATION</h1>
            <button id="resumeBtn" class="mystic-btn">RESUME</button>
            <button id="menuBtn" class="mystic-btn">ABORT</button>
        </div>

        <div id="settingsScreen" class="ui-layer hidden" style="background: rgba(0,0,0,0.9);">
            <h1 class="title-text" style="font-size: 2.5rem;">SACRED RITES</h1>
            <div style="width: 320px; margin: 20px 0; background: rgba(20,20,20,0.8); padding: 20px; border: 1px solid var(--primary);">
                <div style="display: flex; justify-content: space-between; margin: 15px 0; border-bottom: 1px solid #444; padding-bottom: 10px;">
                    <span>CHANT (MUSIC)</span>
                    <input type="checkbox" id="musicToggle" checked style="accent-color: var(--primary);">
                </div>
                <div style="display: flex; justify-content: space-between; margin: 15px 0; border-bottom: 1px solid #444; padding-bottom: 10px;">
                    <span>RESONANCE (SFX)</span>
                    <input type="checkbox" id="sfxToggle" checked style="accent-color: var(--primary);">
                </div>
                <div style="display: flex; justify-content: space-between; margin: 15px 0;">
                    <span>KUNDALINI (VIBE)</span>
                    <input type="checkbox" id="vibrationToggle" checked style="accent-color: var(--primary);">
                </div>
            </div>
            <button id="backBtn" class="mystic-btn">RETURN</button>
        </div>

        <button id="pauseBtn" class="pause-btn hidden">||</button>
        
        <div id="statsPanel" class="stats-panel">
            <div style="color: var(--primary); font-weight: bold; margin-bottom: 5px;">:: GNOSIS ::</div>
            FPS: <span id="fpsCounter" style="color: #fff;">0</span><br>
            AUDIO: <span id="audioStatus" style="color: #fff;">STANDBY</span>
        </div>

        <div id="instructions" class="instructions hidden">
            [ TAP / SPACE TO ASCEND ]
        </div>
    </div>

    <script>
        // High-Speed CDN Prefix
        const CDN_PREFIX = "https://cdn.jsdelivr.net/gh/bookthief666/93-protocol-game-assets-@662f3d608769e9e945295ac00d668447d974dc5c/";

        const CONFIG = {
            DEBUG: true, 
            MENU_MUSIC: CDN_PREFIX + "iamerror%20-%20The%20Zelda%20Song%20(Hyr00l).mp3",
            GAME_PLAYLIST: [
                CDN_PREFIX + "iamerror%20-%20Hyr00l%20Rough.mp4",
                CDN_PREFIX + "bookthief%F0%9F%A5%80%20-%20booothief-%20All%20gay%F0%9F%98%87%202024-07-10%2001_11%20(1).m4a",
                CDN_PREFIX + "Vae!%20Puto%20Deus%20Fio!%20(3).mp3",
                CDN_PREFIX + "IAMERROR%20-%20The%20Iceclops%20Cometh.mp3",
                CDN_PREFIX + "Forest%20of%20Fellatio%20%5BTTn3kjGwXi0%5D.mp3",
                CDN_PREFIX + "LEX_LFL_80_wurli_loop_ate_bit_Cm.wav",
                CDN_PREFIX + "iamerror%20-%20The%20Zelda%20Song%20(Hyr00l).mp3"
            ],
            BASE_URL: "https://lh3.googleusercontent.com/d/",
            IMG_SUFFIX: "=s0",
            INITIAL_GAME_SPEED: 3.5,
            SPEED_INCREASE_PER_LEVEL: 0.25,
            PILLAR_SPAWN_RATE: 100, // frames
            PILLAR_WIDTH: 55,
            PILLAR_GAP: 220,
            ORB_SPAWN_CHANCE: 0.4,
            PLAYER_JUMP_FORCE: -5.8,
            GRAVITY: 0.25
        };

        const originalLevels = [
            { name: "MALKUTH", id: "1jI7bl3hsVOuzYf6u35L4bhHq5JUiBDa1" },
            { name: "YESOD", id: "1tHgxNvDO5md4z24hS81eTa9uva25mtr5" },
            { name: "HOD", id: "1Mtp6cP6lwGbPRhLWjQKKDijrLX53K4UR" },
            { name: "NETZACH", id: "1y1i5lxL1jVp37bIz1mtJh4-Puce-E5k0" },
            { name: "TIPHARETH", id: "12png0vOPyJC1Ab4Vffcw2R_K-yRw1sqj" },
            { name: "GEBURAH", id: "1le2Hox1ORxhL28fv7WujO0410vM6jUEJ" },
            { name: "CHESED", id: "1Gsq1xSx9ivfVEq6W2nCMrO-dOIMrSYrW" },
            { name: "DA'ATH", id: "1o601hrLi5RpuGL_kiVEoPXxXk2SCbM2z" },
            { name: "BINAH", id: "1iSYJfPsaYjA1rmRTsujLcn1Do-lBydF7" },
            { name: "CHOKMAH", id: "1PvOC62nv5HdsE1cuCF8RENY9Z8HTabn7" },
            { name: "KETHER", id: "1Ym_eyrXJEQUBA7Lg_2oUc6dQ-gy9yfGs" }
        ];

        const newImageIDs = [
            "1pJ5CUGyKXgkSgEREkKos1Kch5FmfUyxE", "1spT4HpO_4q9joE4x6bLjZQRlFTS9j-ie", "1YGzyjcjiCoPCLbYjJEiqT8USUhe4S6hM", "1ELjoJU7KDC88nUk_Vs57OKUG9oLl5E8N",
            "1faa2c3QFWhZ8UgvyZ_ZrlnyFsnsKRclm", "10W5oYkoqB9LC3YjvB_aozR0kG3hWaHka", "1l9Jdm0EQh8sgWh1W0wsXQCzrQM19Bfm9", "1BrHTF2dvfbRkyYfXAbPUiujwE1AJskY4",
            "1KqV8IYF7KDbmgHS3ph6eRQKl4uAAFG_u", "1sZ02UH_vb1xLaOvyETqptc5FuvOtVKd4", "1hLKOGYXCBemcIKt8OLEX4dHTn6bd88cr", "1g_DQeG6qldMBxHzZ82MOVoxk9APwb4NO",
            "1-SIvE5EZyUd7FKXJ7eyB4JCrtOpQoF18", "1S4y4YSCjxSb-b_U1BfMw_0PhabJ-METm", "1OL-kWl-TJNcZFPcsCAtynW2NWp-YYjGd", "1ApPgou40N2Q6GlNKNuyoQ2Gk5DqAfmw_",
            "1OeH1GMu2rDcwzdtWFZSB1WWe0OjkmxV0", "12Z92v9Mu9yNOnDTtK-bjMRZ8_2BAW2eW", "1Erf3DKxZpfbG57oGcUCjuHIhajsweLZz", "1qK22CJhJ1XgElL156uOQxYrucaRG16p0",
            "1euwdAWg-xQw7isR-JAiZ-krXQXOS8pi0", "1A3hT3mJibINtsr8CVxTmp71QsYgPB2JZ", "1QUVr-RK2kP7IIAuy0wX3pOZRQuyr-o-e", "1eF02YMyYBcgx7Ga20pXgoltzWXPYznfD",
            "1zx1vrrbuSA4xCFKXAHgXbkG1rX8PUPel", "1ds1iqXf90gy9PUFs80t4QOxamkJj0u1I", "14-t6dPPv5MeXe7LWPIp7Tjc8x4w5Vj2d", "1pUtIizMzVhjzB46dhah5mgz6Tr-vaSLO",
            "1ZOEkUW8q2s5zerS7BubYJU69RHk7_Zlo", "15ZHj0fLYu-4rEQy43BMJKDgXnnQ5FeyP", "1ZzgVT0O6XQzW3DUP4i1aoKd_DD5wV5LZ", "1rZHZM0bR_j6uiYZLS82J0BkbIfEUoXvY",
            "1CNrQ_EeMXQgHJGXxe7EHysQi_A0A9UE7", "1ubCqIg7ETOIsHGfBjQfVsRzjlZIpBP6E", "1pojzjR-uiQ0oTHRJxXXCW_w0hlJUCqyb", "1SnclBlH6sflhaTWzFhbcNedzNeh25-BV",
            "1thfc-9DnM4GhCi0zTbcX4MH-yaQEpomX", "1BXrXXd9TKSqCFNwvS-cJpNORbyvP6fkR", "1D1bOksatIt6Jw6Zq8Sbmhbq_GC_2EQHh", "1eP_Xnk80YnL3w3Q69wQmVo9_F0OaA3Wo",
            "1ARDOipcr0lB1GYf3gmhqlHXlpC23Q2JE", "1io39jfggXQl-OyvSFGIpgOtoIzHbml3M", "1o0rJmx3vEKITMx1ixP5iruOX2ujOT6VO", "1Irw61utgSGdip21OgTcYqz56LpWWS9fb",
            "19V2ObVoQn9R9bt1ZgMNEBJokaAjYdX_9", "1WWvLnkkPBN7Q0ZsGi16FL1anhPlti3Qd", "1HoYqC0SLc3nrSDnoW9KJ2-z8AnRWIz5M", "1oS0J3F-zh5H48-Qs5Mrm10dPR993kF-b",
            "1bRwsBEuZiAIZW_5f3WOZVI6-KVnCEslk", "1GLza2_RmR4c_KD_KGxbXPOoCAw9SITKl", "1uWFSChozQmHEnuJwXqiPNApXuAwPAzKS", "1t2hNBEudzIo19kuP8ksPY_cNetDdTd8P",
            "1KhMBL7a3NSggVerbyy53fQ-dLq11adwj", "1wgxalTR68YM7oIku8JYZYKtG50atEnG_", "1BceMgnHgVn9U_7EYnXQu9HDwEQY1UBa_", "14_iwYDQjp34-R_iby8QadKnI9m3zVnOu",
            "1cZ_ci9J80jnqCAdag8SQofYZw1dfsX3C", "15z3bGrCqUy8SQjX1dO5C1vlN3y4-soai", "10xAFw98B39Ou0SSeB4eWyoY2D_OLLPgz", "1CexZQw11p33u1-YA7JhPAkGV6NBCgd6e",
            "16t1EdHfHRpb7GmqNAfo2iKKm57qLfbKn", "12wQOhUztVCVEFV21fPDq-JXGi5zxdkeQ", "1-0u9JUH0oUHD1--5iaySxRpO_PuyxkH6", "1wnITY3i6XxOr1b3l6P0cT10LkEHQauO5"
        ].filter((value, index, self) => self.indexOf(value) === index);

        const esotericNames = [
            "KUNDALINI", "HIEROS GAMOS", "SACRED UNION", "RED TINCTURE", "WHITE GLUTEN", 
            "CUP OF BABALON", "BLOOD OF SAINTS", "CITY OF PYRAMIDS", "NIGHT OF PAN", 
            "HADIT'S FLAME", "NUIT'S EMBRACE", "LAW OF THELEMA", "LOVE UNDER WILL", 
            "GREAT WORK", "STONE OF WISE", "ELIXIR OF LIFE", "RED LION", "WHITE EAGLE",
            "ABRAHADABRA", "LASHTAL", "KA", "BA", "KHU", "SCARLET WOMAN", "THE BEAST",
            "AEON OF HORUS", "93", "AGAPE", "THELEMA", "VIA OVUM", "SPERMATOZOON",
            "HOMUNCULUS", "DIVINE EROS", "TANTRA", "YONI", "LINGAM", "O.T.O.", "A.'.A.'.",
            "STAR SAPPHIRE", "MASS OF PHOENIX", "LIBER AL", "RESH", "SAMEKH", "TZADDI"
        ];

        let MASTER_POOL = [...originalLevels];
        
        const palette = ["#ff003c", "#ff00ff", "#9d00ff", "#00f0ff", "#00ff9d", "#d4ff00", "#ff8800"];

        newImageIDs.forEach((id, index) => {
            const nameIndex = index % esotericNames.length;
            MASTER_POOL.push({
                name: esotericNames[nameIndex],
                id: id,
                color: "#000",
                accent: palette[index % palette.length],
                img: null,
                loaded: false
            });
        });

        const GameState = {
            START: 'start',
            LOADING: 'loading',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAME_OVER: 'gameover',
            SETTINGS: 'settings'
        };

        // ========== TARGETED PERFORMANCE FIXES ==========
        // ONLY fix what's absolutely necessary for mobile
        
        // 1. The REAL problem: Gaussian blur shadows on mobile
        // Solution: Use optimized shadow rendering for mobile
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Mobile-optimized shadow rendering
        const optimizedShadow = {
            apply(ctx, blur, color) {
                if (isMobile) {
                    // On mobile: Use cheaper layered shadows instead of expensive blur
                    ctx.shadowBlur = Math.min(blur, 10); // Cap blur on mobile
                    ctx.shadowColor = color;
                } else {
                    ctx.shadowBlur = blur;
                    ctx.shadowColor = color;
                }
            },
            clear(ctx) {
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }
        };

        const SFX = {
            audioContext: null,
            init() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
            },
            playTone(freq, type, duration, vol, detune = 0) {
                if (!game?.settings?.sfx) return;
                if (!this.audioContext) this.init();
                if (this.audioContext.state === 'suspended') this.audioContext.resume();
                
                try {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    
                    osc.type = type;
                    osc.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                    osc.detune.setValueAtTime(detune, this.audioContext.currentTime);
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    gain.gain.setValueAtTime(vol, this.audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                    
                    osc.start();
                    osc.stop(this.audioContext.currentTime + duration);
                } catch(e){}
            },
            jump() { 
                this.playTone(400, 'square', 0.08, 0.1);
                this.playTone(600, 'sine', 0.05, 0.05, 100);
            },
            collect() { 
                this.playTone(800, 'sine', 0.2, 0.1);
                this.playTone(1200, 'triangle', 0.1, 0.05, 50);
            },
            crash() { 
                this.playTone(100, 'sawtooth', 0.5, 0.3);
                this.playTone(80, 'square', 0.3, 0.2, -100);
            },
            levelUp() { 
                // Rising tone for level up
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.5);
                osc.connect(gain);
                gain.connect(this.audioContext.destination);
                gain.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                osc.start();
                osc.stop(this.audioContext.currentTime + 0.5);
            },
            phaseShift() {
                this.playTone(300, 'sawtooth', 0.3, 0.15);
                this.playTone(450, 'square', 0.2, 0.1, 200);
            }
        };

        // Haptic Feedback System
        const Haptics = {
            jump() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([20]);
                }
            },
            collect() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([50, 30, 50]);
                }
            },
            crash() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([200, 50, 100, 50, 50]);
                }
            },
            levelUp() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([100, 30, 100, 30, 100]);
                }
            },
            phaseShift() {
                if (game?.settings?.vibration && navigator.vibrate) {
                    navigator.vibrate([75, 25, 75]);
                }
            }
        };

        const AudioSys = {
            bgm: null,
            localBlobUrl: null,
            currentMode: 'none', 
            retryCount: 0,
            
            setStatus(msg) {
                const el = document.getElementById('audioStatus');
                if (el) {
                    el.textContent = msg;
                    el.style.color = '#fff';
                    setTimeout(() => el.style.color = 'var(--primary)', 200);
                }
            },

            init() {
                this.setupAudioElement(CONFIG.MENU_MUSIC);
                this.currentMode = 'menu';
                this.setStatus("MENU AUDIO RDY");
            },

            setupAudioElement(src) {
                if (this.bgm) {
                    this.bgm.pause();
                    this.bgm.src = "";
                    this.bgm.load();
                }
                this.bgm = new Audio();
                this.bgm.src = src;
                this.bgm.loop = true;
                this.bgm.volume = 0.8;
                this.bgm.preload = "auto";
                
                this.bgm.onwaiting = () => this.setStatus("BUFFERING...");
                this.bgm.onplaying = () => {
                    this.setStatus("PLAYING");
                    this.retryCount = 0;
                };
                
                this.bgm.onerror = (e) => {
                    console.warn("Audio error:", e);
                    this.setStatus("LOAD ERROR");
                };
            },

            loadLocalFile(file) {
                if (this.localBlobUrl) URL.revokeObjectURL(this.localBlobUrl);
                this.localBlobUrl = URL.createObjectURL(file);
                this.setupAudioElement(this.localBlobUrl);
                this.setStatus("FILE LOADED");
            },
            
            switchToGameMusic() {
                if (this.localBlobUrl) return; 
                const randomIndex = Math.floor(Math.random() * CONFIG.GAME_PLAYLIST.length);
                const track = CONFIG.GAME_PLAYLIST[randomIndex];
                this.currentMode = 'game';
                this.setStatus("LOADING TRK " + (randomIndex + 1));
                this.setupAudioElement(track);
                this.play();
            },

            switchToMenuMusic() {
                if (this.localBlobUrl) return;
                this.currentMode = 'menu';
                this.setStatus("LOADING MENU");
                this.setupAudioElement(CONFIG.MENU_MUSIC);
            },
            
            play() {
                if (!this.bgm) return;
                const playPromise = this.bgm.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => this.setStatus("PLAYING")).catch(error => {
                        console.warn("Play failed:", error);
                        this.setStatus("AUTOPLAY BLOCK");
                    });
                }
            },
            
            pause() { if (this.bgm) { this.bgm.pause(); this.setStatus("PAUSED"); } },
            resume() { if (this.bgm && this.bgm.paused) { this.bgm.play(); this.setStatus("RESUMED"); } },
            stop() { if (this.bgm) { this.bgm.pause(); this.bgm.currentTime = 0; this.setStatus("STOPPED"); } }
        };

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.root = document.documentElement;
                
                this.state = GameState.START;
                this.currentLevelIdx = 0;
                this.frames = 0;
                this.score = 0;
                this.highScore = localStorage.getItem('93protocol_highscore') || 0;
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED;
                this.shake = 0;
                this.lastFrameTime = 0;
                this.fps = 0;
                
                // MINIMAL performance tweaks only for mobile
                this.isMobile = isMobile;
                
                // Glitch effect properties
                this.glitchEffect = false;
                this.glitchTimer = 0;
                this.glitchDuration = 300;
                
                // Hyperspace tunnel properties
                this.tunnelOffset = 0;
                this.tunnelSpeed = 0.5;
                
                this.backgroundParticles = [];
                
                this.player = null;
                this.particles = [];
                this.stars = [];
                this.obstacles = [];
                this.collectibles = [];
                this.gameLevels = []; 
                
                this.settings = { music: true, sfx: true, vibration: true };
                
                this.loadSettings();
                this.initEventListeners();
                this.resizeCanvas();
                this.preloadAllImages();
                this.createBackgroundParticles();
                
                AudioSys.init();
                SFX.init();
            }
            
            createBackgroundParticles() {
                // Keep the same number but optimize drawing
                for (let i = 0; i < 80; i++) {
                    this.backgroundParticles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        z: Math.random() * 2 + 0.5, 
                        size: Math.random() * 3,
                        speed: Math.random() * 0.5 + 0.1,
                        color: palette[Math.floor(Math.random() * palette.length)],
                        opacity: Math.random() * 0.4 + 0.1,
                        shape: Math.floor(Math.random() * 3)
                    });
                }
            }
            
            initEventListeners() {
                document.getElementById('fileUpload').addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) AudioSys.loadLocalFile(file);
                });

                window.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && this.state === GameState.PLAYING) this.playerJump();
                    else if (e.code === 'Escape') this.togglePause();
                });
                
                window.addEventListener('mousedown', (e) => {
                    if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'LABEL' && this.state === GameState.PLAYING) this.playerJump();
                });
                
                window.addEventListener('touchstart', (e) => {
                    if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'LABEL' && this.state === GameState.PLAYING) {
                        e.preventDefault();
                        this.playerJump();
                    }
                }, { passive: false });
                
                document.getElementById('startBtn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (this.settings.music) AudioSys.switchToGameMusic();
                    this.startGame();
                });
                
                document.getElementById('restartBtn').addEventListener('click', (e) => {
                     e.stopPropagation();
                     if (this.settings.music) AudioSys.switchToGameMusic();
                     this.restartGame();
                });
                
                document.getElementById('pauseBtn').addEventListener('click', (e) => { e.stopPropagation(); this.togglePause(); });
                document.getElementById('resumeBtn').addEventListener('click', (e) => { e.stopPropagation(); this.togglePause(); });
                document.getElementById('menuBtn').addEventListener('click', (e) => { e.stopPropagation(); this.returnToMenu(); });
                document.getElementById('settingsBtn').addEventListener('click', (e) => { e.stopPropagation(); this.showSettings(); });
                document.getElementById('backBtn').addEventListener('click', (e) => { e.stopPropagation(); this.hideSettings(); });
                
                document.getElementById('musicToggle').addEventListener('change', (e) => {
                    this.settings.music = e.target.checked;
                    this.saveSettings();
                    if (!this.settings.music) AudioSys.stop();
                    else if (this.state === GameState.PLAYING) AudioSys.play();
                });
                
                document.getElementById('sfxToggle').addEventListener('change', (e) => {
                    this.settings.sfx = e.target.checked;
                    this.saveSettings();
                });
                
                document.getElementById('vibrationToggle').addEventListener('change', (e) => {
                    this.settings.vibration = e.target.checked;
                    this.saveSettings();
                });
                
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            loadSettings() {
                const saved = localStorage.getItem('93protocol_settings');
                if (saved) this.settings = { ...this.settings, ...JSON.parse(saved) };
                document.getElementById('musicToggle').checked = this.settings.music;
                document.getElementById('sfxToggle').checked = this.settings.sfx;
                document.getElementById('vibrationToggle').checked = this.settings.vibration;
            }
            
            saveSettings() { localStorage.setItem('93protocol_settings', JSON.stringify(this.settings)); }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }
            
            preloadAllImages() {
                const progressFill = document.getElementById('progressFill');
                const loadingText = document.getElementById('loadingText');
                let loadedCount = 0;
                
                const failsafe = setTimeout(() => {
                    if (loadedCount < MASTER_POOL.length) {
                        console.warn("Loading timed out. Forcing start.");
                        this.finishLoading();
                    }
                }, 5000);
                
                MASTER_POOL.forEach(lvl => {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.onload = () => {
                        lvl.img = img;
                        lvl.loaded = true;
                        loadedCount++;
                        const percent = Math.floor((loadedCount / MASTER_POOL.length) * 100);
                        progressFill.style.width = `${percent}%`;
                        loadingText.innerText = `CHARGING SIGIL... ${loadedCount}/${MASTER_POOL.length}`;
                        if (loadedCount >= MASTER_POOL.length) {
                            clearTimeout(failsafe);
                            this.finishLoading();
                        }
                    };
                    img.onerror = () => {
                        console.warn(`Failed to load image: ${lvl.id}`);
                        loadedCount++;
                        if (loadedCount >= MASTER_POOL.length) {
                            clearTimeout(failsafe);
                            this.finishLoading();
                        }
                    };
                    img.src = CONFIG.BASE_URL + lvl.id + CONFIG.IMG_SUFFIX;
                });
            }
            
            finishLoading() {
                setTimeout(() => {
                    document.getElementById('loadingMsg').classList.add('hidden');
                    document.getElementById('menuButtons').classList.remove('hidden');
                }, 500);
            }
            
            prepareLevels() {
                let shuffled = [...MASTER_POOL];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                this.gameLevels = shuffled.map((lvl, index) => {
                    return { ...lvl, threshold: index * 5 };
                });
            }

            startGame() {
                this.prepareLevels();
                this.state = GameState.PLAYING;
                document.getElementById('startScreen').classList.add('hidden');
                document.getElementById('scoreUi').classList.remove('hidden');
                document.getElementById('pauseBtn').classList.remove('hidden');
                document.getElementById('instructions').classList.remove('hidden');
                if (CONFIG.DEBUG) document.getElementById('statsPanel').classList.remove('hidden');
                this.initGame();
                this.gameLoop();
            }
            
            initGame() {
                this.player = new Player();
                this.obstacles = [];
                this.collectibles = [];
                this.particles = [];
                this.stars = [];
                for (let i = 0; i < 50; i++) this.stars.push(new Star());
                this.score = 0;
                this.currentLevelIdx = 0;
                this.frames = 0;
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED;
                this.shake = 0;
                this.tunnelOffset = 0;
                document.getElementById('scoreUi').innerText = "0";
                this.applyLevel();
            }
            
            applyLevel() {
                if (this.currentLevelIdx >= this.gameLevels.length) return;
                const l = this.gameLevels[this.currentLevelIdx];
                document.getElementById('levelUi').innerText = l.name;
                document.getElementById('levelUi').style.color = l.accent;
                document.getElementById('levelUi').style.textShadow = `0 0 15px ${l.accent}`;
                this.root.style.setProperty('--primary', l.accent);
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED + (this.currentLevelIdx * CONFIG.SPEED_INCREASE_PER_LEVEL);
                
                if (this.currentLevelIdx > 0) {
                    this.triggerGlitchEffect();
                    Haptics.levelUp();
                }
            }
            
            triggerGlitchEffect() {
                this.glitchEffect = true;
                this.glitchTimer = this.glitchDuration;
            }
            
            applyGlitchEffect() {
                if (!this.glitchEffect) return;
                
                const ctx = this.ctx;
                const intensity = this.glitchTimer / this.glitchDuration;
                
                // Simple glitch effect that works on mobile
                if (Math.random() > 0.7) {
                    const shiftX = Math.floor(Math.random() * 10 * intensity) - 5;
                    const shiftY = Math.floor(Math.random() * 10 * intensity) - 5;
                    
                    ctx.save();
                    ctx.translate(shiftX, shiftY);
                    ctx.restore();
                }
                
                // Scanline effect
                if (Math.random() > 0.8) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fillRect(0, Math.floor(Math.random() * this.canvas.height), this.canvas.width, 1);
                }
                
                this.glitchTimer -= 16;
                if (this.glitchTimer <= 0) {
                    this.glitchEffect = false;
                }
            }
            
            checkLevel() {
                const nextIdx = this.currentLevelIdx + 1;
                if (nextIdx >= this.gameLevels.length) return;
                const next = this.gameLevels[nextIdx];
                if (this.score >= next.threshold) {
                    this.currentLevelIdx++;
                    this.applyLevel();
                    this.shake = 15;
                    
                    for (let i = 0; i < 40; i++) {
                        this.particles.push(new Particle(
                            this.canvas.width / 2, this.canvas.height / 2, 
                            this.gameLevels[this.currentLevelIdx].accent, 15,
                            Math.random() > 0.5 ? 'hexagram' : 'triangle'
                        ));
                    }
                    
                    if (this.settings.sfx) SFX.levelUp();
                }
            }
            
            playerJump() {
                if (this.state === GameState.PLAYING) {
                    this.player.jump();
                    Haptics.jump();
                }
            }
            
            togglePause() {
                if (this.state === GameState.PLAYING) {
                    this.state = GameState.PAUSED;
                    document.getElementById('pauseScreen').classList.remove('hidden');
                    AudioSys.pause();
                } else if (this.state === GameState.PAUSED) {
                    this.state = GameState.PLAYING;
                    document.getElementById('pauseScreen').classList.add('hidden');
                    AudioSys.resume();
                    this.gameLoop();
                }
            }
            
            showSettings() {
                document.getElementById('startScreen').classList.add('hidden');
                document.getElementById('settingsScreen').classList.remove('hidden');
                this.state = GameState.SETTINGS;
            }
            
            hideSettings() {
                document.getElementById('settingsScreen').classList.add('hidden');
                document.getElementById('startScreen').classList.remove('hidden');
                this.state = GameState.START;
            }
            
            returnToMenu() {
                this.state = GameState.START;
                document.getElementById('pauseScreen').classList.add('hidden');
                document.getElementById('startScreen').classList.remove('hidden');
                document.getElementById('scoreUi').classList.add('hidden');
                document.getElementById('pauseBtn').classList.add('hidden');
                document.getElementById('instructions').classList.add('hidden');
                document.getElementById('statsPanel').classList.add('hidden');
                if (this.settings.music) AudioSys.switchToMenuMusic();
            }
            
            gameOver() {
                if (this.state === GameState.GAME_OVER) return;
                this.state = GameState.GAME_OVER;
                this.shake = 20;
                
                if (this.settings.sfx) SFX.crash();
                Haptics.crash();
                
                for (let i = 0; i < 35; i++) {
                    this.particles.push(new Particle(
                        this.player.x, this.player.y,
                        '#ff003c', 12,
                        Math.random() > 0.3 ? 'hexagram' : 'triangle'
                    ));
                }
                
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('93protocol_highscore', this.highScore);
                    document.getElementById('highScoreMsg').textContent = "NEW GNOSIS ATTAINED";
                } else {
                    document.getElementById('highScoreMsg').textContent = `BEST: ${this.highScore}`;
                }
                AudioSys.stop();
                document.getElementById('finalScore').innerText = this.score;
                document.getElementById('scoreUi').classList.add('hidden');
                document.getElementById('pauseBtn').classList.add('hidden');
                document.getElementById('instructions').classList.add('hidden');
                document.getElementById('statsPanel').classList.add('hidden');
                document.getElementById('gameOverScreen').classList.remove('hidden');
            }
            
            restartGame() {
                this.state = GameState.PLAYING;
                this.prepareLevels();
                document.getElementById('gameOverScreen').classList.add('hidden');
                document.getElementById('scoreUi').classList.remove('hidden');
                document.getElementById('pauseBtn').classList.remove('hidden');
                document.getElementById('instructions').classList.remove('hidden');
                if (CONFIG.DEBUG) document.getElementById('statsPanel').classList.remove('hidden');
                this.initGame();
                this.gameLoop();
            }
            
            gameLoop(currentTime = 0) {
                if (this.state !== GameState.PLAYING) return;
                if (this.lastFrameTime) {
                    this.fps = Math.round(1000 / (currentTime - this.lastFrameTime));
                    if (CONFIG.DEBUG) document.getElementById('fpsCounter').textContent = this.fps;
                }
                this.lastFrameTime = currentTime;
                this.frames++;
                const lvl = this.gameLevels[this.currentLevelIdx];
                
                // Update tunnel offset
                this.tunnelOffset += this.tunnelSpeed * (1 + this.gameSpeed * 0.1);
                
                // OPTIMIZATION: Only clear dirty regions when possible
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw background with hyperspace tunnel
                this.drawHyperspaceTunnel(lvl);
                
                // Apply glitch effect if active
                if (this.glitchEffect) {
                    this.applyGlitchEffect();
                }
                
                this.ctx.save();
                if (this.shake > 0) {
                    this.ctx.translate((Math.random() - 0.5) * this.shake, (Math.random() - 0.5) * this.shake);
                    this.shake *= 0.9;
                }
                this.updateGameObjects();
                this.drawGameObjects();
                this.ctx.restore();
                
                requestAnimationFrame((time) => this.gameLoop(time));
            }
            
            // KEEP THE ORIGINAL HYPERSPACE TUNNEL - just optimize shadow rendering
            drawHyperspaceTunnel(lvl) {
                const ctx = this.ctx;
                const cx = this.canvas.width / 2;
                const cy = this.canvas.height / 2;
                const maxRadius = Math.max(this.canvas.width, this.canvas.height) * 0.8;
                
                // Draw tunnel rings
                ctx.strokeStyle = lvl.accent;
                ctx.lineWidth = 1.5;
                optimizedShadow.apply(ctx, 15, lvl.accent);
                
                // Draw multiple rings with perspective
                for (let i = 0; i < 12; i++) {
                    const progress = ((this.tunnelOffset + i * 50) % 300) / 300;
                    const radius = progress * maxRadius;
                    
                    if (radius < 50) continue;
                    
                    ctx.globalAlpha = 1 - progress * 0.8;
                    ctx.beginPath();
                    ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Draw connecting lines
                    for (let j = 0; j < 8; j++) {
                        const angle = (j / 8) * Math.PI * 2;
                        const x1 = cx + Math.cos(angle) * radius;
                        const y1 = cy + Math.sin(angle) * radius;
                        const x2 = cx + Math.cos(angle) * (radius + 20);
                        const y2 = cy + Math.sin(angle) * (radius + 20);
                        
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }
                
                optimizedShadow.clear(ctx);
                ctx.globalAlpha = 1;
                
                // Draw background particles with custom shapes
                this.backgroundParticles.forEach(p => {
                    p.y += p.speed * (1 + this.gameSpeed * 0.1);
                    if (p.y > this.canvas.height) { 
                        p.y = 0; 
                        p.x = Math.random() * this.canvas.width;
                        p.shape = Math.floor(Math.random() * 3);
                    }
                    
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.opacity;
                    
                    if (p.shape === 1) { // Triangle
                        ctx.save();
                        ctx.translate(p.x, p.y);
                        ctx.rotate(this.frames * 0.01);
                        ctx.beginPath();
                        ctx.moveTo(0, -p.size);
                        ctx.lineTo(p.size * 0.866, p.size * 0.5);
                        ctx.lineTo(-p.size * 0.866, p.size * 0.5);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    } else if (p.shape === 2) { // Tiny hexagram
                        ctx.save();
                        ctx.translate(p.x, p.y);
                        ctx.rotate(this.frames * 0.02);
                        const r = p.size * 0.8;
                        ctx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * 60) * Math.PI / 180;
                            const x = Math.cos(angle) * r;
                            const y = Math.sin(angle) * r;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    } else { // Circle
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                ctx.globalAlpha = 1;
                
                // Image Background with reduced opacity
                ctx.globalAlpha = 0.6; 
                if (lvl.loaded && lvl.img && lvl.img.complete) {
                    try {
                        const img = lvl.img;
                        const scale = Math.max(this.canvas.width / img.width, this.canvas.height / img.height);
                        const w = img.width * scale;
                        const h = img.height * scale;
                        const x = (this.canvas.width - w) / 2;
                        const y = (this.canvas.height - h) / 2;
                        ctx.drawImage(img, x, y, w, h);
                    } catch (e) {}
                }
                ctx.globalAlpha = 1.0;
            }
            
            updateGameObjects() {
                if (this.frames % Math.floor(CONFIG.PILLAR_SPAWN_RATE / (1 + this.gameSpeed * 0.05)) === 0) {
                    const p = new Pillar(this.currentLevelIdx);
                    this.obstacles.push(p);
                    if (Math.random() > (1 - CONFIG.ORB_SPAWN_CHANCE)) {
                        this.collectibles.push(new Orb(p.x + p.w / 2, p.top + p.gap / 2));
                    }
                }
                
                this.obstacles.forEach((o, i) => {
                    o.update(this.gameSpeed);
                    let pL = this.player.x - this.player.r + 4;
                    let pR = this.player.x + this.player.r - 4;
                    let pT = this.player.y - this.player.r + 4;
                    let pB = this.player.y + this.player.r - 4;
                    let hTop = (pR > o.x && pL < o.x + o.w && pT < o.top);
                    let hBot = (pR > o.x && pL < o.x + o.w && pB > o.top + o.gap);
                    if (hTop || hBot) this.gameOver();
                    if (!o.marked && o.x + o.w < this.player.x) {
                        this.score++;
                        o.marked = true;
                        document.getElementById('scoreUi').innerText = this.score;
                        this.checkLevel();
                    }
                    if (o.x < -100) this.obstacles.splice(i, 1);
                });
                
                this.collectibles.forEach((c, i) => {
                    c.update(this.gameSpeed);
                    const dist = Math.hypot(this.player.x - c.x, this.player.y - c.y);
                    if (dist < this.player.r + c.r && !c.collected) {
                        this.score += 5;
                        document.getElementById('scoreUi').innerText = this.score;
                        c.collected = true;
                        
                        for (let k = 0; k < 25; k++) {
                            this.particles.push(new Particle(
                                c.x, c.y, 
                                '#ffd700', 10,
                                Math.random() > 0.6 ? 'hexagram' : 
                                Math.random() > 0.3 ? 'triangle' : 'diamond'
                            ));
                        }
                        
                        if (this.settings.sfx) SFX.collect();
                        Haptics.collect();
                        
                        this.collectibles.splice(i, 1);
                        this.checkLevel();
                    }
                    if (c.x < -50) this.collectibles.splice(i, 1);
                });
                
                this.player.update();
                
                this.particles.forEach((p, i) => {
                    p.update();
                    if (p.life <= 0) this.particles.splice(i, 1);
                });
            }
            
            drawGameObjects() {
                const currentLvlConfig = this.gameLevels[this.currentLevelIdx];
                this.obstacles.forEach(o => o.draw(this.ctx, currentLvlConfig));
                this.collectibles.forEach(c => c.draw(this.ctx));
                this.player.draw(this.ctx, currentLvlConfig);
                this.particles.forEach(p => p.draw(this.ctx));
            }
        }

        class Player {
            constructor() {
                this.x = window.innerWidth * 0.25;
                this.y = window.innerHeight / 2;
                this.vy = 0;
                this.r = 16;
                this.rot = 0;
                this.trail = [];
                this.trailLength = 12;
            }
            
            update() {
                this.vy += CONFIG.GRAVITY;
                this.y += this.vy;
                this.rot += 0.03;
                if (this.y > window.innerHeight - this.r) game.gameOver();
                if (this.y < this.r) { this.y = this.r; this.vy = 0; }
                
                if (game.frames % 2 === 0) {
                    this.trail.unshift({
                        x: this.x, 
                        y: this.y, 
                        r: this.r, 
                        life: 1.0,
                        rot: this.rot
                    });
                    if (this.trail.length > this.trailLength) this.trail.pop();
                }
                
                this.trail.forEach(t => t.life -= 0.05);
            }
            
            draw(ctx, conf) {
                const hue = (game.frames * 2) % 360;
                const strokeColor = `hsl(${hue}, 100%, 60%)`;
                const shadowColor = `hsl(${hue}, 100%, 50%)`;

                // Enhanced trail with rotation
                this.trail.forEach((t, i) => {
                    if (t.life > 0) {
                        ctx.save();
                        ctx.globalAlpha = t.life * 0.6;
                        ctx.translate(t.x, t.y);
                        ctx.rotate(t.rot + (this.vy * 0.05));
                        
                        const trailR = t.r * 0.7 * t.life;
                        const points = [];
                        for (let j = 0; j < 6; j++) {
                            const angle = (j * 60 - 90) * Math.PI / 180;
                            points.push({ 
                                x: Math.cos(angle) * trailR, 
                                y: Math.sin(angle) * trailR 
                            });
                        }
                        
                        optimizedShadow.apply(ctx, 20 * t.life, shadowColor);
                        ctx.strokeStyle = strokeColor;
                        ctx.lineWidth = 2 * t.life;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';

                        ctx.beginPath();
                        ctx.moveTo(points[0].x, points[0].y);
                        ctx.lineTo(points[2].x, points[2].y);
                        ctx.lineTo(points[5].x, points[5].y);
                        ctx.lineTo(points[3].x, points[3].y);
                        ctx.lineTo(points[1].x, points[1].y);
                        ctx.lineTo(points[4].x, points[4].y);
                        ctx.lineTo(points[0].x, points[0].y);
                        ctx.stroke();
                        
                        ctx.restore();
                    }
                });
                ctx.globalAlpha = 1.0;
                
                // Main player hexagram
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rot + (this.vy * 0.05));
                
                const r = this.r * 1.2; 
                const points = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (i * 60 - 90) * Math.PI / 180;
                    points.push({ x: Math.cos(angle) * r, y: Math.sin(angle) * r });
                }
                
                optimizedShadow.apply(ctx, 25, shadowColor);
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                ctx.lineTo(points[2].x, points[2].y);
                ctx.lineTo(points[5].x, points[5].y);
                ctx.lineTo(points[3].x, points[3].y);
                ctx.lineTo(points[1].x, points[1].y);
                ctx.lineTo(points[4].x, points[4].y);
                ctx.lineTo(points[0].x, points[0].y);
                ctx.stroke();
                
                // Pulsing central core
                const pulse = Math.sin(game.frames * 0.1) * 0.5 + 1;
                ctx.fillStyle = "#fff";
                optimizedShadow.apply(ctx, 40 * pulse, "#fff");
                ctx.beginPath();
                ctx.arc(0, 0, 3 * pulse, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
            
            jump() {
                this.vy = CONFIG.PLAYER_JUMP_FORCE;
                for (let i = 0; i < 15; i++) {
                    const type = Math.random() > 0.7 ? 'hexagram' : 
                                Math.random() > 0.4 ? 'triangle' : 'circle';
                    game.particles.push(new Particle(
                        this.x, this.y, '#fff', 4, type
                    ));
                }
                if (game.settings.sfx) SFX.jump();
            }
        }

        class Pillar {
            constructor(lvlIndex) {
                this.x = window.innerWidth;
                this.w = CONFIG.PILLAR_WIDTH + Math.random() * 10;
                this.gap = CONFIG.PILLAR_GAP - (lvlIndex * 2);
                this.top = Math.random() * (window.innerHeight - this.gap - 100) + 50;
                this.marked = false;
                this.lvl = lvlIndex;
                this.rotation = Math.random() * Math.PI * 2;
                this.innerPattern = Math.floor(Math.random() * 3);
                this.pulse = 0;
            }
            
            update(speed) { 
                this.x -= speed; 
                this.pulse += 0.05;
                this.rotation += 0.005;
            }
            
            draw(ctx, conf) {
                const hue = (game.frames * 0.5 + this.x * 0.1) % 360;
                const mainColor = `hsl(${hue}, 100%, 60%)`;
                const innerColor = `hsl(${(hue + 60) % 360}, 100%, 70%)`;
                const glowColor = `hsl(${hue}, 100%, 50%)`;
                
                // Main pillar structure with crystalline edges
                ctx.save();
                ctx.translate(this.x + this.w/2, 0);
                
                // Outer glow
                optimizedShadow.apply(ctx, 30, glowColor);
                ctx.strokeStyle = mainColor;
                ctx.lineWidth = 4;
                ctx.fillStyle = "rgba(0,0,0,0.7)";
                
                // Draw crystalline top pillar
                const topHeight = this.top + 10;
                ctx.beginPath();
                ctx.moveTo(-this.w/2, -10);
                ctx.lineTo(this.w/2, -10);
                
                // Add jagged crystalline edge
                const jagCount = 5;
                for (let i = 0; i <= jagCount; i++) {
                    const x = this.w/2 - (i * this.w/jagCount);
                    const y = -10 + (i % 2 === 0 ? 8 : -4);
                    ctx.lineTo(x, y);
                }
                
                ctx.lineTo(-this.w/2, topHeight);
                ctx.lineTo(-this.w/2, -10);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Inner pattern for top pillar
                ctx.save();
                ctx.translate(0, topHeight/2);
                ctx.rotate(this.rotation);
                ctx.globalAlpha = 0.4;
                ctx.strokeStyle = innerColor;
                ctx.lineWidth = 1.5;
                optimizedShadow.apply(ctx, 15, innerColor);
                
                if (this.innerPattern === 0) {
                    // Hexagon pattern
                    const size = Math.min(this.w, topHeight) * 0.3;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = Math.cos(angle) * size;
                        const y = Math.sin(angle) * size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                } else if (this.innerPattern === 1) {
                    // Triangle pattern
                    const size = Math.min(this.w, topHeight) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size * 0.866, size * 0.5);
                    ctx.lineTo(-size * 0.866, size * 0.5);
                    ctx.closePath();
                    ctx.stroke();
                } else {
                    // Cross pattern
                    const size = Math.min(this.w, topHeight) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(-size, 0);
                    ctx.lineTo(size, 0);
                    ctx.moveTo(0, -size);
                    ctx.lineTo(0, size);
                    ctx.stroke();
                }
                ctx.restore();
                
                // Bottom pillar
                const botY = this.top + this.gap;
                const botHeight = window.innerHeight - botY + 10;
                
                ctx.beginPath();
                ctx.moveTo(-this.w/2, botY);
                ctx.lineTo(this.w/2, botY);
                
                // Jagged bottom edge
                for (let i = 0; i <= jagCount; i++) {
                    const x = this.w/2 - (i * this.w/jagCount);
                    const y = botY + (i % 2 === 0 ? -4 : 8);
                    ctx.lineTo(x, y);
                }
                
                ctx.lineTo(this.w/2, botY + botHeight);
                ctx.lineTo(-this.w/2, botY + botHeight);
                ctx.lineTo(-this.w/2, botY);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Inner pattern for bottom pillar
                ctx.save();
                ctx.translate(0, botY + botHeight/2);
                ctx.rotate(-this.rotation);
                ctx.globalAlpha = 0.4;
                ctx.strokeStyle = innerColor;
                ctx.lineWidth = 1.5;
                
                // Draw same pattern as top
                if (this.innerPattern === 0) {
                    const size = Math.min(this.w, botHeight) * 0.3;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = Math.cos(angle) * size;
                        const y = Math.sin(angle) * size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                } else if (this.innerPattern === 1) {
                    const size = Math.min(this.w, botHeight) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size * 0.866, size * 0.5);
                    ctx.lineTo(-size * 0.866, size * 0.5);
                    ctx.closePath();
                    ctx.stroke();
                } else {
                    const size = Math.min(this.w, botHeight) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(-size, 0);
                    ctx.lineTo(size, 0);
                    ctx.moveTo(0, -size);
                    ctx.lineTo(0, size);
                    ctx.stroke();
                }
                ctx.restore();
                
                ctx.restore();
                optimizedShadow.clear(ctx);
                ctx.globalAlpha = 1.0;
            }
        }

        class Orb {
            constructor(x, y) {
                this.x = x; 
                this.y = y; 
                this.r = 10;
                this.collected = false;
                this.float = Math.random() * Math.PI * 2;
                this.pulse = 0;
                this.rotation = 0;
            }
            
            update(speed) {
                this.x -= speed;
                this.float += 0.1;
                this.pulse += 0.15;
                this.rotation += 0.02;
                this.y += Math.sin(this.float) * 0.8;
            }
            
            draw(ctx) {
                if (this.collected) return;
                
                const pulseSize = this.r + Math.sin(this.pulse) * 3;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                // Outer glow ring
                optimizedShadow.apply(ctx, 25, '#ffd700');
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
                ctx.stroke();
                
                // Inner hexagram
                optimizedShadow.apply(ctx, 30, '#fff');
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.9;
                
                const r = pulseSize * 0.7;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i * 60) * Math.PI / 180;
                    const x = Math.cos(angle) * r;
                    const y = Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
                
                // Central core
                ctx.fillStyle = '#fff';
                optimizedShadow.apply(ctx, 40, '#fff');
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize * 0.2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
        }

        class Particle {
            constructor(x, y, c, speed, type = 'circle') {
                this.x = x; 
                this.y = y; 
                this.c = c;
                this.vx = (Math.random() - 0.5) * speed;
                this.vy = (Math.random() - 0.5) * speed;
                this.life = 1; 
                this.size = Math.random() * 4 + 2;
                this.type = type;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.2;
                this.glow = Math.random() > 0.5;
            }
            
            update() { 
                this.x += this.vx; 
                this.y += this.vy; 
                this.vx *= 0.97;
                this.vy *= 0.97;
                this.life -= 0.03; 
                this.rotation += this.rotationSpeed;
                this.size *= 0.98;
            }
            
            draw(ctx) {
                if (this.life <= 0) return;
                
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.c;
                
                if (this.glow && this.life > 0.3) {
                    optimizedShadow.apply(ctx, 20 * this.life, this.c);
                }
                
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                if (this.type === 'hexagram') {
                    const r = this.size * 0.8;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 'triangle') {
                    const r = this.size;
                    ctx.beginPath();
                    ctx.moveTo(0, -r);
                    ctx.lineTo(r * 0.866, r * 0.5);
                    ctx.lineTo(-r * 0.866, r * 0.5);
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 'diamond') {
                    const r = this.size;
                    ctx.beginPath();
                    ctx.moveTo(0, -r);
                    ctx.lineTo(r, 0);
                    ctx.lineTo(0, r);
                    ctx.lineTo(-r, 0);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    // Circle
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
                optimizedShadow.clear(ctx);
            }
        }
        
        class Star {
            constructor() {
                this.x = Math.random() * window.innerWidth;
                this.y = Math.random() * window.innerHeight;
                this.size = Math.random() * 2.5;
                this.speed = Math.random() * 0.5 + 0.1;
                this.alpha = Math.random() * 0.5 + 0.2;
                this.twinkle = Math.random() * Math.PI * 2;
            }
            update() {
                this.y += this.speed;
                if (this.y > window.innerHeight) {
                    this.y = 0; 
                    this.x = Math.random() * window.innerWidth;
                }
                this.twinkle += 0.05;
                this.alpha = 0.3 + Math.sin(this.twinkle) * 0.2;
            }
            draw(ctx) {
                const conf = game.gameLevels[game.currentLevelIdx];
                ctx.fillStyle = conf ? conf.accent : '#fff';
                ctx.globalAlpha = this.alpha;
                
                // Draw tiny cross or dot randomly
                if (Math.random() > 0.7) {
                    // Cross star
                    ctx.fillRect(this.x - this.size/2, this.y, this.size, 1);
                    ctx.fillRect(this.x, this.y - this.size/2, 1, this.size);
                } else {
                    // Dot star
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size/2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1.0;
            }
        }

        let game;
        document.addEventListener('DOMContentLoaded', () => {
            game = new Game();
        });

    </script>
</body>
</html>        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* CRT Scanline Effect */
        .scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
            opacity: 0.4;
        }
        
        /* Vignette for ominous feel */
        .vignette {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, black 130%);
            pointer-events: none;
            z-index: 11;
        }

        /* UI Overlay */
        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 20;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            transition: opacity 0.3s ease;
        }

        /* Start Screen Specifics */
        #startScreen {
            background-size: cover;
            background-position: center;
            /* Psychedelic Background Animation */
            animation: bgBreath 10s infinite alternate; 
        }
        
        /* Dark overlay to make text pop on top of image */
        #startScreen::before {
            content: '';
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: -1;
        }

        @keyframes bgBreath {
            0% { transform: scale(1); filter: hue-rotate(0deg); }
            100% { transform: scale(1.05); filter: hue-rotate(45deg); }
        }

        .hidden {
            opacity: 0 !important;
            pointer-events: none !important;
        }

        /* Neon Buttons */
        .mystic-btn {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--primary);
            color: #fff;
            padding: 15px 50px;
            font-size: 1.2rem;
            font-family: 'Cinzel Decorative', cursive; /* Thelemic Font */
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 4px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 15px var(--primary), inset 0 0 10px var(--primary);
            margin: 15px;
            min-width: 260px;
            position: relative;
            overflow: hidden;
            text-shadow: 0 0 5px #fff;
            
            /* Rainbow Glow Pulse */
            animation: psychedelicBorder 4s infinite linear;
        }

        @keyframes psychedelicBorder {
            0% { border-color: #ff003c; box-shadow: 0 0 15px #ff003c; }
            25% { border-color: #ff00ff; box-shadow: 0 0 15px #ff00ff; }
            50% { border-color: #00ffff; box-shadow: 0 0 15px #00ffff; }
            75% { border-color: #ffd700; box-shadow: 0 0 15px #ffd700; }
            100% { border-color: #ff003c; box-shadow: 0 0 15px #ff003c; }
        }

        .mystic-btn:hover {
            background: #fff;
            color: #000;
            transform: scale(1.05);
            text-shadow: none;
        }

        .mystic-btn:active {
            transform: scale(0.95);
        }

        .title-text {
            font-family: 'Cinzel Decorative', cursive;
            font-size: 5rem;
            color: #fff;
            text-shadow: 0 0 10px var(--primary);
            margin-bottom: 10px;
            letter-spacing: -2px;
            animation: pulseNeon 3s infinite alternate;
        }

        @keyframes pulseNeon {
            0% { text-shadow: 0 0 10px var(--primary), 0 0 20px var(--primary); opacity: 1; }
            100% { text-shadow: 0 0 20px var(--primary), 0 0 40px var(--primary), 0 0 80px var(--primary); opacity: 0.9; }
        }

        .level-indicator {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            font-size: 1.5rem;
            font-family: 'Cinzel Decorative', serif;
            font-weight: 700;
            letter-spacing: 6px;
            color: #fff;
            z-index: 15;
            text-shadow: 0 0 10px #000;
            text-transform: uppercase;
        }

        .score-display {
            position: absolute;
            top: 10%;
            width: 100%;
            text-align: center;
            font-size: 9rem;
            font-family: 'Cinzel Decorative', serif;
            color: rgba(255, 255, 255, 0.1);
            z-index: 5;
            pointer-events: none;
            mix-blend-mode: screen;
            font-weight: 900;
        }

        .progress-bar {
            width: 300px;
            height: 4px;
            background: #222;
            margin: 20px 0;
            position: relative;
            box-shadow: 0 0 10px #000;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width 0.2s ease;
            box-shadow: 0 0 15px var(--primary);
        }

        .instructions {
            position: absolute;
            bottom: 100px;
            width: 100%;
            text-align: center;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 3px;
            z-index: 15;
            font-family: 'Orbitron', sans-serif;
            
            /* FADE OUT ANIMATION */
            animation: fadeOut 5s ease-in-out forwards;
            animation-delay: 2s; /* Wait 2 seconds before fading */
            pointer-events: none;
        }

        @keyframes fadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; visibility: hidden; }
        }

        .pause-btn {
            position: absolute;
            top: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--primary);
            color: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            z-index: 25;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            pointer-events: auto;
            box-shadow: 0 0 10px var(--primary);
            transition: 0.3s;
        }
        
        .pause-btn:hover {
            background: var(--primary);
            color: #000;
            box-shadow: 0 0 20px var(--primary);
        }

        .stats-panel {
            position: absolute;
            top: 30px;
            left: 30px;
            background: rgba(0, 0, 0, 0.7);
            border-left: 3px solid var(--primary);
            padding: 10px 15px;
            font-size: 0.8rem;
            color: #ccc;
            z-index: 25;
            pointer-events: auto;
            font-family: 'Orbitron', monospace;
            text-align: left;
            backdrop-filter: blur(4px);
        }
        
        /* Custom File Upload Styling */
        .file-upload-label {
            display: inline-block;
            margin-top: 20px;
            padding: 10px 20px;
            border: 1px dashed #666;
            color: #888;
            cursor: pointer;
            font-size: 0.8rem;
            transition: 0.3s;
            font-family: 'Orbitron', sans-serif;
        }
        .file-upload-label:hover {
            border-color: var(--primary);
            color: var(--primary);
            box-shadow: 0 0 10px rgba(255, 0, 60, 0.2);
        }

        @media(max-width: 600px) {
            .title-text { font-size: 3.5rem; }
            .score-display { font-size: 6rem; }
            .mystic-btn { 
                padding: 12px 30px; 
                font-size: 1rem;
                min-width: 200px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="scanlines"></div>
        <div class="vignette"></div>
        
        <div id="scoreUi" class="score-display">0</div>
        <div id="levelUi" class="level-indicator">INITIATION</div>
        
        <!-- Start Screen with Background Image -->
        <div id="startScreen" class="ui-layer" style="background-image: url('https://lh3.googleusercontent.com/d/1BXrXXd9TKSqCFNwvS-cJpNORbyvP6fkR=s0');">
            <h1 class="title-text">Sex Magick</h1>
            <p style="letter-spacing: 8px; color: #ff003c; margin-bottom: 40px; font-size: 1.1rem; text-shadow: 0 0 10px #ff003c; font-family: 'Cinzel Decorative', cursive;">Do Your Will Foo</p>
            
            <div id="loadingMsg">
                <div class="loader"></div>
                <p style="letter-spacing: 4px; font-size: 0.9rem; margin-top: 15px; font-family: 'Cinzel Decorative';">CHARGING SIGIL...</p>
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill"></div>
                </div>
            </div>

            <div id="menuButtons" class="hidden">
                <button id="startBtn" class="mystic-btn">INVOKE</button>
                <button id="settingsBtn" class="mystic-btn">RITES</button>
                
                <label for="fileUpload" class="file-upload-label">
                    [ OPTIONAL: LOAD LOCAL MP3 ]
                </label>
                <input type="file" id="fileUpload" accept="audio/*" style="display:none;">
                <p id="trackName" style="margin-top: 5px; font-size: 0.6rem; color: #555;">SOURCE: GITHUB CDN</p>
            </div>
        </div>

        <div id="gameOverScreen" class="ui-layer hidden" style="background: rgba(0,0,0,0.85);">
            <h1 class="title-text" style="color: #ff003c; font-size: 4rem;">ABORTED</h1>
            <p style="font-size: 1.2rem; letter-spacing: 4px; margin-bottom: 20px; font-family: 'Cinzel Decorative';">RITUAL FAILED</p>
            <p class="text-xl mb-6 text-gray-300">WILL: <span id="finalScore" style="color: #fff; font-weight:bold; text-shadow: 0 0 10px #fff;">0</span></p>
            <p id="highScoreMsg" style="color: #ffd700; margin-bottom: 30px; font-size: 1rem; letter-spacing: 2px;"></p>
            <button id="restartBtn" class="mystic-btn">REINCARNATE</button>
        </div>

        <div id="pauseScreen" class="ui-layer hidden">
            <h1 class="title-text" style="font-size: 3.5rem; color: #ffd700;">MEDITATION</h1>
            <button id="resumeBtn" class="mystic-btn">RESUME</button>
            <button id="menuBtn" class="mystic-btn">ABORT</button>
        </div>

        <div id="settingsScreen" class="ui-layer hidden" style="background: rgba(0,0,0,0.9);">
            <h1 class="title-text" style="font-size: 2.5rem;">SACRED RITES</h1>
            <div style="width: 320px; margin: 20px 0; background: rgba(20,20,20,0.8); padding: 20px; border: 1px solid var(--primary);">
                <div style="display: flex; justify-content: space-between; margin: 15px 0; border-bottom: 1px solid #444; padding-bottom: 10px;">
                    <span>CHANT (MUSIC)</span>
                    <input type="checkbox" id="musicToggle" checked style="accent-color: var(--primary);">
                </div>
                <div style="display: flex; justify-content: space-between; margin: 15px 0; border-bottom: 1px solid #444; padding-bottom: 10px;">
                    <span>RESONANCE (SFX)</span>
                    <input type="checkbox" id="sfxToggle" checked style="accent-color: var(--primary);">
                </div>
                <div style="display: flex; justify-content: space-between; margin: 15px 0;">
                    <span>KUNDALINI (VIBE)</span>
                    <input type="checkbox" id="vibrationToggle" checked style="accent-color: var(--primary);">
                </div>
            </div>
            <button id="backBtn" class="mystic-btn">RETURN</button>
        </div>

        <button id="pauseBtn" class="pause-btn hidden">||</button>
        
        <div id="statsPanel" class="stats-panel">
            <div style="color: var(--primary); font-weight: bold; margin-bottom: 5px;">:: GNOSIS ::</div>
            FPS: <span id="fpsCounter" style="color: #fff;">0</span><br>
            AUDIO: <span id="audioStatus" style="color: #fff;">STANDBY</span>
        </div>

        <div id="instructions" class="instructions hidden">
            [ TAP / SPACE TO ASCEND ]
        </div>
    </div>

    <script>
        // High-Speed CDN Prefix
        const CDN_PREFIX = "https://cdn.jsdelivr.net/gh/bookthief666/93-protocol-game-assets-@662f3d608769e9e945295ac00d668447d974dc5c/";

        const CONFIG = {
            DEBUG: true, 
            // MENU MUSIC: "The Zelda Song" (Ready to play on first click)
            MENU_MUSIC: CDN_PREFIX + "iamerror%20-%20The%20Zelda%20Song%20(Hyr00l).mp3",
            
            // GAMEPLAY PLAYLIST (All 7 songs) - CDN Links
            GAME_PLAYLIST: [
                CDN_PREFIX + "iamerror%20-%20Hyr00l%20Rough.mp4",
                CDN_PREFIX + "bookthief%F0%9F%A5%80%20-%20booothief-%20All%20gay%F0%9F%98%87%202024-07-10%2001_11%20(1).m4a",
                CDN_PREFIX + "Vae!%20Puto%20Deus%20Fio!%20(3).mp3",
                CDN_PREFIX + "IAMERROR%20-%20The%20Iceclops%20Cometh.mp3",
                CDN_PREFIX + "Forest%20of%20Fellatio%20%5BTTn3kjGwXi0%5D.mp3",
                CDN_PREFIX + "LEX_LFL_80_wurli_loop_ate_bit_Cm.wav",
                CDN_PREFIX + "iamerror%20-%20The%20Zelda%20Song%20(Hyr00l).mp3"
            ],
            
            BASE_URL: "https://lh3.googleusercontent.com/d/",
            IMG_SUFFIX: "=s0",
            INITIAL_GAME_SPEED: 3.5,
            SPEED_INCREASE_PER_LEVEL: 0.2,
            PILLAR_SPAWN_RATE: 100, // frames
            PILLAR_WIDTH: 55,
            PILLAR_GAP: 220,
            ORB_SPAWN_CHANCE: 0.3,
            PLAYER_JUMP_FORCE: -5.8,
            GRAVITY: 0.25
        };

        // --- THELEMIC & ALCHEMICAL LEVEL NAMES (No Numbers) ---
        // Replacing numbered levels with thematic names
        const originalLevels = [
            { name: "MALKUTH", id: "1jI7bl3hsVOuzYf6u35L4bhHq5JUiBDa1" },
            { name: "YESOD", id: "1tHgxNvDO5md4z24hS81eTa9uva25mtr5" },
            { name: "HOD", id: "1Mtp6cP6lwGbPRhLWjQKKDijrLX53K4UR" },
            { name: "NETZACH", id: "1y1i5lxL1jVp37bIz1mtJh4-Puce-E5k0" },
            { name: "TIPHARETH", id: "12png0vOPyJC1Ab4Vffcw2R_K-yRw1sqj" },
            { name: "GEBURAH", id: "1le2Hox1ORxhL28fv7WujO0410vM6jUEJ" },
            { name: "CHESED", id: "1Gsq1xSx9ivfVEq6W2nCMrO-dOIMrSYrW" },
            { name: "DA'ATH", id: "1o601hrLi5RpuGL_kiVEoPXxXk2SCbM2z" },
            { name: "BINAH", id: "1iSYJfPsaYjA1rmRTsujLcn1Do-lBydF7" },
            { name: "CHOKMAH", id: "1PvOC62nv5HdsE1cuCF8RENY9Z8HTabn7" },
            { name: "KETHER", id: "1Ym_eyrXJEQUBA7Lg_2oUc6dQ-gy9yfGs" }
        ];

        const newImageIDs = [
            "1pJ5CUGyKXgkSgEREkKos1Kch5FmfUyxE", "1spT4HpO_4q9joE4x6bLjZQRlFTS9j-ie", "1YGzyjcjiCoPCLbYjJEiqT8USUhe4S6hM", "1ELjoJU7KDC88nUk_Vs57OKUG9oLl5E8N",
            "1faa2c3QFWhZ8UgvyZ_ZrlnyFsnsKRclm", "10W5oYkoqB9LC3YjvB_aozR0kG3hWaHka", "1l9Jdm0EQh8sgWh1W0wsXQCzrQM19Bfm9", "1BrHTF2dvfbRkyYfXAbPUiujwE1AJskY4",
            "1KqV8IYF7KDbmgHS3ph6eRQKl4uAAFG_u", "1sZ02UH_vb1xLaOvyETqptc5FuvOtVKd4", "1hLKOGYXCBemcIKt8OLEX4dHTn6bd88cr", "1g_DQeG6qldMBxHzZ82MOVoxk9APwb4NO",
            "1-SIvE5EZyUd7FKXJ7eyB4JCrtOpQoF18", "1S4y4YSCjxSb-b_U1BfMw_0PhabJ-METm", "1OL-kWl-TJNcZFPcsCAtynW2NWp-YYjGd", "1ApPgou40N2Q6GlNKNuyoQ2Gk5DqAfmw_",
            "1OeH1GMu2rDcwzdtWFZSB1WWe0OjkmxV0", "12Z92v9Mu9yNOnDTtK-bjMRZ8_2BAW2eW", "1Erf3DKxZpfbG57oGcUCjuHIhajsweLZz", "1qK22CJhJ1XgElL156uOQxYrucaRG16p0",
            "1euwdAWg-xQw7isR-JAiZ-krXQXOS8pi0", "1A3hT3mJibINtsr8CVxTmp71QsYgPB2JZ", "1QUVr-RK2kP7IIAuy0wX3pOZRQuyr-o-e", "1eF02YMyYBcgx7Ga20pXgoltzWXPYznfD",
            "1zx1vrrbuSA4xCFKXAHgXbkG1rX8PUPel", "1ds1iqXf90gy9PUFs80t4QOxamkJj0u1I", "14-t6dPPv5MeXe7LWPIp7Tjc8x4w5Vj2d", "1pUtIizMzVhjzB46dhah5mgz6Tr-vaSLO",
            "1ZOEkUW8q2s5zerS7BubYJU69RHk7_Zlo", "15ZHj0fLYu-4rEQy43BMJKDgXnnQ5FeyP", "1ZzgVT0O6XQzW3DUP4i1aoKd_DD5wV5LZ", "1rZHZM0bR_j6uiYZLS82J0BkbIfEUoXvY",
            "1CNrQ_EeMXQgHJGXxe7EHysQi_A0A9UE7", "1ubCqIg7ETOIsHGfBjQfVsRzjlZIpBP6E", "1pojzjR-uiQ0oTHRJxXXCW_w0hlJUCqyb", "1SnclBlH6sflhaTWzFhbcNedzNeh25-BV",
            "1thfc-9DnM4GhCi0zTbcX4MH-yaQEpomX", "1BXrXXd9TKSqCFNwvS-cJpNORbyvP6fkR", "1D1bOksatIt6Jw6Zq8Sbmhbq_GC_2EQHh", "1eP_Xnk80YnL3w3Q69wQmVo9_F0OaA3Wo",
            "1ARDOipcr0lB1GYf3gmhqlHXlpC23Q2JE", "1io39jfggXQl-OyvSFGIpgOtoIzHbml3M", "1o0rJmx3vEKITMx1ixP5iruOX2ujOT6VO", "1Irw61utgSGdip21OgTcYqz56LpWWS9fb",
            "19V2ObVoQn9R9bt1ZgMNEBJokaAjYdX_9", "1WWvLnkkPBN7Q0ZsGi16FL1anhPlti3Qd", "1HoYqC0SLc3nrSDnoW9KJ2-z8AnRWIz5M", "1oS0J3F-zh5H48-Qs5Mrm10dPR993kF-b",
            "1bRwsBEuZiAIZW_5f3WOZVI6-KVnCEslk", "1GLza2_RmR4c_KD_KGxbXPOoCAw9SITKl", "1uWFSChozQmHEnuJwXqiPNApXuAwPAzKS", "1t2hNBEudzIo19kuP8ksPY_cNetDdTd8P",
            "1KhMBL7a3NSggVerbyy53fQ-dLq11adwj", "1wgxalTR68YM7oIku8JYZYKtG50atEnG_", "1BceMgnHgVn9U_7EYnXQu9HDwEQY1UBa_", "14_iwYDQjp34-R_iby8QadKnI9m3zVnOu",
            "1cZ_ci9J80jnqCAdag8SQofYZw1dfsX3C", "15z3bGrCqUy8SQjX1dO5C1vlN3y4-soai", "10xAFw98B39Ou0SSeB4eWyoY2D_OLLPgz", "1CexZQw11p33u1-YA7JhPAkGV6NBCgd6e",
            "16t1EdHfHRpb7GmqNAfo2iKKm57qLfbKn", "12wQOhUztVCVEFV21fPDq-JXGi5zxdkeQ", "1-0u9JUH0oUHD1--5iaySxRpO_PuyxkH6", "1wnITY3i6XxOr1b3l6P0cT10LkEHQauO5"
        ].filter((value, index, self) => self.indexOf(value) === index);

        // THELEMIC & ALCHEMICAL THEMES (Expanded & Randomized)
        const esotericNames = [
            "KUNDALINI", "HIEROS GAMOS", "SACRED UNION", "RED TINCTURE", "WHITE GLUTEN", 
            "CUP OF BABALON", "BLOOD OF SAINTS", "CITY OF PYRAMIDS", "NIGHT OF PAN", 
            "HADIT'S FLAME", "NUIT'S EMBRACE", "LAW OF THELEMA", "LOVE UNDER WILL", 
            "GREAT WORK", "STONE OF WISE", "ELIXIR OF LIFE", "RED LION", "WHITE EAGLE",
            "ABRAHADABRA", "LASHTAL", "KA", "BA", "KHU", "SCARLET WOMAN", "THE BEAST",
            "AEON OF HORUS", "93", "AGAPE", "THELEMA", "VIA OVUM", "SPERMATOZOON",
            "HOMUNCULUS", "DIVINE EROS", "TANTRA", "YONI", "LINGAM", "O.T.O.", "A.'.A.'.",
            "STAR SAPPHIRE", "MASS OF PHOENIX", "LIBER AL", "RESH", "SAMEKH", "TZADDI"
        ];

        let MASTER_POOL = [...originalLevels];
        
        // Updated Neon Palette
        const palette = ["#ff003c", "#ff00ff", "#9d00ff", "#00f0ff", "#00ff9d", "#d4ff00", "#ff8800"];

        newImageIDs.forEach((id, index) => {
            const nameIndex = index % esotericNames.length;
            MASTER_POOL.push({
                name: esotericNames[nameIndex],
                id: id,
                color: "#000",
                accent: palette[index % palette.length],
                img: null,
                loaded: false
            });
        });

        const GameState = {
            START: 'start',
            LOADING: 'loading',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAME_OVER: 'gameover',
            SETTINGS: 'settings'
        };

        const AudioSys = {
            bgm: null,
            localBlobUrl: null,
            currentMode: 'none', 
            retryCount: 0,
            
            setStatus(msg) {
                const el = document.getElementById('audioStatus');
                if (el) {
                    el.textContent = msg;
                    el.style.color = '#fff';
                    setTimeout(() => el.style.color = 'var(--primary)', 200);
                }
            },

            init() {
                // Initialize in "Menu Mode" but don't play until interaction
                this.setupAudioElement(CONFIG.MENU_MUSIC);
                this.currentMode = 'menu';
                this.setStatus("MENU AUDIO RDY");
                
                // Manual Start Only - No Auto Play
            },

            setupAudioElement(src) {
                if (this.bgm) {
                    this.bgm.pause();
                    this.bgm.src = "";
                    this.bgm.load();
                }
                this.bgm = new Audio();
                
                this.bgm.src = src;
                this.bgm.loop = true;
                this.bgm.volume = 0.8;
                this.bgm.preload = "auto";
                
                this.bgm.onwaiting = () => this.setStatus("BUFFERING...");
                this.bgm.onplaying = () => {
                    this.setStatus("PLAYING");
                    this.retryCount = 0; // Reset retries on success
                };
                
                this.bgm.onerror = (e) => {
                    const err = this.bgm.error;
                    console.warn("Audio error:", err);
                    this.setStatus("LOAD ERROR");
                    // No Auto-Skip
                };
            },

            loadLocalFile(file) {
                if (this.localBlobUrl) URL.revokeObjectURL(this.localBlobUrl);
                this.localBlobUrl = URL.createObjectURL(file);
                this.setupAudioElement(this.localBlobUrl);
                this.setStatus("FILE LOADED");
            },
            
            switchToGameMusic() {
                if (this.localBlobUrl) return; 
                
                const randomIndex = Math.floor(Math.random() * CONFIG.GAME_PLAYLIST.length);
                const track = CONFIG.GAME_PLAYLIST[randomIndex];
                
                this.currentMode = 'game';
                this.setStatus("LOADING TRK " + (randomIndex + 1));
                this.setupAudioElement(track);
                this.play();
            },

            switchToMenuMusic() {
                if (this.localBlobUrl) return;

                this.currentMode = 'menu';
                this.setStatus("LOADING MENU");
                this.setupAudioElement(CONFIG.MENU_MUSIC);
                // Do not auto-play menu music per request
            },
            
            play() {
                if (!this.bgm) return;
                const playPromise = this.bgm.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => this.setStatus("PLAYING")).catch(error => {
                        console.warn("Play failed:", error);
                        this.setStatus("AUTOPLAY BLOCK");
                    });
                }
            },
            
            pause() { if (this.bgm) { this.bgm.pause(); this.setStatus("PAUSED"); } },
            resume() { if (this.bgm && this.bgm.paused) { this.bgm.play(); this.setStatus("RESUMED"); } },
            stop() { if (this.bgm) { this.bgm.pause(); this.bgm.currentTime = 0; this.setStatus("STOPPED"); } }
        };

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.root = document.documentElement;
                
                this.state = GameState.START;
                this.currentLevelIdx = 0;
                this.frames = 0;
                this.score = 0;
                this.highScore = localStorage.getItem('93protocol_highscore') || 0;
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED;
                this.shake = 0;
                this.lastFrameTime = 0;
                this.fps = 0;
                
                this.player = null;
                this.particles = [];
                this.stars = [];
                this.obstacles = [];
                this.collectibles = [];
                this.gameLevels = []; 
                
                this.settings = { music: true, sfx: true, vibration: true };
                
                this.loadSettings();
                this.initEventListeners();
                this.resizeCanvas();
                this.preloadAllImages();
                
                AudioSys.init();
            }
            
            initEventListeners() {
                document.getElementById('fileUpload').addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) AudioSys.loadLocalFile(file);
                });

                window.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && this.state === GameState.PLAYING) this.playerJump();
                    else if (e.code === 'Escape') this.togglePause();
                });
                
                window.addEventListener('mousedown', (e) => {
                    if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'LABEL' && this.state === GameState.PLAYING) this.playerJump();
                });
                
                window.addEventListener('touchstart', (e) => {
                    if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'LABEL' && this.state === GameState.PLAYING) {
                        e.preventDefault();
                        this.playerJump();
                    }
                }, { passive: false });
                
                document.getElementById('startBtn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (this.settings.music) AudioSys.switchToGameMusic();
                    this.startGame();
                });
                
                document.getElementById('restartBtn').addEventListener('click', (e) => {
                     e.stopPropagation();
                     if (this.settings.music) AudioSys.switchToGameMusic();
                     this.restartGame();
                });
                
                document.getElementById('pauseBtn').addEventListener('click', (e) => { e.stopPropagation(); this.togglePause(); });
                document.getElementById('resumeBtn').addEventListener('click', (e) => { e.stopPropagation(); this.togglePause(); });
                document.getElementById('menuBtn').addEventListener('click', (e) => { e.stopPropagation(); this.returnToMenu(); });
                document.getElementById('settingsBtn').addEventListener('click', (e) => { e.stopPropagation(); this.showSettings(); });
                document.getElementById('backBtn').addEventListener('click', (e) => { e.stopPropagation(); this.hideSettings(); });
                
                document.getElementById('musicToggle').addEventListener('change', (e) => {
                    this.settings.music = e.target.checked;
                    this.saveSettings();
                    if (!this.settings.music) AudioSys.stop();
                    else if (this.state === GameState.PLAYING) AudioSys.play();
                });
                
                document.getElementById('sfxToggle').addEventListener('change', (e) => {
                    this.settings.sfx = e.target.checked;
                    this.saveSettings();
                });
                
                document.getElementById('vibrationToggle').addEventListener('change', (e) => {
                    this.settings.vibration = e.target.checked;
                    this.saveSettings();
                });
                
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            loadSettings() {
                const saved = localStorage.getItem('93protocol_settings');
                if (saved) this.settings = { ...this.settings, ...JSON.parse(saved) };
                document.getElementById('musicToggle').checked = this.settings.music;
                document.getElementById('sfxToggle').checked = this.settings.sfx;
                document.getElementById('vibrationToggle').checked = this.settings.vibration;
            }
            
            saveSettings() { localStorage.setItem('93protocol_settings', JSON.stringify(this.settings)); }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }
            
            preloadAllImages() {
                const progressFill = document.getElementById('progressFill');
                let loadedCount = 0;
                
                MASTER_POOL.forEach(lvl => {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.onload = () => {
                        lvl.img = img;
                        lvl.loaded = true;
                        loadedCount++;
                        progressFill.style.width = `${(loadedCount / MASTER_POOL.length) * 100}%`;
                        if (loadedCount >= MASTER_POOL.length) this.finishLoading();
                    };
                    img.onerror = () => {
                        lvl.loaded = false;
                        loadedCount++;
                        progressFill.style.width = `${(loadedCount / MASTER_POOL.length) * 100}%`;
                        if (loadedCount >= MASTER_POOL.length) this.finishLoading();
                    };
                    img.src = CONFIG.BASE_URL + lvl.id + CONFIG.IMG_SUFFIX;
                });
            }
            
            finishLoading() {
                setTimeout(() => {
                    document.getElementById('loadingMsg').classList.add('hidden');
                    document.getElementById('menuButtons').classList.remove('hidden');
                }, 500);
            }
            
            prepareLevels() {
                let shuffled = [...MASTER_POOL];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                this.gameLevels = shuffled.map((lvl, index) => {
                    return { ...lvl, threshold: index * 5 };
                });
            }

            startGame() {
                this.prepareLevels();
                this.state = GameState.PLAYING;
                document.getElementById('startScreen').classList.add('hidden');
                document.getElementById('scoreUi').classList.remove('hidden');
                document.getElementById('pauseBtn').classList.remove('hidden');
                document.getElementById('instructions').classList.remove('hidden');
                if (CONFIG.DEBUG) document.getElementById('statsPanel').classList.remove('hidden');
                this.initGame();
                this.gameLoop();
            }
            
            initGame() {
                this.player = new Player();
                this.obstacles = [];
                this.collectibles = [];
                this.particles = [];
                this.stars = [];
                for (let i = 0; i < 50; i++) this.stars.push(new Star());
                this.score = 0;
                this.currentLevelIdx = 0;
                this.frames = 0;
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED;
                this.shake = 0;
                document.getElementById('scoreUi').innerText = "0";
                this.applyLevel();
            }
            
            applyLevel() {
                if (this.currentLevelIdx >= this.gameLevels.length) return;
                const l = this.gameLevels[this.currentLevelIdx];
                document.getElementById('levelUi').innerText = l.name;
                document.getElementById('levelUi').style.color = l.accent;
                document.getElementById('levelUi').style.textShadow = `0 0 15px ${l.accent}`;
                this.root.style.setProperty('--primary', l.accent);
                this.gameSpeed = CONFIG.INITIAL_GAME_SPEED + (this.currentLevelIdx * CONFIG.SPEED_INCREASE_PER_LEVEL);
            }
            
            checkLevel() {
                const nextIdx = this.currentLevelIdx + 1;
                if (nextIdx >= this.gameLevels.length) return;
                const next = this.gameLevels[nextIdx];
                if (this.score >= next.threshold) {
                    this.currentLevelIdx++;
                    this.applyLevel();
                    this.shake = 15;
                    for (let i = 0; i < 20; i++) {
                        this.particles.push(new Particle(
                            this.canvas.width / 2, this.canvas.height / 2, 
                            this.gameLevels[this.currentLevelIdx].accent, 15
                        ));
                    }
                    if (this.settings.vibration && navigator.vibrate) navigator.vibrate([50, 20, 50]);
                }
            }
            
            playerJump() {
                if (this.state === GameState.PLAYING) {
                    this.player.jump();
                    if (this.settings.vibration && navigator.vibrate) navigator.vibrate(20);
                }
            }
            
            togglePause() {
                if (this.state === GameState.PLAYING) {
                    this.state = GameState.PAUSED;
                    document.getElementById('pauseScreen').classList.remove('hidden');
                    AudioSys.pause();
                } else if (this.state === GameState.PAUSED) {
                    this.state = GameState.PLAYING;
                    document.getElementById('pauseScreen').classList.add('hidden');
                    AudioSys.resume();
                    this.gameLoop();
                }
            }
            
            showSettings() {
                document.getElementById('startScreen').classList.add('hidden');
                document.getElementById('settingsScreen').classList.remove('hidden');
                this.state = GameState.SETTINGS;
            }
            
            hideSettings() {
                document.getElementById('settingsScreen').classList.add('hidden');
                document.getElementById('startScreen').classList.remove('hidden');
                this.state = GameState.START;
            }
            
            returnToMenu() {
                this.state = GameState.START;
                document.getElementById('pauseScreen').classList.add('hidden');
                document.getElementById('startScreen').classList.remove('hidden');
                document.getElementById('scoreUi').classList.add('hidden');
                document.getElementById('pauseBtn').classList.add('hidden');
                document.getElementById('instructions').classList.add('hidden');
                document.getElementById('statsPanel').classList.add('hidden');
                if (this.settings.music) AudioSys.switchToMenuMusic();
            }
            
            gameOver() {
                if (this.state === GameState.GAME_OVER) return;
                this.state = GameState.GAME_OVER;
                this.shake = 20;
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('93protocol_highscore', this.highScore);
                    document.getElementById('highScoreMsg').textContent = "NEW GNOSIS ATTAINED!";
                } else {
                    document.getElementById('highScoreMsg').textContent = `HIGHEST ASCENSION: ${this.highScore}`;
                }
                AudioSys.stop();
                document.getElementById('finalScore').innerText = this.score;
                document.getElementById('scoreUi').classList.add('hidden');
                document.getElementById('pauseBtn').classList.add('hidden');
                document.getElementById('instructions').classList.add('hidden');
                document.getElementById('statsPanel').classList.add('hidden');
                document.getElementById('gameOverScreen').classList.remove('hidden');
                if (this.settings.vibration && navigator.vibrate) navigator.vibrate(200);
            }
            
            restartGame() {
                this.state = GameState.PLAYING;
                this.prepareLevels();
                document.getElementById('gameOverScreen').classList.add('hidden');
                document.getElementById('scoreUi').classList.remove('hidden');
                document.getElementById('pauseBtn').classList.remove('hidden');
                document.getElementById('instructions').classList.remove('hidden');
                if (CONFIG.DEBUG) document.getElementById('statsPanel').classList.remove('hidden');
                this.initGame();
                this.gameLoop();
            }
            
            gameLoop(currentTime = 0) {
                if (this.state !== GameState.PLAYING) return;
                if (this.lastFrameTime) {
                    this.fps = Math.round(1000 / (currentTime - this.lastFrameTime));
                    if (CONFIG.DEBUG) document.getElementById('fpsCounter').textContent = this.fps;
                }
                this.lastFrameTime = currentTime;
                this.frames++;
                const lvl = this.gameLevels[this.currentLevelIdx];
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawBackground(lvl);
                this.ctx.save();
                if (this.shake > 0) {
                    this.ctx.translate((Math.random() - 0.5) * this.shake, (Math.random() - 0.5) * this.shake);
                    this.shake *= 0.9;
                }
                this.updateGameObjects();
                this.drawGameObjects();
                this.ctx.restore();
                requestAnimationFrame((time) => this.gameLoop(time));
            }
            
            drawBackground(lvl) {
                // Draw Grid Effect first
                const time = this.frames * 0.5;
                this.ctx.strokeStyle = lvl.accent;
                this.ctx.lineWidth = 1;
                this.ctx.globalAlpha = 0.2;
                this.ctx.beginPath();
                
                // Floor grid
                const horizon = this.canvas.height * 0.75;
                const centerX = this.canvas.width / 2;
                
                // Perspective lines
                for (let i = -10; i <= 10; i++) {
                    const x = centerX + (i * 200);
                    this.ctx.moveTo(centerX, horizon - 50);
                    this.ctx.lineTo(x, this.canvas.height);
                }
                
                // Horizontal lines moving
                const offset = time % 50;
                for (let y = horizon; y < this.canvas.height; y += 25) {
                    const yPos = y + offset;
                    if (yPos > this.canvas.height) continue;
                    this.ctx.moveTo(0, yPos);
                    this.ctx.lineTo(this.canvas.width, yPos);
                }
                this.ctx.stroke();
                
                // Image Background with high visibility
                this.ctx.globalAlpha = 0.85; 
                if (lvl.loaded && lvl.img && lvl.img.complete) {
                    try {
                        const img = lvl.img;
                        const scale = Math.max(this.canvas.width / img.width, this.canvas.height / img.height);
                        const w = img.width * scale;
                        const h = img.height * scale;
                        const x = (this.canvas.width - w) / 2;
                        const y = (this.canvas.height - h) / 2;
                        this.ctx.drawImage(img, x, y, w, h);
                    } catch (e) {}
                }
                this.ctx.globalAlpha = 1.0;

                // Moving Stars
                this.stars.forEach(s => {
                    s.update();
                    s.draw(this.ctx);
                });
            }
            
            updateGameObjects() {
                if (this.frames % CONFIG.PILLAR_SPAWN_RATE === 0) {
                    const p = new Pillar(this.currentLevelIdx);
                    this.obstacles.push(p);
                    if (Math.random() > (1 - CONFIG.ORB_SPAWN_CHANCE)) {
                        this.collectibles.push(new Orb(p.x + p.w / 2, p.top + p.gap / 2));
                    }
                }
                this.obstacles.forEach((o, i) => {
                    o.update(this.gameSpeed);
                    let pL = this.player.x - this.player.r + 4;
                    let pR = this.player.x + this.player.r - 4;
                    let pT = this.player.y - this.player.r + 4;
                    let pB = this.player.y + this.player.r - 4;
                    let hTop = (pR > o.x && pL < o.x + o.w && pT < o.top);
                    let hBot = (pR > o.x && pL < o.x + o.w && pB > o.top + o.gap);
                    if (hTop || hBot) this.gameOver();
                    if (!o.marked && o.x + o.w < this.player.x) {
                        this.score++;
                        o.marked = true;
                        document.getElementById('scoreUi').innerText = this.score;
                        this.checkLevel();
                    }
                    if (o.x < -100) this.obstacles.splice(i, 1);
                });
                this.collectibles.forEach((c, i) => {
                    c.update(this.gameSpeed);
                    const dist = Math.hypot(this.player.x - c.x, this.player.y - c.y);
                    if (dist < this.player.r + c.r && !c.collected) {
                        this.score += 2;
                        document.getElementById('scoreUi').innerText = this.score;
                        c.collected = true;
                        for (let k = 0; k < 8; k++) this.particles.push(new Particle(c.x, c.y, '#fff', 6));
                        this.collectibles.splice(i, 1);
                        this.checkLevel();
                    }
                    if (c.x < -50) this.collectibles.splice(i, 1);
                });
                this.player.update();
                this.particles.forEach((p, i) => {
                    p.update();
                    if (p.life <= 0) this.particles.splice(i, 1);
                });
            }
            
            drawGameObjects() {
                const currentLvlConfig = this.gameLevels[this.currentLevelIdx];
                this.obstacles.forEach(o => o.draw(this.ctx, currentLvlConfig));
                this.collectibles.forEach(c => c.draw(this.ctx));
                this.player.draw(this.ctx, currentLvlConfig);
                this.particles.forEach(p => p.draw(this.ctx));
            }
        }

        class Player {
            constructor() {
                this.x = window.innerWidth * 0.25;
                this.y = window.innerHeight / 2;
                this.vy = 0;
                this.r = 16;
                this.rot = 0;
                this.trail = [];
            }
            
            update() {
                this.vy += CONFIG.GRAVITY;
                this.y += this.vy;
                this.rot += 0.03;
                if (this.y > window.innerHeight - this.r) game.gameOver();
                if (this.y < this.r) { this.y = this.r; this.vy = 0; }
                if (game.frames % 2 === 0) {
                    this.trail.unshift({x: this.x, y: this.y, r: this.r, life: 1.0});
                    if (this.trail.length > 8) this.trail.pop();
                }
            }
            
            draw(ctx, conf) {
                // Rainbow Cycle
                const hue = (game.frames * 2) % 360;
                const strokeColor = `hsl(${hue}, 100%, 60%)`;
                const shadowColor = `hsl(${hue}, 100%, 50%)`;

                // Glowing Trail
                this.trail.forEach((t, i) => {
                    t.life -= 0.1;
                    if (t.life > 0) {
                        ctx.beginPath();
                        ctx.arc(t.x, t.y, t.r * 0.6 * t.life, 0, Math.PI * 2);
                        ctx.fillStyle = shadowColor;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = shadowColor;
                        ctx.globalAlpha = t.life * 0.4;
                        ctx.fill();
                        ctx.globalAlpha = 1.0;
                    }
                });
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rot + (this.vy * 0.05));
                
                // UNICURSAL HEXAGRAM PATH
                // Vertices for a 6-pointed star polygon
                // Order for unicursal flow: 0 -> 2 -> 4 -> 1 -> 3 -> 5 -> 0?
                // Standard visual:
                const r = this.r * 1.2; 
                const points = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (i * 60 - 90) * Math.PI / 180;
                    points.push({ x: Math.cos(angle) * r, y: Math.sin(angle) * r });
                }

                // Drawing logic for Unicursal:
                // Top(0) -> BottomRight(2) -> TopLeft(5) -> Bottom(3) -> TopRight(1) -> BottomLeft(4) -> Top(0)
                // This sequence connects them in one line while forming the hexagram + central "flower"
                
                ctx.shadowBlur = 25;
                ctx.shadowColor = shadowColor;
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y); // Top
                ctx.lineTo(points[2].x, points[2].y); // Bottom Right
                ctx.lineTo(points[5].x, points[5].y); // Top Left
                ctx.lineTo(points[3].x, points[3].y); // Bottom
                ctx.lineTo(points[1].x, points[1].y); // Top Right
                ctx.lineTo(points[4].x, points[4].y); // Bottom Left
                ctx.lineTo(points[0].x, points[0].y); // Back to Top
                ctx.stroke();
                
                // Central Core
                ctx.fillStyle = "#fff";
                ctx.shadowBlur = 40;
                ctx.shadowColor = "#fff";
                ctx.beginPath();
                ctx.arc(0, 0, 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
            
            jump() {
                this.vy = CONFIG.PLAYER_JUMP_FORCE;
                for (let i = 0; i < 8; i++) game.particles.push(new Particle(this.x, this.y, '#fff', 4));
            }
        }

        class Pillar {
            constructor(lvlIndex) {
                this.x = window.innerWidth;
                this.w = CONFIG.PILLAR_WIDTH;
                this.gap = CONFIG.PILLAR_GAP;
                this.top = Math.random() * (window.innerHeight - this.gap - 100) + 50;
                this.marked = false;
                this.lvl = lvlIndex;
            }
            
            update(speed) { this.x -= speed; }
            
            draw(ctx, conf) {
                // CHROMATIC WALL EFFECT
                // Instead of static accent color, we cycle hue
                const hue = (game.frames * 0.5 + this.x * 0.1) % 360;
                const dynamicColor = `hsl(${hue}, 100%, 60%)`;
                
                ctx.shadowBlur = 20;
                ctx.shadowColor = dynamicColor;
                ctx.strokeStyle = dynamicColor;
                ctx.lineWidth = 3;
                ctx.fillStyle = "rgba(0,0,0,0.5)"; 
                
                // Top
                ctx.fillRect(this.x, -10, this.w, this.top + 10);
                ctx.strokeRect(this.x, -10, this.w, this.top + 10);
                
                // Bottom
                const botY = this.top + this.gap;
                ctx.fillRect(this.x, botY, this.w, window.innerHeight - botY + 10);
                ctx.strokeRect(this.x, botY, this.w, window.innerHeight - botY + 10);
                
                // Reset shadow to prevent bleeding
                ctx.shadowBlur = 0;
            }
        }

        class Orb {
            constructor(x, y) {
                this.x = x; this.y = y; this.r = 8; this.collected = false;
                this.float = Math.random() * Math.PI * 2;
            }
            update(speed) {
                this.x -= speed;
                this.float += 0.1;
                this.y += Math.sin(this.float) * 0.5;
            }
            draw(ctx) {
                if (this.collected) return;
                ctx.fillStyle = '#fff';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#fff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        class Particle {
            constructor(x, y, c, speed) {
                this.x = x; this.y = y; this.c = c;
                this.vx = (Math.random() - 0.5) * speed;
                this.vy = (Math.random() - 0.5) * speed;
                this.life = 1; this.size = Math.random() * 3 + 1;
            }
            update() { this.x += this.vx; this.y += this.vy; this.life -= 0.04; }
            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.c;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.c;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
        }
        
        class Star {
            constructor() {
                this.x = Math.random() * window.innerWidth;
                this.y = Math.random() * window.innerHeight;
                this.size = Math.random() * 2;
                this.speed = Math.random() * 0.5 + 0.1;
                this.alpha = Math.random();
            }
            update() {
                this.y += this.speed;
                if (this.y > window.innerHeight) {
                    this.y = 0; this.x = Math.random() * window.innerWidth;
                }
                this.alpha = 0.3 + Math.sin(game.frames * 0.05 + this.x) * 0.2;
            }
            draw(ctx) {
                const conf = game.gameLevels[game.currentLevelIdx];
                ctx.fillStyle = conf ? conf.accent : '#fff';
                ctx.globalAlpha = this.alpha;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1.0;
            }
        }

        let game;
        document.addEventListener('DOMContentLoaded', () => {
            game = new Game();
        });

    </script>
</body>
</html>
